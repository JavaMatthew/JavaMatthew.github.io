<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ElasticSearch索引</title>
    <link href="undefined2020/08/28/%E5%90%8E%E7%AB%AF/Elasticsearch/ElasticSearch%E7%B4%A2%E5%BC%95/"/>
    <url>2020/08/28/%E5%90%8E%E7%AB%AF/Elasticsearch/ElasticSearch%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h2><img src="/2020/08/28/%E5%90%8E%E7%AB%AF/Elasticsearch/ElasticSearch%E7%B4%A2%E5%BC%95/index.png" srcset="undefined" class="" title="index.png"><p><a href="https://kibana.53site.com/app/kibana#/management/elasticsearch/index_management/indices?_g=()" target="_blank" rel="noopener">kibana</a><br>创建一个索引的基本流程：</p><ol><li>确定索引名</li><li>创建索引轮循器</li><li>创建索引模板</li><li>上传索引</li><li>创建索引模式</li><li>观察数据</li></ol><h3 id="创建索引轮循器"><a href="#创建索引轮循器" class="headerlink" title="创建索引轮循器"></a>创建索引轮循器</h3><p>Name：名称</p><h4 id="Hot-phase"><a href="#Hot-phase" class="headerlink" title="Hot phase"></a>Hot phase</h4><p>先选择是否开启rollover<br>三个max共同限制回滚界限</p><h4 id="Delect-phase"><a href="#Delect-phase" class="headerlink" title="Delect phase"></a>Delect phase</h4><p>如果开启，超过设定时间会删除索引</p><h3 id="创建索引模板"><a href="#创建索引模板" class="headerlink" title="创建索引模板"></a>创建索引模板</h3><h4 id="Logistics"><a href="#Logistics" class="headerlink" title="Logistics"></a>Logistics</h4><p>Name: 索引模板的名称<br>Index patterns：适用于哪些索引例如：rongyun-*适用于所有以rongyun-开头的索引</p><h4 id="Index-settings"><a href="#Index-settings" class="headerlink" title="Index settings"></a>Index settings</h4><p>lifecycle.name: 轮循器的名称<br>lifecycle.rollover_alias: 索引别名，用于轮循器迭代标记索引时使用<br>refresh_interval: 索引刷新时间</p><pre><code class="json">{  &quot;index&quot;: {    &quot;lifecycle&quot;: {      &quot;name&quot;: &quot;rongcloud-history&quot;,      &quot;rollover_alias&quot;: &quot;rongcloud-history&quot;    },    &quot;refresh_interval&quot;: &quot;5s&quot;  }}</code></pre><h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p>索引中数据的类型</p><pre><code class="json">{  &quot;properties&quot;: {    &quot;dateTime&quot;: {      &quot;type&quot;: &quot;date&quot;    },    &quot;timestramp&quot;: {      &quot;type&quot;: &quot;long&quot;    },    &quot;targetId&quot;: {      &quot;type&quot;: &quot;integer&quot;    },    &quot;sendDate&quot;: {      &quot;type&quot;: &quot;date&quot;    },    &quot;fromUserId&quot;: {      &quot;type&quot;: &quot;integer&quot;    },    &quot;groupId&quot;: {      &quot;type&quot;: &quot;integer&quot;    },    &quot;targetType&quot;: {      &quot;type&quot;: &quot;integer&quot;    },    &quot;source&quot;: {      &quot;type&quot;: &quot;text&quot;,      &quot;fields&quot;: {        &quot;keyword&quot;: {          &quot;ignore_above&quot;: 256,          &quot;type&quot;: &quot;keyword&quot;        }      }    },    &quot;msgUID&quot;: {      &quot;type&quot;: &quot;text&quot;,      &quot;fields&quot;: {        &quot;keyword&quot;: {          &quot;ignore_above&quot;: 256,          &quot;type&quot;: &quot;keyword&quot;        }      }    },    &quot;content&quot;: {      &quot;type&quot;: &quot;object&quot;    },    &quot;@timestamp&quot;: {      &quot;type&quot;: &quot;date&quot;    },    &quot;uploadDate&quot;: {      &quot;type&quot;: &quot;date&quot;    },    &quot;classname&quot;: {      &quot;type&quot;: &quot;text&quot;,      &quot;fields&quot;: {        &quot;keyword&quot;: {          &quot;ignore_above&quot;: 256,          &quot;type&quot;: &quot;keyword&quot;        }      }    },    &quot;appId&quot;: {      &quot;type&quot;: &quot;text&quot;,      &quot;fields&quot;: {        &quot;keyword&quot;: {          &quot;ignore_above&quot;: 256,          &quot;type&quot;: &quot;keyword&quot;        }      }    }  }}</code></pre><h3 id="上传索引"><a href="#上传索引" class="headerlink" title="上传索引"></a>上传索引</h3><p>一般有两种方式来进行索引上传，第一种使用rest请求，第二种使用Java配合的API进行操作（本质还是第一种）</p><h3 id="rest请求"><a href="#rest请求" class="headerlink" title="rest请求"></a>rest请求</h3><pre><code class="java">public static void main(String[] args) {        try {            String newIndex = &quot;cn-werewolf-game-total-analysis-2020.07.31-000001&quot;;            List&lt;String&gt; indexList = new ArrayList&lt;&gt;();            indexList.add(&quot;cn-werewolf-game-analysis-*&quot;);            // 判断删除的索引名是否包含合并的新索引名，如果包含直接结束            for (String index : indexList) {                String deleteIndex = index.substring(0, index.length() - 1);                if (newIndex.contains(deleteIndex)) {                    logger.debug(&quot;请检查删除索引数组是否包含新建索引&quot;);                    logger.debug(&quot;删除索引名：&quot; + index + &quot; 新建索引名：&quot; + newIndex);                    return;                }            }            // 合并索引            String result = ESUtil.mergeIndex(newIndex, indexList);            if (!result.contains(&quot;error&quot;)) {                // 删除旧索引                List&lt;String&gt; response = ESUtil.deleteIndex(indexList);                logger.debug(response);                // 给新索引添加别名                String alias = &quot;test-cn-werewolf-game-client&quot;;                String responseAddAlias = ESUtil.addAlias(newIndex, alias);                logger.debug(responseAddAlias);            }        } catch (Exception e) {            e.printStackTrace();        }    }</code></pre><pre><code class="java">public class ESUtil {    private static final String Content_Type = &quot;application/json; charset=UTF-8&quot;;    // 线上es    private static final String uri = &quot;http://123.254.33.254:8978/&quot;;    private static final String Authorization = &quot;Basic asdasdwadsaxs-213xzd&quot;;    public static String mergeIndex(String newIndex, List&lt;String&gt; source) throws IOException {        URL url = new URL(uri + &quot;_reindex&quot;);        HttpURLConnection connection = (HttpURLConnection) url.openConnection();        connection.setDoInput(true); // 设置可输入        connection.setDoOutput(true); // 设置该连接是可以输出的        connection.setRequestMethod(&quot;POST&quot;); // 设置请求方式        connection.setRequestProperty(&quot;Content-Type&quot;, Content_Type);        connection.setRequestProperty(&quot;Authorization&quot;, Authorization);        connection.connect();        StringBuilder reIndex = new StringBuilder(&quot;{\&quot;source\&quot;:{\&quot;index\&quot;:[&quot;);        for (String index : source) {            reIndex.append(&quot;\&quot;&quot;).append(index).append(&quot;\&quot;,&quot;);        }        reIndex.deleteCharAt(reIndex.lastIndexOf(&quot;,&quot;));        reIndex.append(&quot;]},\&quot;dest\&quot;:{\&quot;index\&quot;:&quot;);        reIndex.append(&quot;\&quot;&quot;).append(newIndex).append(&quot;\&quot;&quot;);        reIndex.append(&quot;}}&quot;);        PrintWriter pw = new PrintWriter(new BufferedOutputStream(connection.getOutputStream()));        pw.write(reIndex.toString());        pw.flush();        pw.close();        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));        String line;        StringBuilder result = new StringBuilder();        while ((line = br.readLine()) != null) { // 读取数据            result.append(line).append(&quot;\n&quot;);        }        connection.disconnect();        return result.toString();    }    public static List&lt;String&gt; deleteIndex(List&lt;String&gt; indexList) throws IOException {        List&lt;String&gt; resultList = new ArrayList&lt;&gt;();        for (String index : indexList) {            URL url = new URL(uri + index);            HttpURLConnection connection = (HttpURLConnection) url.openConnection();            connection.setDoInput(true); // 设置可输入            connection.setDoOutput(true); // 设置该连接是可以输出的            connection.setRequestMethod(&quot;DELETE&quot;); // 设置请求方式            connection.setRequestProperty(&quot;Content-Type&quot;, Content_Type);            connection.setRequestProperty(&quot;Authorization&quot;, Authorization);            connection.connect();            BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));            String line;            StringBuilder result = new StringBuilder();            while ((line = br.readLine()) != null) { // 读取数据                result.append(line).append(&quot;\n&quot;);            }            resultList.add(result.toString());            connection.disconnect();        }        return resultList;    }    public static String addAlias(String index,String alias) throws IOException {        URL url = new URL(uri + index+&quot;/_alias/&quot;+alias);        HttpURLConnection connection = (HttpURLConnection) url.openConnection();        connection.setDoInput(true); // 设置可输入        connection.setDoOutput(true); // 设置该连接是可以输出的        connection.setRequestMethod(&quot;PUT&quot;); // 设置请求方式        connection.setRequestProperty(&quot;Content-Type&quot;, Content_Type);        connection.setRequestProperty(&quot;Authorization&quot;, Authorization);        connection.connect();        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));        String line;        StringBuilder result = new StringBuilder();        while ((line = br.readLine()) != null) { // 读取数据            result.append(line).append(&quot;\n&quot;);        }        connection.disconnect();        return result.toString();    }}</code></pre><h4 id="java操作"><a href="#java操作" class="headerlink" title="java操作"></a>java操作</h4><pre><code class="java">package com.mega.rongyunhistory.mapper;import java.io.IOException;import java.util.*;import java.util.stream.Collectors;import org.elasticsearch.action.admin.indices.alias.Alias;import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.reindex.BulkByScrollResponse;import org.elasticsearch.index.reindex.DeleteByQueryRequest;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.alibaba.fastjson.JSONObject;import com.mega.rongyunhistory.common.ElasticsearchCommon;import com.mega.rongyunhistory.model.RongCloudEntity;import lombok.extern.slf4j.Slf4j;@Slf4j@Componentpublic class ElasticsearchMapper {    private final RestHighLevelClient restHighLevelClient;    @Autowired    public ElasticsearchMapper(RestHighLevelClient restHighLevelClient) {        this.restHighLevelClient = restHighLevelClient;    }    /**     * 将批量数据上传ES     *      * @param rongCloudEntityList 批量数据     */    public void upload2Elasticsearch(List&lt;RongCloudEntity&gt; rongCloudEntityList) {        BulkRequest bulkRequest = new BulkRequest();        createIndex();        for (RongCloudEntity rongCloudEntity : rongCloudEntityList) {            IndexRequest indexRequest = new IndexRequest(ElasticsearchCommon.INDEXNAME_ALIA);            indexRequest.source(JSONObject.toJSONString(rongCloudEntity), XContentType.JSON);            bulkRequest.add(indexRequest);        }        try {            restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);        } catch (IOException e) {            log.error(e.getLocalizedMessage());        }        log.debug(&quot;-------上传结束---------&quot;);    }    /**     * ES创建索引     */    @SuppressWarnings(&quot;deprecation&quot;)    public void createIndex() {        if (!isExist(ElasticsearchCommon.INDEXNAME)) {            CreateIndexRequest createIndexRequest = new CreateIndexRequest();            createIndexRequest.index(ElasticsearchCommon.INDEXNAME);            createIndexRequest.alias(new Alias(ElasticsearchCommon.INDEXNAME_ALIA));            try {                restHighLevelClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);            } catch (IOException e1) {                log.error(e1.getLocalizedMessage());            }        }    }    /**     * 判断索引是否存在     *      * @param index 索引名     * @return 是否存在     */    public boolean isExist(String index) {        GetIndexRequest getIndexRequest = new GetIndexRequest(index);        boolean exit = true;        try {            exit = restHighLevelClient.indices().exists(getIndexRequest, RequestOptions.DEFAULT);        } catch (IOException e) {            e.printStackTrace();            log.error(e.getLocalizedMessage());        }        return exit;    }    /**     * 根据时间获取上传时间列表     *      * @param start     * @param end     * @return     */    public List&lt;Date&gt; selectByDate(Date start, Date end) {        Set&lt;Date&gt; set = new HashSet&lt;Date&gt;();        // 创建并设置SearchSourceBuilder对象，也就是设置查询条件        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();        boolQueryBuilder.filter(QueryBuilders.rangeQuery(&quot;uploadDate&quot;).from(start).to(end));        searchSourceBuilder = searchSourceBuilder.query(boolQueryBuilder);        searchSourceBuilder.fetchSource(&quot;uploadDate&quot;, null);        // 创建并设置SearchRequest对象        SearchRequest searchRequest = new SearchRequest(ElasticsearchCommon.INDEXNAME_ALIA);        searchRequest.source(searchSourceBuilder);        // 查询        try {            SearchResponse search = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);            SearchHit[] hits = search.getHits().getHits();            for (SearchHit hit : hits) {                Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();                Date date = new Date((long) sourceAsMap.get(&quot;uploadDate&quot;));                set.add(date);            }        } catch (IOException e) {            log.error(&quot;selectByDate查询出错&quot;);            log.error(e.getLocalizedMessage());        }        return new ArrayList&lt;&gt;(set);    }    public void deletByDate(Date lastUploadDate) {        DeleteByQueryRequest delete = new DeleteByQueryRequest(ElasticsearchCommon.INDEXNAME_ALIA);        delete.setQuery(QueryBuilders.rangeQuery(&quot;uploadDate&quot;).from(lastUploadDate));        delete.setRefresh(true);        try {            BulkByScrollResponse response = restHighLevelClient.deleteByQuery(delete, RequestOptions.DEFAULT);            log.debug(&quot;删除文档返回结果&quot; + response.getStatus().getUpdated());        } catch (IOException e) {            log.error(e.getLocalizedMessage());        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="undefined2020/08/27/%E5%90%8E%E7%AB%AF/Java/JVM/%E5%A0%86/"/>
    <url>2020/08/27/%E5%90%8E%E7%AB%AF/Java/JVM/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li><li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</li><li>堆内存的大小是可以调节的。</li><li>《Java虚拟机规范》规定，堆可以处于物理撒花姑娘不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</li></ul><h2 id="内存细分"><a href="#内存细分" class="headerlink" title="内存细分"></a>内存细分</h2><img src="/2020/08/27/%E5%90%8E%E7%AB%AF/Java/JVM/%E5%A0%86/%E5%A0%86%E7%A9%BA%E9%97%B4.png" srcset="undefined" class="" title="堆空间"><p>新生区+养老区+元空间</p><ul><li>Young Generation Space 新生区 Young/New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><img src="/2020/08/27/%E5%90%8E%E7%AB%AF/Java/JVM/%E5%A0%86/%E5%B7%AE%E5%BC%82.png" srcset="undefined" class="" title="差异"><h2 id="堆空间的大小设置和查看"><a href="#堆空间的大小设置和查看" class="headerlink" title="堆空间的大小设置和查看"></a>堆空间的大小设置和查看</h2><ul><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。<ul><li>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li><li>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li></ul></li><li>一旦堆区中的内存大小超过”-Xmx”所指定的最大内存时，将会跑出OutOfMemoryError异常</li><li>通常会将-Xms和-Xmx两个参数配置相同的，<strong>其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></li><li>默认情况下，初始内存大小: 物理电脑内存大小/64<pre><code>       最大内存大小: 物理电脑内存大小/4</code></pre></li></ul><pre><code class="java">-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小    -X 是jvm的运行参数    ms 是memory start-Xmx 用来设置对空（年轻代+老年代）的最大内存大小</code></pre><ul><li>手动设置：-Xms600m -Xmx600m<br>开发中建议将初始堆内存和最大的堆内存设置成相同的值</li><li>查看设置的参数：方式一：jps / jstart -gc 进程id<pre><code>           方式二：-XX:+PrintGCDetails</code></pre></li></ul><pre><code class="java">-Xms: 575 M-Xmx: 575 M系统内存大小为：35.9375 G系统内存大小为：2.24609375 GHeap PSYoungGen      total 179200K, used 9216K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)  eden space 153600K, 6% used [0x00000000f3800000,0x00000000f41001a0,0x00000000fce00000)  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000) ParOldGen       total 409600K, used 0K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)  object space 409600K, 0% used [0x00000000da800000,0x00000000da800000,0x00000000f3800000) Metaspace       used 3176K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>179200K = 153600 + 25600<br>jvm默认from和to只有一个有数据<br>所以575 = （153600 + 25600 + 409600）/1024</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mina简介</title>
    <link href="undefined2020/08/17/%E5%90%8E%E7%AB%AF/Mina/Mina%E7%AE%80%E4%BB%8B/"/>
    <url>2020/08/17/%E5%90%8E%E7%AB%AF/Mina/Mina%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Mina服务端"><a href="#Mina服务端" class="headerlink" title="Mina服务端"></a>Mina服务端</h2><blockquote><p>Mina apache 开发的一个开源的网络通信框架，基于我们java NIO来实现</p></blockquote><ol><li>NIOSocket</li><li>设置编码解码过滤器</li><li>设置一些session属性</li><li>绑定一个端口</li></ol><pre><code class="shell">cmd访问本地服务器telnet 127.0.0.1 7080</code></pre><h2 id="Mina客户端"><a href="#Mina客户端" class="headerlink" title="Mina客户端"></a>Mina客户端</h2><p>替代cmd的telnet</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><ol><li>mina在应用程序中出于什么地位<br> 主要屏蔽了网络通信的一些细节，对socket进行封装，并且是NIOde一个实现架构，可以帮助我们快速的开发网络通信。常常用于游戏的开发，中间件等服务端程序。</li><li>IOService接口<br> 用于描述我们的客户端和服务端接口，其子类是connector和Acceptor，分别用于描述我们的客户端和服务端。IOproceser多线程环境来处理我们的连接请求流程。IOFilter提供数据的过滤工作：包括编解码，日志等信息的过滤，Hanlder就是我们的业务对象，自定义的handler需要实现IOHandlerAcceptor</li><li>大致看看我的类图结构<pre><code>                 IOService</code></pre> IOconnector                         IOAcceptor<br> NIOSocketConnector                  NIOSocketAcceptor</li></ol><p>IOsession：描述的是客户端和服务端连接的描述。常常用于接受和发送数据。</p><p>总结： IOconnector -&gt; IOProcessor -&gt; IOFilter -&gt; Handler<br>       IOAcceptor -&gt; IOProcessor -&gt; IOFilter -&gt; Handler</p><h2 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h2><ol><li>长连接：通信双方长期的保持一个连接状态不断开，比如qq，当我们登录qq的时候，我们就去连接腾讯服务器，一旦建立连接，就不断开，除非发生异常，这样的范式就是长连接，对于长连接比较耗费IO资源。</li><li>短连接：通信双方不是保持一个长期的连接状态，比如http协议，当客户端发起http请求，服务器处理http请求，当服务器处理完成之后，返回客户端数据后就断开连接，对于下次的连接请求需要重新发起。</li></ol><h2 id="IOService"><a href="#IOService" class="headerlink" title="IOService"></a>IOService</h2><ol><li>它实现了对网络通信的客户端和服务端之间的抽象，用于描述客户端的子接口IOConnector，用于描述服务端的子接口IOAcceptor。</li><li>它的作用是可以管理我们网络通信的客户端和服务端，并且可以管理连接双方的会话session，同样可以添加过滤器。</li><li>IOService类结构<pre><code>                             IOService                 IOAcceptor                  IOConnector                             abstractIoService                 abstractIOAcceptor          abstractIOConnector                 NioSocketAcceptor           NioSocketConnector</code></pre></li></ol><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h3 id="IOService常用API"><a href="#IOService常用API" class="headerlink" title="IOService常用API"></a>IOService常用API</h3><ol><li>getFilterChain() 获得过滤器链</li><li>setHandler(IoHandler handelr) 设置我们真正业务handler</li><li>getSessionConfig() 得到我们会话的配置信息</li><li>dispose() 在我们完成关闭连接的时候所调用的方法</li></ol><h3 id="IOConnector常用API"><a href="#IOConnector常用API" class="headerlink" title="IOConnector常用API"></a>IOConnector常用API</h3><ol><li>connect(SocketAddress remoteAddress) 主要用户发起一个连接请求</li><li>setConnectTimeout(int connectTimeout) 连接超时的设置</li></ol><h3 id="IoAcceptor常用API"><a href="#IoAcceptor常用API" class="headerlink" title="IoAcceptor常用API"></a>IoAcceptor常用API</h3><ol><li>bind(SocketAddress localAddress) 绑定端口</li><li>getLocalAddress() 获得本地ip地址</li></ol><h3 id="NioSocketAcceptor常用API"><a href="#NioSocketAcceptor常用API" class="headerlink" title="NioSocketAcceptor常用API"></a>NioSocketAcceptor常用API</h3><ol><li>accept（IoProcessor&lt;NioSession&gt; processor, ServerSocketChannel handle) 接受一个连接</li><li>open(SocketAddress localAddress) 打开一个socketchannel</li><li>select() 获得我们的选择器</li></ol><h3 id="NIOSocketConnector常用API"><a href="#NIOSocketConnector常用API" class="headerlink" title="NIOSocketConnector常用API"></a>NIOSocketConnector常用API</h3><ol><li>connect(SocketChannel handle,SocketAddress remoteAddress)用于描述连接请求</li><li>register(SocketChannel handle,AbstractPollingIoConnector.ConnectionRequest request) 注册我们的IO事件</li><li>select(int timeout) 返回选择器</li></ol><h2 id="IOFilter"><a href="#IOFilter" class="headerlink" title="IOFilter"></a>IOFilter</h2><blockquote><p>IOFilte:对应用程序和网络传输，就是二进制数据和对象之间的相互转化，有相应的解码和编码器。这也是我们过滤器一种，我们对过了长期还可以做日志、消息确认等功能。它是在应用层和我们的业务层之间的过滤层</p></blockquote><p>Client：业务handler之前会调用我们的过滤器<br>Server：同样在我们接收到数据的时候和发送数据的时候也调用了过滤器，然后交给我嗯的handler</p><h2 id="IOSession"><a href="#IOSession" class="headerlink" title="IOSession"></a>IOSession</h2><ol><li>主要描述我们网络通信双方所建立的连接之间描述。</li><li>可以完成对于连接的一些管理，可以发送或者读取数据，并且可以设置我们会话的上下文信息。</li></ol><h3 id="IOSession常用API"><a href="#IOSession常用API" class="headerlink" title="IOSession常用API"></a>IOSession常用API</h3><ol><li>getAttribute(Object key) 根据key获获得设置的上下文属性。</li><li>setAttribute(Object key,Object value)设置上下文属性</li><li>removeAttribute(Object key) 删除上下文属性</li><li>write(Object message)发送数据</li><li>read() 读取数据</li></ol><h2 id="IOSessionConfig"><a href="#IOSessionConfig" class="headerlink" title="IOSessionConfig"></a>IOSessionConfig</h2><ol><li>提供我们对连接的配置信息的描述，比如缓冲区的设置等等。</li><li>设置读写缓冲区的信息，读和写的空闲时间以及设置读写超时信息。</li></ol><h3 id="IOSessionConfig常用API"><a href="#IOSessionConfig常用API" class="headerlink" title="IOSessionConfig常用API"></a>IOSessionConfig常用API</h3><ol><li>getBothIdleTime() 获得读写通用的空闲时间</li><li>setIdleTime(IdleStatus status,int idleTime)设置我们的读或者写的空闲时间</li><li>setReadBufferSize(int readBufferSize) 设置读缓冲区大小</li><li>setWriteTimeout(int writeTimeout) 设置写超时时间</li></ol><h2 id="IOProcessor"><a href="#IOProcessor" class="headerlink" title="IOProcessor"></a>IOProcessor</h2><ol><li>Processor：是以NIO为基础实现的以多线程的方式来完成我们读写工作。</li><li>Processor的作用：是为我们的filter读写原始数据的多线程环境，如果mina不去实现的话，我们来实现NIO的话需要自己写一个非阻塞读写的多线程的环境。</li><li>配置Processor的多线程环境<ul><li>通过NioSocketAcceptor(int processorCount)构造函数可以指定多线程的个数</li><li>通过NioSocketConnector(int processorCount)构造函数也可以指定多线程的个数</li></ul></li></ol><h2 id="IOBuffer"><a href="#IOBuffer" class="headerlink" title="IOBuffer"></a>IOBuffer</h2><p>基于java NIO 中的ByteBuffer做了封装，用户操作缓冲区中的数据，包括基本数据类型以及字节数组和一些对象，其本质就是可扩展的byte数组</p><p>IoBuffer的索引属性</p><img src="/2020/08/17/%E5%90%8E%E7%AB%AF/Mina/Mina%E7%AE%80%E4%BB%8B/iobuffer.png" srcset="undefined" class="" title="iobuffer"><ol><li>Capacity：代表当前缓冲区的大小</li><li>Position：理解成当前读写位置，也可以理解成下一个刻度数据单元的位置，Position&lt;=Capicity的时候可以完成数据的读写操作</li><li>Limit：就是下一个不可以被读写缓冲区的单元的位置。Limit&lt;=Capacity</li></ol><h3 id="IOBuffer常用的API"><a href="#IOBuffer常用的API" class="headerlink" title="IOBuffer常用的API"></a>IOBuffer常用的API</h3><ol><li>static allocate(int capacity) 开辟已制定的大小缓冲区的空间</li><li>setAutoExpand(boolean autoExpand) 可以设置是否支持动态的扩展</li><li>putString(CharSequence val,CharsetEncoder encoder),putInt(int calue)等等方法实现让缓冲区中法如数据Putxxx()</li><li>flip() 就是把缓冲区的数据放入到流中，往往在发送数据之前调用</li><li>hasRemaining() 缓冲区中是否有数据: boolean是关于position&lt;=limit=true,否则返回false</li><li>remaining() 返回的是缓冲区中可读数据的大小，limit-position的值</li><li>Rest和Clear<br> reset() 实现情况数据<br> Clear() 实现数据的覆盖，position=0，重新开始都我们缓冲区的数据</li></ol><h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><ol><li>自定义的编解码工厂：要实现编解码工厂就要实现ProtocolCodecFactory接口。</li><li>实现自定义编解码器：<ol><li>实现自定义解码器：实现ProtocolDecoder接口</li><li>实现自定义编码器：实现ProtocolEncoder接口</li></ol></li><li>根据我们自定义的编解码工厂来获得编解码对象</li></ol><h3 id="为什么要使用自定义的编码器"><a href="#为什么要使用自定义的编码器" class="headerlink" title="为什么要使用自定义的编码器"></a>为什么要使用自定义的编码器</h3><p>因为现实中往往不是通过一个字符串就可以传输所有的信息。我们传输的是自定义的协议包。并且能在应用程序和网络通信中存在对象和二进制流之前转化关系。所以我们需要结合业务编写自定义的编解码器</p><h3 id="常用的自定义协议的方法"><a href="#常用的自定义协议的方法" class="headerlink" title="常用的自定义协议的方法"></a>常用的自定义协议的方法</h3><ol><li>定长的方式：Aa,bb,cc,ok,po等这样的通信方式</li><li>定界符：helloworld|watchmend|…|…|通过特殊的符号来区别消息，这样方式会出现粘包，半包等现象。</li><li>自定义协议包：包头+包体，包头：数据包的版本号，以及整个数据包长度，包体：实际数据。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Mina</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mina</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器数据持久化</title>
    <link href="undefined2020/08/05/%E5%90%8E%E7%AB%AF/Docker/Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>2020/08/05/%E5%90%8E%E7%AB%AF/Docker/Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><blockquote><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：</p></blockquote><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，及时容器被删除</li></ul><p>注意：<strong>数据卷的使用，类似于Linux下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷</strong></p><pre><code class="docker">docker run -p 3306:3306 --name mysql \-v /usr/local/docker/mysql/conf:/etc/mysql \-v /usr/local/docker/mysql/logs:/var/log/mysql \-v /usr/local/docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=root \-d mysql</code></pre><p>如果执行sql失败吧/etc/mysql.conf.d/mysqldump.cnf的<code>max_allowed_packet = 16M</code>追加到配置文件末尾<br><code>echo &quot;max_allow_packet = 128M&quot; &gt;&gt; mysqld.cnf</code></p><h2 id="将容器里的文件复制到宿主机"><a href="#将容器里的文件复制到宿主机" class="headerlink" title="将容器里的文件复制到宿主机"></a>将容器里的文件复制到宿主机</h2><pre><code class="docker">docker cp mysql:/etc/mysql .复制mysql容器的/etc/mysql文件夹到当前目录mv *.* ..移动所有文件到上级目录rm -fr mysql删除空文件夹</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用各种嵌套类的时机</title>
    <link href="undefined2020/07/31/%E5%90%8E%E7%AB%AF/Java/%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E6%97%B6%E6%9C%BA/"/>
    <url>2020/07/31/%E5%90%8E%E7%AB%AF/Java/%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="嵌套类（nested-class）"><a href="#嵌套类（nested-class）" class="headerlink" title="嵌套类（nested class）"></a>嵌套类（nested class）</h2><blockquote><p>嵌套类是指被定义在另一个类内部的类</p></blockquote><p>嵌套类的分类：</p><ol><li>静态成员类（static member class）</li><li>非静态成员类（nonstatic member class）</li><li>匿名类（anonymous class）</li><li>局部类（local class）</li></ol><p>除了第一种之外，其他三种被称为内部类（inner class）</p><h2 id="静态成员类用法"><a href="#静态成员类用法" class="headerlink" title="静态成员类用法"></a>静态成员类用法</h2><blockquote><p>常见的用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。</p></blockquote><p>例如：考虑一个枚举类，它描述了计算机支持的各种操作。Operation枚举应该时Calculator类的公有静态成员类，然后，Calculator类的客户端就可以用诸如<code>Calculator.Operation.PLUS</code>和<code>Calculator.Operation.MINUS</code>这样的名称来引用 这些操作。</p><h2 id="非静态成员类用法"><a href="#非静态成员类用法" class="headerlink" title="非静态成员类用法"></a>非静态成员类用法</h2><blockquote><p>常见的用法时定义一个Adapter，它允许外部类的实例被看作时另一个不相关的类的实例。</p></blockquote><p>例如：Map接口的是西安往往 使用非静态成员类来实现他们的集合试图（collection view），这些集合视图时由Map的keySet、entrySet和Values方法返回的。同样诸如Set和List这种集合接口的实现往往也是使用非静态成员类 来实现他们的迭代器（iterator）</p><p><strong>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使他成为静态成员类，而不是非静态成员类。</strong>如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就不能使用非静态成员类，因为非静态成员类的实例必须要有一个外围实例。</p><h2 id="匿名类用法"><a href="#匿名类用法" class="headerlink" title="匿名类用法"></a>匿名类用法</h2><blockquote><p>匿名类可以出现在代码中任何允许存在表达式的地方。常见的用法时动态地创建函数对象、过程对象、静态工厂方法的内部。</p></blockquote><p>例如：Comparator(函数对象)，Runnable(过程对象)，new AbstractList{@Override…}(静态工厂方法的内部)</p><h2 id="局部类用法"><a href="#局部类用法" class="headerlink" title="局部类用法"></a>局部类用法</h2><blockquote><p>局部类时四种嵌套类中 用的最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。</p></blockquote><p>总之如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个只想其外围实例的引用，就要把成员类做成非静态的否则就做成静态的。<br>假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例。并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类；否则就做成局部类。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker命令</title>
    <link href="undefined2020/07/28/%E5%90%8E%E7%AB%AF/Docker/Docker%E5%91%BD%E4%BB%A4/"/>
    <url>2020/07/28/%E5%90%8E%E7%AB%AF/Docker/Docker%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><pre><code class="shell">$ curl -fsSL get.docker.com -o get-docker.sh$ sh get-docker.sh --mirror Aliyun           # 从阿里云国内资源上下载$ curl -L &quot;https://github.com/docker/compose/releases/download/1.26.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose # 安装docker compse$ chmod +x /usr/local/bin/docker-compose # 加可执行权限</code></pre><h2 id="Ubuntu-16-04-、Debian8-、CentOS7"><a href="#Ubuntu-16-04-、Debian8-、CentOS7" class="headerlink" title="Ubuntu 16.04+、Debian8+、CentOS7"></a>Ubuntu 16.04+、Debian8+、CentOS7</h2><p>对于使用systemd的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容（如果文件不存在请新建该文件）</p><pre><code class="json">{    &quot;registry-mirrors&quot;: [        &quot;https://registry.docker-cn.com&quot;    ]}</code></pre><p><strong>注意，一定要保证该文件符合json规范，否则Docker将不能启动</strong><br>之后重启服务</p><pre><code class="shell">systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><pre><code class="docker">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]docker images 展示所有镜像</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>\相当于window里的回车</p><pre><code class="docker">$ docker run -it --rm \    ubuntu:16.04 \    bash$ cat /etc/os-relaesase$ exit</code></pre><ul><li>-it: 以交互的形式运行容器。这是两个参数，一个是-i ：交互式操作，一个是-t ：终端。</li><li>-rm: 这个参数是说容器退出后自动删除容器，默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动<code>docker rm</code>。</li><li>bash: 放在镜像名后的是命令，这里我们希望有个交互式Shell，因此用的是bash。</li><li>exit: 退出系统</li></ul><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>在run命令后加上-d参数</p><pre><code class="docker">docker run -d tomcat</code></pre><h3 id="交互的方式进入容器"><a href="#交互的方式进入容器" class="headerlink" title="交互的方式进入容器"></a>交互的方式进入容器</h3><p><code>docker exec -it [容器ID] bash</code></p><h3 id="交互的方式启动容器"><a href="#交互的方式启动容器" class="headerlink" title="交互的方式启动容器"></a>交互的方式启动容器</h3><p><code>docker run -it tomcat bash</code></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除容器是<code>docker rmi 容器id</code><br>删除镜像是<code>docker rm 镜像id</code></p><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><pre><code class="shell">cd /usr/local/mkdir dockercd dockermkdir tomcatcd tomcatvi DockerfileFROM tomcat:8.5.32RUN echo &quot;Hello Docker&quot; &gt; /usr/local/tomcat/webapps/ROOT/index.htmlFROM tomcat:8.5.32WORKDIR /usr/local/tomcat/webapps/ROOT/RUN rm -fr *RUN echo &quot;Hello Docker&quot; &gt; /usr/local/tomcat/webapps/ROOT/index.html// 构建镜像docker build -t mytomcat .</code></pre><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到<code>docker build</code>命令最后有一个<code>.</code>。表示当前目录，而<code>Dockerfile</code>就在当前目录，因此不少初学者以为这个路径是指<code>Dockerfile</code>所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>，那么什么是上下文呢？</p><p>首先我们要理解<code>docker build</code>的工作原理。Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API，被称为Docker Remote API，而如<code>docker</code>命令这样的客户端工具，则是通过这组API与Docker引擎交互，从而完成各种功能。因此，虽然标明上我们像是在本机执行各种<code>docker</code>功能，但实际上，一切都是使用的远程调用形式在服务端（Docker引擎）完成。也因为这种C/S设计，让我们操作远程服务器的Docker引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有与定制都会通过<code>RUN</code>指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而<code>docker build</code>命令构建镜像，其实并非在本地构建，而是在服务端，也就是Docker引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code>命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需要的的一起文件。</p><pre><code class="shell">COPY ./package.json/app/</code></pre><p>这并不是要赋值执行<code>docker build</code>命令所在的目录下的<code>package.json</code>,也不是复制<code>Dockerfile</code>所在目录下的<code>package.json</code>，而是复制<strong>上下文（context）</strong>目录下的<code>package.json</code>。</p><p>因此，<code>COPY</code>这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么<code>COPY ../package.json/app</code>或者<code>COPY /opt/xxxx/app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，DOcker引擎无法获得这些位置的文件。如果真的需要那些文件，应该讲他们复制到上下文目录中去。</p><p>现在就可以理解刚才的，命令<code>docker build -t nginx:v3 .</code>中的这个<code>.</code>，实际上是在指定上下文的目录，<code>docker build</code>命令会将该目录下的内容打包交给DOcker引擎一帮助构建镜像。</p>{% asset_img 上下文.png 上下文 %}<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><pre><code class="docker">FROM [镜像名：版本号]选取一个镜像WORKDIR [工作目录]切换工作目录RUN 运行一个容器，后面可以接shell命令ADD [文件名] [粘贴的目标路径]复制文件，如果是压缩包并且格式为tar、gzip、bzip2、xz就会复制后解压缩EXPOSE &lt;端口1&gt; [&lt;端口2&gt; ...]暴露端口</code></pre><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h2><blockquote><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。Docker-Compose将所管理的容器分为三层，分别是项目（project）-&gt;服务（service）-&gt;容器（container）。</p></blockquote><p>在<code>/usr/local/docker/tomcat/</code>下编写docker-compose.yml文件</p><pre><code class="yml">version: &#39;4&#39; # docker-compose的版本号service: # 服务  tomcat: # 服务名（随便起名）    restart: always # 总是重启    image: tomcat:8.5.2   # 镜像名tomcat    container_name: tomcat:8.5.2 # 容器名    ports:      - 8080:8080  redis:    image: &quot;redis&quot;</code></pre><p>如果没有tomcat：8.5.2会先下载然后再启动</p><pre><code class="shell"># docker-compose命令必须在有docker-compose.yml文件所在的目录下，因为上下文docker-compose up # 运行配置文件docker-compose down # 删除容器docker-compose up -d # 运行配置文件中的服务，以守护态的形式docker-compose logs tomcat # 看tomcat容器日志</code></pre>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker简介</title>
    <link href="undefined2020/07/27/%E5%90%8E%E7%AB%AF/Docker/Docker%E7%AE%80%E4%BB%8B/"/>
    <url>2020/07/27/%E5%90%8E%E7%AB%AF/Docker/Docker%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>更高效的利用云资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li><li>更轻松的维护和扩展</li></ol><blockquote><p>Docker使用客户端-服务器(C/S)架构模式，使用原厂API来管理和创建Docker容器。<br>  Docker容器通过Docker镜像来创建。<br>  容器与镜像的关系类似于面向对象编程中的对象与类</p></blockquote><table><thead><tr><th>标题</th><th>说明</th></tr></thead><tbody><tr><td>镜像（Images）</td><td>Docker镜像是用于创建Docker容器的模板</td></tr><tr><td>容器（Container）</td><td>容器是独立运行的一个或一组应用</td></tr><tr><td>客户端（Client）</td><td>Docker客户端通过命令行或者其他工具使用Docker API与Docker的守护进程通信。</td></tr><tr><td>主机（Host）</td><td>一个物理或者虚拟的机器用于执行DOcker守护进程和容器。</td></tr><tr><td>仓库（Registry）</td><td>Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。</td></tr><tr><td>Docker Machine</td><td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台撒花姑娘安装Docker，比如VitrualBox、Digtal Ocean、Microsoft Azure</td></tr></tbody></table><p>Docker仓库 -&gt; Docker镜像 -&gt; Docker容器</p><h2 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h2><p>分为公有仓库和私有仓库</p><p>Docker CE 社区版 免费版<br>Docker EE 企业版 收费版</p><h2 id="Dockers镜像"><a href="#Dockers镜像" class="headerlink" title="Dockers镜像"></a>Dockers镜像</h2><p>Docker镜像采用的是分层存储技术，下载也是一层一层的。</p><h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里的表示的所占用空间和在DockerHub上看到的镜像的大小不同。比如，ubuntu:16.04镜像大小，在这里是127MB，但是在DockerHub显示的确实50MB。这是因为DokrHub中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此Docker Hub所显示的大小是网络传输中更关心的流量大小，而<code>docker image ls</code>显示的是镜像下载到本地后，解压的大小，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code>列表中的镜像体积综合并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于Docker使用Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间可能要比这个列表镜像大小的总和要小的多。<br>你可以通过以下命令来查看镜像、容器、、数据卷所占用的空间。</p><pre><code class="docker">$ docker system df</code></pre><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像没有仓库名，也没有标签，均为<code>&lt;none&gt;</code></p><pre><code class="docker">&lt;none&gt;  &lt;none&gt;  00284dsa8df   5 days ago    324MB</code></pre><p>这个镜像原本是有镜像名和标签的，原来为<code>mongo:3.2</code>,随着官方维护发布新版本，重新<code>docker pull mongo:3.2</code>时，<code>mongo:3.2</code>这个镜像名呗转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了<code>&lt;none&gt;</code>。除了<code>docker pull</code>可能导致这种情况，<code>docker build</code>也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为<code>&lt;none&gt;</code>的镜像。这类无标签镜像也被成为虚悬镜像，可以使用<code>docker images ls -f dangling=true</code></p><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用<code>dicjer image prune</code>命令删除</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件权限管理</title>
    <link href="undefined2020/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>2020/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h2><p>ls -al使用ls不带参数只显示文件名称，通过ls -al可以显示文件或者目录的权限信息。<br>ls -l 文件名 显示信息包括：<br>第一个为文件类型，以后三个符号为一组。<br>文件类型（d 目录，- 普通文件，l 链接文件），文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称<br>|-rw-r–r–|  1 |root| root|  322 |7月  21 22:25 |.bash_history|<br>|———-|—-|—-|——|—–|————–|————-|<br>|文档类型及权限|连接数|文档所属用户|文档所属组|文档大小|文档最后被修改日期|文档名称|</p><table><thead><tr><th>-</th><th>rw-</th><th>r–</th><th>r–</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><ul><li>-: 普通文件</li><li>rw-: 说明用户组root有读写权限，没有运行权限</li><li>r–: 表示用户root只有读权限，没有写和运行的权限</li><li>r–: 其他用户只有读权限，没有写权限和运行的权限</li></ul><h3 id="文档所属用户和所属组"><a href="#文档所属用户和所属组" class="headerlink" title="文档所属用户和所属组"></a>文档所属用户和所属组</h3><p>就是文档属于哪个用户和用户组。文件所属用户和组时可以更改的</p><h3 id="文档大小"><a href="#文档大小" class="headerlink" title="文档大小"></a>文档大小</h3><p>默认是bytes</p><h2 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h2><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>是change owener的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组<br><code>chown [-R] 用户名称 文件或者目录</code><br><code>chown [-R] 用户名称 用户组名称 文件或目录</code><br>-R: 进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变访问权限</p><p><code>chmod [who] [+|-|=] [mode] 文件名</code></p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>表示操作对象可以是一下字母的一个或者组合</p><ul><li>u : 用户user</li><li>g : 用户组group</li><li>o : 表示其他用户</li><li>a : 表示所以搜用户是系统默认的</li></ul><h2 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h2><p>数字设定法中数字表示的含义：</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = x</li><li>2 表示有可写权限 = w</li><li>4 表示有刻度权限 = r</li></ul><p>用数字来表示权限如<code>chmod 755 file_name</code><br>7 = 1+2+4, 5 = 1 + 4</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux用户和组管理</title>
    <link href="undefined2020/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <url>2020/07/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Linux操作系统个还是一个多用户系统，他允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，是的每个用户工作都不受干扰。</p><h2 id="使用Root用户"><a href="#使用Root用户" class="headerlink" title="使用Root用户"></a>使用Root用户</h2><p>给root账户设置密码<code>sudo passwd root</code><br>切换到root账户<code>su</code><br>允许root账户远程连接 <code>vi /etc/ssh/sshd_config</code></p><pre><code class="shell"># Authentication:LoginGraceTime 2m# PermiRootLogin prohibit-password  注释此行PermitRootLogin yes            #  加入此行StrictModes yes更改完文件后保存重启服务service ssh restart</code></pre><h2 id="组账户说明"><a href="#组账户说明" class="headerlink" title="组账户说明"></a>组账户说明</h2><h3 id="私有组"><a href="#私有组" class="headerlink" title="私有组"></a>私有组</h3><p>当创建一个用户时没有指定属于哪个组，Linux救护建立一个与用户同名的私有组，次私有组只含有该用户</p><h3 id="标准组"><a href="#标准组" class="headerlink" title="标准组"></a>标准组</h3><p>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的位附加组。</p><h2 id="账户文件说明"><a href="#账户文件说明" class="headerlink" title="账户文件说明"></a>账户文件说明</h2><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>每一行代表一个账户，众多账户是系统正常运行所必须的，例如bin，nobody每行定义一个用户账户，此文件对所有用户刻度。每行账户包含如下信息：<br><code>root:x0:0:root:/root:/bin/bash</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux软件的安装与卸载</title>
    <link href="undefined2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
    <url>2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="软件的安装与卸载"><a href="#软件的安装与卸载" class="headerlink" title="软件的安装与卸载"></a>软件的安装与卸载</h2><p>apt 软件包管理程序<br>ubuntu 下载软件包管理是通过apt<br>centos通过yum来进行软件包管理程序</p><p>安装文件<br>    安装版<br>    绿色版  压缩包</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>安装：<code>sudo apt-get install nano</code><br>删除：<code>sudo apt-get remove nano</code><br>查看系统版本：<code>lsb_release -a</code></p><pre><code class="linux">Distributor ID: DeepinDescription:    Deepin 20 BetaRelease:        20 BetaCodename:       n/a</code></pre><p>编辑数据源：<code>vi /etc/apt/sources.list</code><br>将数据源改为阿里的镜像数据源<code>deb [by-hash=force] https://mirrors.aliyun.com/deepin/ panda main contrib non-free</code><br>更新数据源：<code>sudo apt-get update</code><br>更新软件,就重新安装一遍<br>纯净卸载：<code>sudo apt-get autoremove nano</code>,连带nano依赖一起删除</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java实体类中为何不用基本数据类型</title>
    <link href="undefined2020/07/22/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/Java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%B8%8D%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/07/22/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/Java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%B8%8D%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>阿里巴巴开发手册中写的很明确，基本类型接收NULL值有NPE风险（java.lang.NullPointerException  NPE 空值异常），而且默认值和NULL值不能传达同一种信息。</p><img src="/2020/07/22/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/Java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%B8%8D%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ali.jpg" srcset="undefined" class="" title="ali">]]></content>
    
    
    <categories>
      
      <category>性能分析</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java内存泄漏可能出现的情况</title>
    <link href="undefined2020/07/22/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <url>2020/07/22/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由于java的JVM引入了垃圾回收机制，垃圾回收器会自动回收不再使用的对象，了解JVM回收机制的都知道JVM是使用引用计数法和可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。<br>    在支持垃圾回收的语言中，内存泄漏是很隐蔽的（称这类内存泄漏为“无疑是的对象保持” unintentional object retention 更为恰当）如果一个对象</p></blockquote><ol><li><p>静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p></li><li><p>各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p></li><li><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p></li></ol><pre><code class="java">public class UsingRandom {        private String msg;        public void receiveMsg(){            readFromNet();// 从网络中接受数据保存到msg中            saveDB();// 把msg保存到数据库中        }}</code></pre><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。</p><p>实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p><ol start="4"><li><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p></li><li><p>改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露</p></li><li><p>举个例子-看你能否找出内存泄漏</p></li></ol><pre><code class="java">import java.util.Arrays;public class Stack {    private Object[] elements;    private int size = 0;    private static final int DEFAULT_INITIAL_CAPACITY = 16;    public Stack() {        elements = new Object[DEFAULT_INITIAL_CAPACITY];    }    public void push(Object e) {        ensureCapacity();        elements[size++] = e;    }    public Object pop() {        if (size == 0)            throw new EmptyStackException();        return elements[--size];    }    private void ensureCapacity() {        if (elements.length == size)            elements = Arrays.copyOf(elements, 2 * size + 1);    }}</code></pre><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。代码的主要问题在pop函数，下面通过这张图示展现当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，从中可以看出，如果栈先增长，在收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p><pre><code class="java">public Object pop() {    if (size == 0)    throw new EmptyStackException();    Object result = elements[--size];    elements[size] = null;    return result;}</code></pre><p>一旦引用过期，清空这些引用，将引用置空。</p><ol start="7"><li>缓存泄漏,内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</li></ol><pre><code class="java">import java.util.HashMap;import java.util.Map;import java.util.WeakHashMap;import java.util.concurrent.TimeUnit;public class MapTest {    static Map wMap = new WeakHashMap();    static Map map = new HashMap();    public static void main(String[] args) {        init();        testWeakHashMap();        testHashMap();    }    public static void init(){        String ref1= new String(&quot;obejct1&quot;);        String ref2 = new String(&quot;obejct2&quot;);        String ref3 = new String (&quot;obejct3&quot;);        String ref4 = new String (&quot;obejct4&quot;);        wMap.put(ref1, &quot;chaheObject1&quot;);        wMap.put(ref2, &quot;chaheObject2&quot;);        map.put(ref3, &quot;chaheObject3&quot;);        map.put(ref4, &quot;chaheObject4&quot;);        System.out.println(&quot;String引用ref1，ref2，ref3，ref4 消失&quot;);    }    public static void testWeakHashMap(){        System.out.println(&quot;WeakHashMap GC之前&quot;);        for (Object o : wMap.entrySet()) {            System.out.println(o);        }        try {            System.gc();            TimeUnit.SECONDS.sleep(20);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;WeakHashMap GC之后&quot;);        for (Object o : wMap.entrySet()) {            System.out.println(o);        }    }    public static void testHashMap(){        System.out.println(&quot;HashMap GC之前&quot;);        for (Object o : map.entrySet()) {            System.out.println(o);        }        try {            System.gc();            TimeUnit.SECONDS.sleep(20);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        System.out.println(&quot;HashMap GC之后&quot;);        for (Object o : map.entrySet()) {            System.out.println(o);        }    }}/** 结果 String引用ref1，ref2，ref3，ref4 消失 WeakHashMap GC之前 obejct2=chaheObject2 obejct1=chaheObject1 WeakHashMap GC之后 HashMap GC之前 obejct4=chaheObject4 obejct3=chaheObject3 Disconnected from the target VM, address: &#39;127.0.0.1:51628&#39;, transport: &#39;socket&#39; HashMap GC之后 obejct4=chaheObject4 obejct3=chaheObject3 **/</code></pre><p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1,weakd2,d1,d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，hashmap的没有被回收，而WeakHashmap里面的缓存被回收了。<br>8. 监听器和回调,内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p>]]></content>
    
    
    <categories>
      
      <category>性能分析</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作命令</title>
    <link href="undefined2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">参考手册</a></p><h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>内存 1GB 超过   内存溢出 会造成阻塞崩溃宕机<br>磁盘 1TB swap 交换空间，虽然会防止内存溢出，但是会减慢速度拖垮系统<br>云服务器    一台超级计算机 1TB 硬盘 128G 内存，云服务器是没有交换空间的<br>                开辟一个空间    20GB 1G</p><h3 id="Linuxw文件操作命令"><a href="#Linuxw文件操作命令" class="headerlink" title="Linuxw文件操作命令"></a>Linuxw文件操作命令</h3><pre><code class="shell">如果无法找到ls或其他命令export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin压缩文件# tar -xzvf test.tar.gz</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><ul><li>reboot</li><li>shutdown -r now</li></ul><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><ul><li>shutdown -h now</li></ul><h2 id="Linux编辑器"><a href="#Linux编辑器" class="headerlink" title="Linux编辑器"></a>Linux编辑器</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><ul><li>编辑模式：等待编辑命令输入</li><li>插入模式：编辑模式下，输入i进入插入模式，插入文本信息</li><li>命令模式：在编辑模式下，输入:进行命令模式</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol><li>:q 直接退出vi</li><li>:wq 保存后退出vi，并可以新建文件</li><li>:q! 强制退出</li><li>:w file 将当前内容保存成某个文件</li><li>:set number 在编辑文件显示行号</li><li>:set nonumber 在编辑文件不显示行号</li></ol><h3 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h3><p>nano是一个字符中断的文本编辑器，有点像DOS下的editor程序。它比vi/vim要简单的多，比较审核Linux初学者使用。某些Linux发行版的默认编辑器就是nano。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>swagger跨域问题</title>
    <link href="undefined2020/07/21/%E9%94%99%E8%AF%AF/swagger/swagger%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>2020/07/21/%E9%94%99%E8%AF%AF/swagger/swagger%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Swagger的跨域问题"><a href="#Swagger的跨域问题" class="headerlink" title="Swagger的跨域问题"></a>Swagger的跨域问题</h2><img src="/2020/07/21/%E9%94%99%E8%AF%AF/swagger/swagger%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/%E9%97%AE%E9%A2%98.png" srcset="undefined" class="" title="问题 [问题]"><p>必须保证三处ip相同,访问页面的url和Server的访问地址，以及index的url</p><img src="/2020/07/21/%E9%94%99%E8%AF%AF/swagger/swagger%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/ip.png" srcset="undefined" class="" title="ip [ip]"><pre><code class="html">&lt;!-- HTML for static distribution bundle build --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Swagger UI&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./swagger-ui.css&quot; &gt;    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-32x32.png&quot; sizes=&quot;32x32&quot; /&gt;    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-16x16.png&quot; sizes=&quot;16x16&quot; /&gt;    &lt;style&gt;      html      {        box-sizing: border-box;        overflow: -moz-scrollbars-vertical;        overflow-y: scroll;      }      *,      *:before,      *:after      {        box-sizing: inherit;      }      body      {        margin:0;        background: #fafafa;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;swagger-ui&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;./swagger-ui-bundle.js&quot;&gt; &lt;/script&gt;    &lt;script src=&quot;./swagger-ui-standalone-preset.js&quot;&gt; &lt;/script&gt;    &lt;script&gt;    window.onload = function() {      // Begin Swagger UI call region      const ui = SwaggerUIBundle({        url: &quot;http://192.168.1.142/PHPCode/swagger/openapi.yaml&quot;,        dom_id: &#39;#swagger-ui&#39;,        deepLinking: true,        presets: [          SwaggerUIBundle.presets.apis,          SwaggerUIStandalonePreset        ],        plugins: [          SwaggerUIBundle.plugins.DownloadUrl        ],        layout: &quot;StandaloneLayout&quot;      })      // End Swagger UI call region      window.ui = ui    }  &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;&lt;!-- HTML for static distribution bundle build --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Swagger UI&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./swagger-ui.css&quot; &gt;    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-32x32.png&quot; sizes=&quot;32x32&quot; /&gt;    &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon-16x16.png&quot; sizes=&quot;16x16&quot; /&gt;    &lt;style&gt;      html      {        box-sizing: border-box;        overflow: -moz-scrollbars-vertical;        overflow-y: scroll;      }      *,      *:before,      *:after      {        box-sizing: inherit;      }      body      {        margin:0;        background: #fafafa;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;swagger-ui&quot;&gt;&lt;/div&gt;    &lt;script src=&quot;./swagger-ui-bundle.js&quot;&gt; &lt;/script&gt;    &lt;script src=&quot;./swagger-ui-standalone-preset.js&quot;&gt; &lt;/script&gt;    &lt;script&gt;    window.onload = function() {      // Begin Swagger UI call region      const ui = SwaggerUIBundle({        url: &quot;http://192.168.1.142/PHPCode/swagger/openapi.yaml&quot;,        dom_id: &#39;#swagger-ui&#39;,        deepLinking: true,        presets: [          SwaggerUIBundle.presets.apis,          SwaggerUIStandalonePreset        ],        plugins: [          SwaggerUIBundle.plugins.DownloadUrl        ],        layout: &quot;StandaloneLayout&quot;      })      // End Swagger UI call region      window.ui = ui    }  &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>swagger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux简介</title>
    <link href="undefined2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AE%80%E4%BB%8B/"/>
    <url>2020/07/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><p>Linux 是内核，具备图灵完备。Ubuntu、CentOS、RedHat、深度。。。是Linux的操作系统<br>Windows Nt 是Windows的内核</p><p>Linux有超级管理员账户root</p><p>Windows 一块硬盘 1TB<br>        C 100 D 100 Movies<br>        E 500 F 300<br>Linux   一块硬盘 第0块硬盘<br>        挂载<br>            Movies sc0 20GB<br>            Games sc0 100GB<br>LVM技术 磁盘扩容技术<br>        500GB   C<br>        500GB   D</p><h2 id="服务器远程控制"><a href="#服务器远程控制" class="headerlink" title="服务器远程控制"></a>服务器远程控制</h2><p>Open SSH</p><p>连接<br>    服务端<br>        创建监听端口<br>    客户端<br>        请求服务端的监听端口<br>免密登录<br>    客户端创建一对密钥<br>        公钥    私钥<br>XShell</p><pre><code class="linux">查看端口ifconfig    inet是端口</code></pre><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><table><thead><tr><th>一级目录</th><th>功能（作用）</th></tr></thead><tbody><tr><td>/bin/</td><td>存放系统命令，普通用户和 root 都可以执行。放在 /bin 下的命令在单用户模式下也可以执行</td></tr><tr><td>/etc/</td><td>配置文件目录</td></tr><tr><td>/user/local</td><td>我们自己安装的程序，必须放在该目录</td></tr><tr><td>/var/</td><td>存放数据库的目录</td></tr><tr><td>/boot/</td><td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等</td></tr><tr><td>/dev/</td><td>设备文件保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td></tr><tr><td>/home/</td><td>普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 /home/liming</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置</td></tr><tr><td>/media/</td><td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td></tr><tr><td>/mnt/</td><td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td></tr><tr><td>/misc/</td><td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 /mnt/ 下建立不同目录挂载不同设备的习惯，如 /mnt/cdrom/ 挂载光盘、/mnt/usb/ 挂载 U 盘，都是可以的</td></tr><tr><td>/opt/</td><td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 /usr/local/ 目录中，也就是说，/usr/local/ 目录也可以用来安装软件</td></tr><tr><td>/root/</td><td>root 的主目录。普通用户主目录在 /home/ 下，root 主目录直接在“/”</td></tr><tr><td>/sbin/</td><td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td></tr><tr><td>/srv/</td><td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td></tr><tr><td>/tmp/</td><td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td></tr></tbody></table><h2 id="深度linux没有ll等命令的解决办法"><a href="#深度linux没有ll等命令的解决办法" class="headerlink" title="深度linux没有ll等命令的解决办法"></a>深度linux没有ll等命令的解决办法</h2><pre><code class="shell">编辑~/.bashrc, 添加alias如下vim ~/.bashrc 设置别名。添加如下行alias ll=&#39;ls -alF&#39;alias la=&#39;ls -A&#39;alias vi=&#39;vim&#39;alias sub=&#39;sublime-text-dev&#39;:wq存盘退出source ~/.bashrc</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Antd标签</title>
    <link href="undefined2020/07/18/%E5%89%8D%E7%AB%AF/Antd/Antd%E6%A0%87%E7%AD%BE/"/>
    <url>2020/07/18/%E5%89%8D%E7%AB%AF/Antd/Antd%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="制作的页面代码"><a href="#制作的页面代码" class="headerlink" title="制作的页面代码"></a>制作的页面代码</h2><p>里面有时间，下拉框（可清除），表单分页（子目录）</p><pre><code class="js">/* * @Description: 奖池分组 * @version: 1.0.0 * @Company: sdbean * @Author: zhangyi * @Date: 2020-7-18 */import {IawardGroup, Igachats} from &#39;./models/gacha&#39;;import React, {Component} from &#39;react&#39;;import * as styles from &#39;./CoinWeightManager.less&#39;;import PageHeaderWrapper from &#39;@/components/PageHeaderWrapper&#39;;import {connect} from &#39;dva&#39;;import {ILogin} from &#39;@/models/login&#39;;import EditorAwardGroup from &#39;./EditorAwardGroup&#39;;import {PlusOutlined} from &#39;@ant-design/icons&#39;;import { getGachaSeasonGroup, getGachaSeasonSelectName} from &#39;@/utils/mallTool&#39;;import {  Button,  Spin,  Row,  Card,  Col,  Select,  Table,  message} from &#39;antd&#39;;import {ColumnProps} from &quot;antd/lib/table&quot;;export const PAGESIZE = 8;@connect(({loading, login, gacha}: { loading: IdvaLoading; login: ILogin; gacha: Igachats }) =&gt; ({  uid: login.uid,  isLoading: loading.models.getSeasonList,  seasonList: gacha.seasonList,  coinList: gacha.coinList,  awardList: gacha.awardList,  modelType: gacha.modelType,  coinModelType: gacha.coinModelType,  currentWeightSeasonId: gacha.currentWeightSeasonId,  simpleSeasonList: gacha.simpleSeasonList,  simpleSeasonGroupList: gacha.simpleSeasonGroupList,  currentGroupSeasonId: gacha.currentGroupSeasonId,  currentGroupId: gacha.currentGroupId,  groupList: gacha.groupList,  groupId: gacha.groupId,}))class AwardGroup extends Component&lt;Igachats&gt; {  constructor(props) {    super(props);    this.state = {      visible: false,      currentPage: 1,    };  }  componentDidMount() {    const {dispatch} = this.props;    dispatch({      type: &#39;gacha/getSimpleSeasonList&#39;,    });    dispatch({      type: &#39;gacha/getSimpleSeasonCoinList&#39;,    });    dispatch({      type: &#39;gacha/getGachaSeasonAward&#39;,    });    dispatch({      type: &#39;gacha/getGroupList&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId, gacha_group_id: this.props.groupId}    });  }  render() {    const {isLoading} = this.props;    return (      &lt;PageHeaderWrapper title=&quot;奖池分组&quot; content={this.renderHeader()}&gt;        &lt;Spin spinning={!!this.props.isLoading}&gt;          {this.props.currentGroupSeasonId &gt; 0 &amp;&amp; &lt;EditorAwardGroup/&gt;}        &lt;/Spin&gt;        &lt;div className={styles.avswitch}&gt;          &lt;Row&gt;            &lt;Col span={2}&gt;              &lt;Button type=&quot;primary&quot; icon={&lt;PlusOutlined/&gt;} size=&quot;large&quot; onClick={this.onClickCreate}&gt;添加&lt;/Button&gt;            &lt;/Col&gt;            &lt;Col span={2}&gt;              &lt;Button type=&quot;primary&quot; icon={&lt;PlusOutlined/&gt;} size=&quot;large&quot; onClick={this.onClickUpdate}&gt;更新&lt;/Button&gt;            &lt;/Col&gt;          &lt;/Row&gt;        &lt;/div&gt;        &lt;Card&gt;          &lt;Table            //  scroll={{ x: 'calc(1800px + 50%)', y: 720 }}            // scroll={{ x: 2000, y: 720 }}            className={styles.tableClass}            rowClassName={this.rowClassName}            columns={this.columns}            dataSource={this.props.groupList}            loading={!!isLoading}            bordered={true}            rowKey={(record, index) =&gt; index.toString()}            pagination={{              pageSize: PAGESIZE,              current: this.state.currentPage,              total: this.props.groupList ? this.props.groupList.length : 0,              onChange: this.changePage,            }}          /&gt;        &lt;/Card&gt;      &lt;/PageHeaderWrapper&gt;    );  }  rowClassName = (record, index) =&gt; {    return (record.current === true ? styles.current : &#39;&#39;)  }  changePage = (page) =&gt; {    this.setState({currentPage: page});  };  //表格列规则  columns: Array&lt;ColumnProps&lt;IawardGroup&gt;&gt; = [    {      title: &#39;ID&#39;,      dataIndex: &#39;id&#39;,      key: &#39;id&#39;,      align: &#39;center&#39;,    },    {      title: &#39;季度 ID&#39;,      dataIndex: &#39;gacha_season_id&#39;,      key: &#39;gacha_season_id&#39;,      align: &#39;center&#39;,    },    {      title: &#39;分组 ID&#39;,      dataIndex: &#39;gacha_group_id&#39;,      key: &#39;gacha_group_id&#39;,      align: &#39;center&#39;,    },    {      title: &#39;名称&#39;,      dataIndex: &#39;item_name&#39;,      key: &#39;item_name&#39;,      align: &#39;center&#39;,    },    {      title: &#39;操作&#39;,      key: &#39;action&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return (          &lt;div className={styles.cellCenter}&gt;            &lt;Button type=&quot;primary&quot; onClick={() =&gt; this.onClickDelete(row)}&gt;删除&lt;/Button&gt;          &lt;/div&gt;        );      },    },    {      title: &#39;中文备注&#39;,      dataIndex: &#39;cn_remark&#39;,      key: &#39;cn_remark&#39;,      align: &#39;center&#39;,    },    {      title: &#39;分类名称&#39;,      dataIndex: &#39;type_name&#39;,      key: &#39;type_name&#39;,      align: &#39;center&#39;,    },    {      title: &#39;物品等级&#39;,      dataIndex: &#39;item_level&#39;,      key: &#39;item_level&#39;,      align: &#39;center&#39;,      render: (value) =&gt; {        switch (value) {          case 0:            return &#39;无&#39;;          case 1:            return &#39;C&#39;;          case 2:            return &#39;R&#39;;          case 3:            return &#39;SR&#39;;          case 4:            return &#39;SSR&#39;;          case 5:            return &#39;UR&#39;;        }      },    },  ];  //渲染头部  renderHeader() {    return (      &lt;div className={styles.avframeheader}&gt;        &lt;div className={styles.title}&gt;季度选择：&lt;/div&gt;        &lt;Select style={{width: 280}}                className={styles.actionItem}                placeholder=&quot;请选择要查看的季度&quot;                onChange={this.onChangeSelect}                defaultValue={getGachaSeasonSelectName(this.props.currentWeightSeasonId, this.props.simpleSeasonList)}        &gt;          {this.props.simpleSeasonList.map((item, index) =&gt; {            return (              &lt;Option key={index.toString()} value={this.props.simpleSeasonList[index].gacha_season_id}&gt;                {&quot;季度ID: &quot; + this.props.simpleSeasonList[index].gacha_season_id + &quot; 名称: &quot; + this.props.simpleSeasonList[index].name}              &lt;/Option&gt;            );          })}        &lt;/Select&gt;        &lt;div className={styles.title}&gt;分组选择：&lt;/div&gt;        &lt;Select style={{width: 280}}                allowClear                className={styles.actionItem}                placeholder=&quot;请选择要查看的分组&quot;                onChange={this.onChangeGroupSelect}                defaultValue={getGachaSeasonGroup(this.props.currentWeightSeasonId, this.props.simpleSeasonGroupList)}        &gt;          {            this.props.simpleSeasonGroupList.map((item, index) =&gt; {            return (              &lt;Option key={index.toString()} value={this.props.simpleSeasonGroupList[index].gacha_season_group_id}&gt;                {&quot;分组ID: &quot; + this.props.simpleSeasonGroupList[index].gacha_season_group_id + &quot; 名称: &quot; + this.props.simpleSeasonGroupList[index].name}              &lt;/Option&gt;            );          })}        &lt;/Select&gt;      &lt;/div&gt;    );  }  //选择框  onChangeSelect = value =&gt; {    const {dispatch} = this.props;    this.changePage(1);    dispatch({      type: &#39;gacha/setCurrentWeight&#39;,      payload: null    });    dispatch({      type: &#39;gacha/getGroupList&#39;,      payload: {gacha_season_id: value}    });    dispatch({      type: &#39;gacha/setCurrentWeightSeasonId&#39;,      payload: value    });    dispatch({      type: &#39;gacha/getSimpleSeasonGroupList&#39;,      payload: {gacha_season_id: value}    });  };  onChangeGroupSelect = value =&gt; {    const {dispatch} = this.props;    this.changePage(1);    dispatch({      type: &#39;gacha/getGroupList&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId, gacha_group_id: value}    });    dispatch({      type: &#39;gacha/setCurrentGroupId&#39;,      payload: value,    })  }  //点击编辑  onClickDelete = (row: any) =&gt; {    if (this.props.currentWeightSeasonId &lt;= 0) {      message.error(&quot;请先选择季度&quot;);      return;    }    this.props.dispatch({      type: &#39;gacha/deleteSeasonGroupAward&#39;,      payload: row    });    message.success(&quot;删除成功&quot;);    this.props.dispatch({      type: &#39;gacha/getGroupList&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId, gacha_group_id: row.gacha_group_id}    });  };  onClickCreate = () =&gt; {    if (this.props.currentWeightSeasonId &lt;= 0) {      message.error(&quot;请先选择季度&quot;);      return;    }    this.props.dispatch({      type: &#39;gacha/getCurrentGroupSeasonId&#39;,      payload: {}    });    this.props.dispatch({      type: &#39;gacha/getGachaAwardPoolList&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId}    });  };  onClickUpdate = () =&gt; {    if (this.props.currentWeightSeasonId &lt;= 0) {      message.error(&quot;请先选择季度&quot;);      return;    }    if (this.props.currentGroupId &lt;= 0){      message.error(&quot;请先选择分组&quot;);      return;    }    this.props.dispatch({      type: &#39;gacha/setCurrentGroupSeasonId&#39;,      payload: [{id:this.props.currentGroupId}]    });    this.props.dispatch({      type: &#39;gacha/getGachaAwardPoolList&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId}    });    this.props.dispatch({      type: &#39;gacha/getSelectedRowKeys&#39;,      payload: {gacha_season_id: this.props.currentWeightSeasonId,gacha_group_id: this.props.currentGroupId}    });  };}export default AwardGroup;</code></pre><pre><code class="js">/* * @Description: 订单管理 * @version: 1.0.0 * @Company: sdbean * @Author: zhangyi * @Date: 2020-7-18 */import {IgachaOrder, Igachats} from &#39;./models/gacha&#39;;import React, {Component} from &#39;react&#39;;import * as styles from &#39;./CoinWeightManager.less&#39;;import PageHeaderWrapper from &#39;@/components/PageHeaderWrapper&#39;;import {connect} from &#39;dva&#39;;import {ILogin} from &#39;@/models/login&#39;;import {  Row,  Card,  Col,  Select,  DatePicker,  Table,} from &#39;antd&#39;;import moment from &quot;moment&quot;;import {ColumnProps} from &quot;antd/es/table&quot;;import {getGachaSeasonSelectName} from &quot;@/utils/mallTool&quot;;export const PAGESIZE = 8;@connect(({loading, login, gacha}: { loading: IdvaLoading; login: ILogin; gacha: Igachats }) =&gt; ({  uid: login.uid,  isLoading: loading.models.getSeasonList,  orderList: gacha.orderList,  currentWeightSeasonId: gacha.currentWeightSeasonId,  simpleSeasonList: gacha.simpleSeasonList,}))class OrderManage extends Component&lt;Igachats&gt; {  constructor(props) {    super(props);    this.state = {      startTime: 0,      endTime: 0,      orderState: 2,      seasonId: 0,      currentPage: 1,    };  }  componentDidMount() {    const {dispatch} = this.props;    dispatch({      type: &#39;gacha/getOrderList&#39;,      payload: {start: 0, offset: PAGESIZE}    });    dispatch({      type: &#39;gacha/getSimpleSeasonList&#39;,    });  }  render() {    const {isLoading} = this.props;    return (      &lt;PageHeaderWrapper title=&quot;订单管理&quot; content={this.renderHeader()}&gt;        &lt;Card&gt;          &lt;Table            scroll={{x: 'calc(1800px + 50%)', y: 450}}            className={styles.tableClass}            rowClassName={this.rowClassName}            columns={this.columns}            dataSource={this.props.orderList.data}            loading={!!isLoading}            bordered={true}            rowKey={(record, index) =&gt; index.toString()}            pagination={{              pageSize: this.props.orderList.pageSize,              current: this.state.currentPage,              total: this.props.orderList.count,              onChange: this.changePage,            }}          /&gt;        &lt;/Card&gt;      &lt;/PageHeaderWrapper&gt;    );  }  renderHeader() {    return (      &lt;Row style={{marginBottom: 15}}&gt;        &lt;Col span={5}&gt;          季度选择：          &lt;Select style={{width: 280}}                  className={styles.actionItem}                  placeholder=&quot;请选择要查看的季度&quot;                  allowClear                  onChange={this.onChangeSelect}                  defaultValue={getGachaSeasonSelectName(this.props.currentWeightSeasonId, this.props.simpleSeasonList)}          &gt;            {this.props.simpleSeasonList.map((item, index) =&gt; {              return (                &lt;Option key={index.toString()} value={this.props.simpleSeasonList[index].gacha_season_id}&gt;                  {&quot;季度ID: &quot; + this.props.simpleSeasonList[index].gacha_season_id + &quot; 名称: &quot; + this.props.simpleSeasonList[index].name}                &lt;/Option&gt;              );            })}          &lt;/Select&gt;        &lt;/Col&gt;        &lt;Col span={5}&gt;          订单状态:          &lt;Select style={{width: 280}}                  allowClear                  onChange={this.onChangeOrderState}&gt;            &lt;Option value=&quot;0&quot;&gt;已发放&lt;/Option&gt;            &lt;Option value=&quot;1&quot;&gt;未发放&lt;/Option&gt;          &lt;/Select&gt;        &lt;/Col&gt;        &lt;Col span={5}&gt;          创建时间: &lt;DatePicker.RangePicker          allowClear          onChange={this.onTimeChange}          showTime={{            hideDisabledOptions: true,            defaultValue: [moment('00:00:00', 'HH:mm:ss'), moment('11:59:59', 'HH:mm:ss')],          }}          style={{width: '300px'}}/&gt;        &lt;/Col&gt;      &lt;/Row&gt;    );  }  rowClassName = (record) =&gt; {    return (record.current === true ? styles.current : &#39;&#39;)  }  changePage = (page) =&gt; {    this.props.dispatch({      type: &#39;gacha/getOrderList&#39;,      payload: {        start: (page - 1) * PAGESIZE,        offset: PAGESIZE,        gacha_season_id: this.state.seasonId,        startTime: this.state.startTime,        endTime: this.state.endTime,        orderState: this.state.orderState,      }    });    this.setState({currentPage: page});  };  //表格列规则  columns: Array&lt;ColumnProps&lt;IgachaOrder&gt;&gt; = [    {      title: &#39;ID&#39;,      dataIndex: &#39;id&#39;,      key: &#39;id&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;订单号&#39;,      dataIndex: &#39;order_no&#39;,      key: &#39;order_no&#39;,      align: &#39;center&#39;,      width: 150,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;订单状态&#39;,      dataIndex: &#39;status&#39;,      key: &#39;status&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        if (row.rowSpan == null) {          row.rowSpan = 0;        }        return {          children: &lt;div&gt;{value == 0 ? &quot;已发放&quot; : &quot;未发放&quot;}&lt;/div&gt;,          props: {rowSpan: row.rowSpan},        };      },    },    {      title: &#39;创建时间&#39;,      dataIndex: &#39;create_time&#39;,      key: &#39;create_time&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        if (row.rowSpan == null) {          row.rowSpan = 0;        }        if (!!value) {          return {            children: &lt;div&gt;{moment(value).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)}&lt;/div&gt;,            props: {rowSpan: row.rowSpan},          };        } else {          return {            children: &lt;div&gt;无&lt;/div&gt;,            props: {rowSpan: row.rowSpan},          };        }      },      width: 150,    },    {      title: &#39;消耗货币ID&#39;,      dataIndex: &#39;coin_id&#39;,      key: &#39;coin_id&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;消耗货币数量&#39;,      dataIndex: &#39;coin_num&#39;,      key: &#39;coin_num&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;消耗货币名称&#39;,      dataIndex: &#39;coin_name&#39;,      key: &#39;coin_name&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;抽奖次数&#39;,      dataIndex: &#39;order_number&#39;,      key: &#39;order_number&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;用户Id&#39;,      dataIndex: &#39;user_id&#39;,      key: &#39;user_id&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;季度Id&#39;,      dataIndex: &#39;gacha_season_id&#39;,      key: &#39;gacha_season_id&#39;,      align: &#39;center&#39;,      render: (value, row, index) =&gt; {        return this.renderRow(value, row, index);      },    },    {      title: &#39;道具配置&#39;,      align: &#39;center&#39;,      children: [        {          title: &#39;gacha赛季奖励Id&#39;,          dataIndex: &#39;gacha_season_award_id&#39;,          key: &#39;gacha_season_award_id&#39;,          align: &#39;center&#39;,        },        {          title: &#39;道具DicId&#39;,          dataIndex: &#39;item_dic_id&#39;,          key: &#39;item_dic_id&#39;,          align: &#39;center&#39;,        },        {          title: &#39;道具Id&#39;,          dataIndex: &#39;item_id&#39;,          key: &#39;item_id&#39;,          align: &#39;center&#39;,        },        {          title: &#39;道具名称&#39;,          dataIndex: &#39;item_name&#39;,          key: &#39;item_name&#39;,          align: &#39;center&#39;,        },        {          title: &#39;中文备注&#39;,          dataIndex: &#39;cn_remark&#39;,          key: &#39;cn_remark&#39;,          align: &#39;center&#39;,        },        {          title: &#39;道具属性&#39;,          dataIndex: &#39;property_aging&#39;,          key: &#39;property_aging&#39;,          align: &#39;center&#39;,          render: (value) =&gt; {            return value == 0 ? &#39;永久类&#39; : &#39;时效类&#39;;          },        },        {          title: &#39;道具数量&#39;,          dataIndex: &#39;num&#39;,          key: &#39;num&#39;,          align: &#39;center&#39;,        },      ]    },  ];  renderRow = (value, row, index) =&gt; {    if (row.rowSpan == null) {      row.rowSpan = 0;    }    return {      children: value,      props: {rowSpan: row.rowSpan},    };  };  onChangeOrderState = value =&gt; {    this.props.dispatch({      type: &#39;gacha/getOrderList&#39;,      payload: {        start: 0,        offset: PAGESIZE,        gacha_season_id: this.state.seasonId,        startTime: this.state.startTime,        endTime: this.state.endTime,        orderState: value,      }    });    this.setState({orderState: value})  }  onTimeChange = (time, str) =&gt; {    this.props.dispatch({      type: &#39;gacha/getOrderList&#39;,      payload: {        start: 0,        offset: PAGESIZE,        gacha_season_id: this.state.seasonId,        startTime: new Date(str[0]),        endTime: new Date(str[1]),        orderState: this.state.orderState,      }    });    this.setState({startTime: new Date(str[0])});    this.setState({endTime: new Date(str[1])});  }  onChangeSelect = value =&gt; {    this.props.dispatch({      type: &#39;gacha/getOrderList&#39;,      payload: {        start: 0,        offset: PAGESIZE,        gacha_season_id: value,        startTime: this.state.startTime,        endTime: this.state.endTime,        orderState: this.state.orderState,      }    });    this.setState({seasonId: value})  }}export default OrderManage;</code></pre><pre><code class="js">import { array } from &#39;prop-types&#39;;import {  getGachaAwardPoolList,  getCurrentGroupSeasonId,  createGachaSeasonRule,  updateGachaSeasonRule,  getGachaSeasonAwardGroup,  getSimpleSeasonRuleGroupList,  getSimpleSeasonGroupList,  getSeasonRuleList,  gachaRefreshSeasonAwardNum,  createGachaSeasonAward,  updateGachaSeasonAward,  createGachaSeasonAwardCoinWeight,  updateGachaSeasonAwardCoinWeight,  getSimpleSeasonList,  getSimpleSeasonCoinList,  getGachaSeasonAwardCoinWeight,  getGachaSeasonAward,  getItemDicList,  getItemCateList,  getGachaAwardPool,  createGachaAwardPool,  updateGachaAwardPool,  getGachaSeasonList,  updateSeason,  createSeason,  getCoinList,  updateSeasonCoin,  createSeasonCoin,  insertGachaSeasonAwardGroup, deleteSeasonGroupAward, getSelectedRowKeys, getOrderList} from &#39;@/services/gacha&#39;;import moment from &#39;moment&#39;;import { message } from &#39;antd&#39;;import { IitemCate, IitemDic } from &#39;@/dto/mallItem&#39;;export const isgiveList = [  &quot;小于n次不掉落(道具保值)&quot;,  &quot;前n次没有获得的道具,必掉落其中一个(用户保底)&quot;,  &quot;不可重复掉落(道具保值)&quot;,  &quot;前n次没有获得的道具,其权重增加(用户保底)&quot;,  &quot;小于n次权重增增加&quot;,  &quot;每抽n次没有获得的道具,必掉落其中一个,并重新计算n次(用户保底)&quot;,  &quot;每抽n次没有获得的道具,其权重增加并重新计算n次(用户保底)&quot;,  &quot;连抽,某物品不可重复掉落n次(道具保值)&quot;,];export const opentypeList = [  &quot;单抽&quot;,  &quot;连抽&quot;,  &quot;全部&quot;];export interface Icoin {  id: number;  name: number;}export interface IsimpleSeason {  gacha_season_id: number;  name: number;}export interface IsimpleSeasonGroup {  gacha_season_group_id: number;  name: number}export interface IsimpleSeasonCoin {  gacha_season_id: number;  coin_id: number;  name: number;}export interface IgachaSeason {  id: number;  name: string;  starttime: string;  endtime: string;  first_per_free: number;  bg_url: string;  multi: number;  pre_free_time: number;  multi_free_time: number;  first_multi_free: number;  seasonCoinId: number;  num: number;  coin: number;  coin_id: number;  coinName: string;  rowSpan: number;  current: boolean;}export interface Irule {  id: number;  gacha_season_give_id: number;  gacha_season_id: number;  isgive: number;  weight: number;  freq: number;  gacha_group_id: number;  open_type: number;  coin_id: number;  group_name: string;  coin_name: string;}export interface IawardPool {  id: number;  item_name: string;  item_dic_id: number;  item_id: number;  remark: string;  cate_id: number;  item_pic: string;  item_level: number;  type_name: string;  cn_remark: string;  gacha_season_award_id: number;  gacha_award_pool_id: number;  gacha_season_id: number;  award_level: number;  num: number;  valid_num: number;  per_num: number;  min_num: number;  max_num: number;  isshow: number;  ischange: number;  ischange_coin_id: number;  ischange_coin_num: number;  coin_name: string;  delsign: number;  gacha_season_award_coin_weight_id: number;  weight: number;  coin_id: number;}export interface IawardGroup {  id: number;  gacha_season_id: number;  gacha_group_id: number;  item_name: number;  cn_remark: number;  type_name: number;  item_level: number; // 道具等级，0:无，1:C，2:R，3:SR，4:SSR，5:UR}export interface IgachaSeasonAward{  id: number;}export interface IorderManage{  count: number;  pagesize: number;  data: IgachaOrder[];}export interface IgachaOrder{  id: number; // 订单Id  order_no: number; // 订单号  status: number; // 订单状态 0：以发放 1:未发放  gacha_season_award_id: number;  gacha_season_id: number;  create_time: number;  user_id: number;  itemm_dic_id: number;  item_id: number;  item_name: string;  cn_remark: string;  property_aging: number;  num: number;  coin_id: number;  coin_num: number;  coin_name: string;  order_number: number;  rowSpan: number;}export interface IgachaAwardPool {  id: number;  item_name: number;  cn_remark: number;  type_name: number;  item_level: number; // 道具等级，0:无，1:C，2:R，3:SR，4:SSR，5:UR}export interface IseasonManagerProps {  uid: number;  isLoading: boolean;  dispatch: Function;  seasonList: IgachaSeason[];  seasonSimpleList: IgachaSeason[];  coinList: Icoin[];  itemDicList: IitemDic[];  itemCateList: IitemCate[];  modelType: number;  coinModelType: number;  imgModelType: number;  selectId: number;  ruleList: Irule[];}interface Igachats {  seasonList: IgachaSeason[];  seasonSimpleList: IgachaSeason[];  coinList: Icoin[];  poolList: IawardPool[];  awardList: IawardPool[];  weightList: IawardPool[];  simpleSeasonList: IsimpleSeason[];  simpleSeasonCoinList: IsimpleSeasonCoin[];  itemDicList: IitemDic[];  itemCateList: IitemCate[];  modelType: number;  coinModelType: number;  imgModelType: number;  selectId: number;  poolModelType: number;  awardModelType: number;  currentWeightSeasonId: number;  currentWeight: IawardPool;  ruleList: Irule[];  currentRule: Irule;  simpleRuleGroupList: IsimpleSeasonGroup[],  // 奖池分组数据  simpleSeasonGroupList: IsimpleSeasonGroup[],  groupList: IawardGroup[],  groupId: number;  currentGroupSeasonId: number;  currentGroupId: number;  gachaAwardPoolList: IgachaAwardPool[];  selectedRowKeys: IgachaSeasonAward[];  // 订单管理  orderList: IorderManage[];}const init: Igachats = {  seasonList: [],  seasonSimpleList: [],  coinList: [],  poolList: [],  awardList: [],  weightList: [],  simpleSeasonList: [],  simpleSeasonCoinList: [],  simpleSeasonGroupList: [],  groupList: [],  selectedRowKeys: [],  gachaAwardPoolList: [],  groupId: 0,  currentGroupId: 0,  itemDicList: [],  itemCateList: [],  modelType: 0,  coinModelType: 0,  imgModelType: 0,  selectId: -1,  poolModelType: 0,  awardModelType: 0,  currentGroupSeasonId: 0,  currentWeightSeasonId: 0,  currentWeight: null,  ruleList: [],  currentRule: null,  simpleRuleGroupList: [],  orderList: [],}function compareDate(date1, date2) {  date1 = new Date(date1);  date2 = new Date(date2);  if (date1.getTime() &gt;= date2.getTime()) {    return true;  } else {    return false;  }}export default {  namespace: &#39;gacha&#39;,  state: init,  effects: {    * getSeasonList(action, { call, put }) {      const response: IgachaSeason = yield call(getGachaSeasonList);      //更新基础状态      yield put({ type: &#39;setSeasonList&#39;, payload: response });    },    * updateSeason({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(updateSeason, payload);      //更新成功      if (response) {        message.success(&quot;编辑成功&quot;);        yield put({ type: &#39;setModelType&#39;, payload: 0 });      } else {        message.error(&quot;编辑失败，请重试&quot;);      }      yield put({ type: &#39;getSeasonList&#39; })    },    * createSeason({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(createSeason, payload);      //更新成功      if (response) {        message.success(&quot;新建成功&quot;);        yield put({ type: &#39;setModelType&#39;, payload: 0 });      } else {        message.error(&quot;新建失败，请重试&quot;);      }      yield put({ type: &#39;getSeasonList&#39; })    },    * getCoinList(action, { call, put }) {      const response: IgachaSeason = yield call(getCoinList);      //更新基础状态      yield put({ type: &#39;setCoinList&#39;, payload: response });    },    * updateSeasonCoin({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(updateSeasonCoin, payload);      //更新成功      if (response) {        message.success(&quot;编辑成功&quot;);        yield put({ type: &#39;setCoinModelType&#39;, payload: 0 });      } else {        message.error(&quot;编辑失败，请重试&quot;);      }      yield put({ type: &#39;getSeasonList&#39; })    },    * createSeasonCoin({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(createSeasonCoin, payload);      //更新成功      if (response) {        message.success(&quot;新建成功&quot;);        yield put({ type: &#39;setCoinModelType&#39;, payload: 0 });      } else {        message.error(&quot;新建失败，请重试&quot;);      }      yield put({ type: &#39;getSeasonList&#39; })    },    * getGachaAwardPool(action, { call, put }) {      const response = yield call(getGachaAwardPool);      //更新基础状态      yield put({ type: &#39;setPoolList&#39;, payload: response });    },    * createGachaAwardPool({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(createGachaAwardPool, payload);      if (response) {        message.success(&quot;新建成功&quot;);        yield put({ type: &#39;getGachaAwardPool&#39; });        yield put({ type: &#39;setPoolModelType&#39;, payload: 0 });      }    },    * updateGachaAwardPool({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(updateGachaAwardPool, payload);      if (response) {        message.success(&quot;编辑成功&quot;);        yield put({ type: &#39;getGachaAwardPool&#39; });        yield put({ type: &#39;setPoolModelType&#39;, payload: 0 });      }    },    * getItemCateList({ payload }: { payload }, { call, put }) {      const response = yield call(getItemCateList, payload);      if (response) {        yield put({ type: &#39;setItemCateList&#39;, payload: response });      }    },    * getItemDicList({ payload }: { payload }, { call, put }) {      const response = yield call(getItemDicList, payload);      if (response) {        yield put({ type: &#39;setItemDicList&#39;, payload: response });      }    },    * getGachaSeasonAward({ payload }: { payload }, { call, put }) {      const response = yield call(getGachaSeasonAward, payload);      if (response) {        yield put({ type: &#39;setAwardList&#39;, payload: response });      }    },    * getGachaSeasonAwardCoinWeight({ payload }: { payload }, { call, put }) {      const response = yield call(getGachaSeasonAwardCoinWeight, payload);      if (response) {        yield put({ type: &#39;setWeightList&#39;, payload: response });      }    },    * getSimpleSeasonList({ payload }: { payload }, { call, put }) {      const response = yield call(getSimpleSeasonList, payload);      if (response) {        yield put({ type: &#39;setSimpleSeasonList&#39;, payload: response });      }    },    * getOrderList({ payload }: { payload }, { call, put }) {      const response = yield call(getOrderList, payload);      if (response) {        yield put({ type: &#39;setOrderList&#39;, payload: response });      }    },    * getSimpleSeasonGroupList({ payload }: { payload }, { call, put }) {      const response = yield call(getSimpleSeasonGroupList, payload);      if (response) {        yield put({ type: &#39;setSimpleSeasonGroupList&#39;, payload: response });      }    },    * deleteSeasonGroupAward({ payload }: { payload }, { call, put }) {      const response = yield call(deleteSeasonGroupAward, payload);    },    * getCurrentGroupSeasonId({ payload }: { payload }, { call, put }) {      const response = yield call(getCurrentGroupSeasonId);      if (response) {        yield put({ type: &#39;setCurrentGroupSeasonId&#39;, payload: response });      }    },    * getGroupList({ payload }: { payload }, { call, put }) {      const response = yield call(getGachaSeasonAwardGroup, payload);      if (response) {        yield put({ type: &#39;setGroupList&#39;, payload: response });      }    },    * insertGachaSeasonAwardGroup({ payload }: { payload }, { call, put }) {      const response = yield call(insertGachaSeasonAwardGroup, payload);//更新成功      return response;    },    * getGachaAwardPoolList({ payload }: { payload }, { call, put }) {      const response = yield call(getGachaAwardPoolList,payload);      if (response) {        yield put({ type: &#39;setGachaAwardPoolList&#39;, payload: response });      }    },    * getSimpleSeasonCoinList({ payload }: { payload }, { call, put }) {      const response = yield call(getSimpleSeasonCoinList, payload);      if (response) {        yield put({ type: &#39;setSimpleSeasonCoinList&#39;, payload: response });      }    },    * getSelectedRowKeys({ payload }: { payload }, { call, put }) {      const response = yield call(getSelectedRowKeys, payload);      if (response) {        yield put({ type: &#39;setSelectedRowKeys&#39;, payload: response });      }    },    *createGachaSeasonAwardCoinWeight({ payload }: { payload: any }, { call, put }) {      const response = yield call(createGachaSeasonAwardCoinWeight, payload);      //更新成功      if (response) {        message.success(&quot;创建成功&quot;);        yield put({ type: &#39;setCurrentWeight&#39;, payload: null });        yield put({ type: &#39;getGachaSeasonAwardCoinWeight&#39;, payload: { gacha_season_id: payload.gacha_season_id } });      } else {        message.error(&quot;创建失败，如已经存在此条目，请编辑&quot;);      }    },    *updateGachaSeasonAwardCoinWeight({ payload }: { payload: any }, { call, put }) {      const response = yield call(updateGachaSeasonAwardCoinWeight, payload);      //更新成功      if (response) {        message.success(&quot;编辑成功&quot;);        yield put({ type: &#39;setCurrentWeight&#39;, payload: null });        yield put({ type: &#39;getGachaSeasonAwardCoinWeight&#39;, payload: { gacha_season_id: payload.gacha_season_id } });      } else {        message.error(&quot;编辑失败，请重试&quot;);      }    },    *createGachaSeasonAward({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(createGachaSeasonAward, payload);      if (response) {        message.success(&quot;新建成功&quot;);        yield call(gachaRefreshSeasonAwardNum, { seasonId: payload.gacha_season_id });        yield put({ type: &#39;getGachaSeasonAward&#39;, payload: { gacha_season_id: payload.gacha_season_id } });        yield put({ type: &#39;setAwardModelType&#39;, payload: 0 });      }    },    *updateGachaSeasonAward({ payload }: { payload: IgachaSeason }, { call, put }) {      const response = yield call(updateGachaSeasonAward, payload);      if (response) {        message.success(&quot;编辑成功&quot;);        yield call(gachaRefreshSeasonAwardNum, { seasonId: payload.gacha_season_id });        yield put({ type: &#39;getGachaSeasonAward&#39;, payload: { gacha_season_id: payload.gacha_season_id } });        yield put({ type: &#39;setAwardModelType&#39;, payload: 0 });      }    },    *getSeasonRuleList({ payload }: { payload }, { call, put }) {      const response = yield call(getSeasonRuleList, payload);      if (response) {        yield put({ type: &#39;setRuleList&#39;, payload: response });      }    },    *getSimpleSeasonRuleGroupList({ payload }: { payload }, { call, put }) {      const response = yield call(getSimpleSeasonRuleGroupList, payload);      if (response) {        yield put({ type: &#39;setSimpleRuleGroupList&#39;, payload: response });      }    },    *createGachaSeasonRule({ payload }: { payload: any }, { call, put }) {      const response = yield call(createGachaSeasonRule, payload);      //更新成功      if (response) {        message.success(&quot;创建成功&quot;);        yield put({ type: &#39;setCurrentRule&#39;, payload: null });        yield put({ type: &#39;getSeasonRuleList&#39;, payload: { gacha_season_id: payload.gacha_season_id } });      } else {        message.error(&quot;创建失败，如已经存在此条目，请编辑&quot;);      }    },    *updateGachaSeasonRule({ payload }: { payload: any }, { call, put }) {      const response = yield call(updateGachaSeasonRule, payload);      //更新成功      if (response) {        message.success(&quot;编辑成功&quot;);        yield put({ type: &#39;setCurrentRule&#39;, payload: null });        yield put({ type: &#39;getSeasonRuleList&#39;, payload: { gacha_season_id: payload.gacha_season_id } });      } else {        message.error(&quot;编辑失败，请重试&quot;);      }    },  },  reducers: {    setSeasonList(state: Igachats, { payload }): Igachats {      if (!payload) {        console.info(&quot;payload is null&quot;, payload);        return state;      }      const { array } = payload;      const now = new Date();      let rowCount = 0;      let nowId = 0;      const simpleArray = [];      for (let i = array.length - 1; i &gt;= 0; i--) {        const item: IgachaSeason = array[i];        item.starttime = moment(item.starttime, &#39;YYYY-MM-DD HH:mm:ss&#39;).utcOffset(960).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);        item.endtime = moment(item.endtime, &#39;YYYY-MM-DD HH:mm:ss&#39;).utcOffset(960).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);        if (compareDate(now, item.starttime) &amp;&amp; !compareDate(now, item.endtime)) {          item.current = true;        } else {          item.current = false;        }        if (nowId == 0) {          rowCount++;          nowId = item.id;          simpleArray[simpleArray.length] = item;          if (i == 0) {            item.rowSpan = rowCount;          }        } else {          if (nowId != item.id) {            const itemLast: IgachaSeason = array[i + 1];            itemLast.rowSpan = rowCount;            rowCount = 1;            nowId = item.id;            simpleArray[simpleArray.length] = item;            if (i == 0) {              item.rowSpan = rowCount;            }          } else {            if (i == 0) {              item.rowSpan = rowCount + 1;            } else {              rowCount++;              item.rowSpan = 0;            }          }        }      }      const simpleArrayOrder = [];      for (let i = simpleArray.length - 1; i &gt;= 0; i--) {        const item: IgachaSeason = simpleArray[i];        simpleArrayOrder[simpleArrayOrder.length] = item;      }      return { ...state, seasonList: array, seasonSimpleList: simpleArrayOrder }    },    //更新模态页    setModelType(state: Igachats, { payload }: { payload: number }): Igachats {      return { ...state, modelType: payload }    },    //更新模态页    setCoinModelType(state: Igachats, { payload }: { payload: number }): Igachats {      return { ...state, coinModelType: payload }    },    //更新选中的id    setSelectId(state: Igachats, { payload }: { payload: number }): Igachats {      return { ...state, selectId: payload }    },    setCurrentGroupId(state: Igachats, { payload }: { payload: number }): Igachats {      return { ...state, currentGroupId: payload }    },    setCoinList(state: Igachats, { payload }): Igachats {      if (!payload) {        console.info(&quot;payload is null&quot;, payload);        return state;      }      const { array } = payload;      const free = {        id: -1,        name: &quot;免费&quot;,      }      array.unshift(free);      return { ...state, coinList: array }    },    setPoolList(state: Igachats, { payload }): Igachats {      if (!payload) {        console.info(&quot;payload is null&quot;, payload);        return state;      }      return { ...state, poolList: payload }    },    setPoolModelType(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, poolModelType: payload }    },    setItemCateList(state: Igachats, { payload }): Igachats {      return { ...state, itemCateList: payload }    },    setItemDicList(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, itemDicList: payload }    },    setAwardList(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, awardList: payload }    },    setAwardModelType(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, awardModelType: payload }    },    setWeightList(state: Igachats, { payload }: { payload }): Igachats {      if (state.currentWeightSeasonId != 0) {        let total = 0;        let weightList = [];        for (const item of payload) {          total += item.weight;        }        for (const item of payload) {          item.weightPer = (item.weight / total * 100).toFixed(2) + &quot;%&quot;;          weightList.push(item);        }        return { ...state, weightList: weightList }      } else {        return { ...state, weightList: payload }      }    },    setSimpleSeasonList(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, simpleSeasonList: payload }    },    setSimpleSeasonGroupList(state: Igachats, { payload }: { payload }): Igachats {      console.log(&quot;payload&quot;,payload)      return { ...state, simpleSeasonGroupList: payload }    },    setGroupList(state: Igachats, { payload }: { payload }): Igachats {      if (state.currentWeightSeasonId != 0) {        let total = 0;        let groupList = [];        for (const item of payload) {          total += item.weight;        }        for (const item of payload) {          item.weightPer = (item.weight / total * 100) + &quot;%&quot;;          groupList.push(item);        }        return {...state, groupList: groupList}      } else {        return {...state, groupList: payload}      }      return { ...state, groupList: payload }    },    setGachaAwardPoolList(state: Igachats, {payload}: { payload }): Igachats {      return {...state, gachaAwardPoolList: payload}    },    setSimpleSeasonCoinList(state: Igachats, {payload}: { payload }): Igachats {      return {...state, simpleSeasonCoinList: payload}    },    setCurrentWeightSeasonId(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, currentWeightSeasonId: payload }    },    setCurrentGroupSeasonId(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, currentGroupSeasonId: payload[0].id }    },    setCurrentWeight(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, currentWeight: payload }    },    setRuleList(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, ruleList: payload }    },    setCurrentRule(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, currentRule: payload }    },    setSimpleRuleGroupList(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, simpleRuleGroupList: payload }    },    setSelectedRowKeys(state: Igachats, { payload }: { payload }): Igachats {      return { ...state, selectedRowKeys: payload }    },    setOrderList(state: Igachats, { payload }: { payload }): Igachats {      const array = payload.data;      let rowCount = 0;      let nowId = 0;      const simpleArray = [];      for (let i = array.length - 1; i &gt;= 0; i--) {        const item: IgachaOrder = array[i];        if (nowId == 0) {          rowCount++;          nowId = item.id;          simpleArray[simpleArray.length] = item;          if (i == 0) {            item.rowSpan = rowCount;          }        } else {          if (nowId != item.id) {            const itemLast: IgachaOrder = array[i + 1];            itemLast.rowSpan = rowCount;            rowCount = 1;            nowId = item.id;            simpleArray[simpleArray.length] = item;            if (i == 0) {              item.rowSpan = rowCount;            }          } else {            if (i == 0) {              item.rowSpan = rowCount + 1;            } else {              rowCount++;              item.rowSpan = 0;            }          }        }      }      const simpleArrayOrder = [];      for (let i = simpleArray.length - 1; i &gt;= 0; i--) {        const item: IgachaOrder = simpleArray[i];        simpleArrayOrder[simpleArrayOrder.length] = item;      }      return { ...state, orderList: payload }    },  },};</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Antd</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Antd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP编程风格</title>
    <link href="undefined2020/07/13/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/PHP%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <url>2020/07/13/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/PHP%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>普通的方法调用要使用<strong>对象-&gt;方法</strong>的防止来进行调用，静态方法使用类::静态方法的方式</p><pre><code class="php">$wishService-&gt;crystal($userNo,$cpId);Controller::validatePostForm([    &quot;userNo&quot; =&gt; &quot;present&quot;,    &quot;cookie&quot; =&gt; &quot;present&quot;,    &quot;cpId&quot; =&gt; &quot;present&quot;,]);</code></pre><h2 id="DAO编写规范"><a href="#DAO编写规范" class="headerlink" title="DAO编写规范"></a>DAO编写规范</h2><p>用双引号包裹sql语句，因为php中双引号字符串里的内容可以翻译变量</p><pre><code class="php">public function updateUserAnimationState($itemId, $userNo) {    try {        $pdo = $this-&gt;GetPdo();        $sql = &quot;INSERT INTO user_animation_state (user_id,role_id,type,animation_id,delsign) VALUES ($userNo,990,0,$itemId,0) ON DUPLICATE key UPDATE animation_id = $itemId&quot;;        $this-&gt;logger-&gt;Debug($sql);        $prepare = $pdo-&gt;prepare($sql);        $prepare-&gt;execute();        return $prepare-&gt;rowCount();    } catch (Throwable $e) {        $this-&gt;logger-&gt;Error($e);        return false;    }}</code></pre><h2 id="对象判空"><a href="#对象判空" class="headerlink" title="对象判空"></a>对象判空</h2><p>当需要判断数组不为空且长度大于0时<br>使用<code>empty($arr)</code></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>在使用foreach的&amp;后 ，需要unset($value)释放变量防止后续改变之前的数组</p><pre><code class="php">foreach ($result as &amp;$value) {}unset($value);</code></pre><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>date(“Y-m-d”) </p><table><thead><tr><th>格式化方式</th><th>说明</th><th>格式化方式</th><th>说明</th></tr></thead><tbody><tr><td>Y</td><td>4位数字年，y为2位数字，如99即1999年</td><td>Y</td><td>4位数字年，y为2位数字，如99即1999年</td></tr><tr><td>m</td><td>数字月份，前面有前导0，如01。n 为无前导0数字月份</td><td>m</td><td>数字月份，前面有前导0，如01。n 为无前导0数字月份</td></tr><tr><td>F</td><td>月份，完整的文本格式，例如 January 或者 March</td><td>F</td><td>月份，完整的文本格式，例如 January 或者 March</td></tr><tr><td>M</td><td>三个字母缩写表示的月份，例如 Jan 或者 Mar</td><td>M</td><td>三个字母缩写表示的月份，例如 Jan 或者 Mar</td></tr><tr><td>d</td><td>月份中的第几天，前面有前导0，如03。j 为无前导0的天数</td><td>d</td><td>月份中的第几天，前面有前导0，如03。j 为无前导0的天数</td></tr><tr><td>w</td><td>星期中的第几天，以数字表示，0表示星期天</td><td>w</td><td>星期中的第几天，以数字表示，0表示星期天</td></tr><tr><td>z</td><td>年份中的第几天，范围0-366</td><td>z</td><td>年份中的第几天，范围0-366</td></tr><tr><td>W</td><td>年份中的第几周，如第32周</td><td>W</td><td>年份中的第几周，如第32周</td></tr><tr><td>H</td><td>24小时格式，有前导0，h为12小时格式</td><td>H</td><td>24小时格式，有前导0，h为12小时格式</td></tr><tr><td>G</td><td>24小时格式，无前导0，g为对应12小时格式</td><td>G</td><td>24小时格式，无前导0，g为对应12小时格式</td></tr><tr><td>i</td><td>分钟格式，有前导0</td><td>i</td><td>分钟格式，有前导0</td></tr><tr><td>s</td><td>秒格式，有前导0</td><td>s</td><td>秒格式，有前导0</td></tr><tr><td>A</td><td>大写上下午，如AM，a为小写</td><td>A</td><td>大写上下午，如AM，a为小写</td></tr></tbody></table><h2 id="CURL"><a href="#CURL" class="headerlink" title="CURL"></a>CURL</h2><pre><code class="php">public function Curl(string $url, $param) {        $curl = curl_init();        curl_setopt($curl, CURLOPT_URL, $url);        curl_setopt($curl, CURLOPT_CUSTOMREQUEST, &quot;POST&quot;);        curl_setopt($curl, CURLOPT_POSTFIELDS,json_encode($param));        curl_setopt($curl, CURLOPT_RETURNTRANSFER,true);        curl_setopt($curl, CURLOPT_HTTPHEADER, array(                &#39;Content-Type: application/json&#39;,                &#39;Content-Length: &#39; . strlen(json_encode($param)))        );        $data = curl_exec($curl);        curl_close($curl);        return $data;    }</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程风格</category>
      
      <category>PHP编程风格</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程风格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>key问题</title>
    <link href="undefined2020/07/13/%E9%94%99%E8%AF%AF/Java/List%E8%BD%ACMap/"/>
    <url>2020/07/13/%E9%94%99%E8%AF%AF/Java/List%E8%BD%ACMap/</url>
    
    <content type="html"><![CDATA[<p>list转map的时候，忘记了map的key不能重复的问题；其实初衷就是想 利用map的key不能重复的问题.</p><p>将list转为map，原以为是遍历list的方式，存map，然后map的key重复的话，直接覆盖,但是java8 中stream 确给我挖了个坑</p><pre><code class="java">/*** List -&gt; Map* 需要注意的是：* toMap 如果集合对象有重复的key，会报错Duplicate key ....*  apple1,apple12的id都为1。*  可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2*/Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a, (k1, k2) -&gt; k1));</code></pre><p>List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起：</p><pre><code class="java">//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));System.err.println(&quot;groupBy:&quot;+groupBy);{1=[Apple{id=1, name=&#39;苹果1&#39;, money=3.25, num=10}, Apple{id=1, name=&#39;苹果2&#39;, money=1.35, num=20}], 2=[Apple{id=2, name=&#39;香蕉&#39;, money=2.89, num=30}], 3=[Apple{id=3, name=&#39;荔枝&#39;, money=9.99, num=40}]}</code></pre>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的LLambda性能分析</title>
    <link href="undefined2020/07/13/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/Java%E7%9A%84Lambda%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>2020/07/13/%E5%90%8E%E7%AB%AF/Java/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/Java%E7%9A%84Lambda%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="for循环和lambda的性能比较"><a href="#for循环和lambda的性能比较" class="headerlink" title="for循环和lambda的性能比较"></a>for循环和lambda的性能比较</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="Java">public class main {    public static void main(String[] args) {        List&lt;User&gt; listUser = getListUsers();        //一般forEach        long startSimpleTime = System.currentTimeMillis();        for (User user : listUser) {            user.toString();        }        long endSimpleTime = System.currentTimeMillis();        System.out.println(&quot;Simple:&quot; + (endSimpleTime - startSimpleTime));        //java8中新的forEach        long startLambda = System.currentTimeMillis();        listUser.forEach(User::toString);        long endLambda = System.currentTimeMillis();        System.out.println(&quot;Lambda:&quot; + (endLambda - startLambda));        //java8中新的stream+forEach        long startStream = System.currentTimeMillis();        listUser.stream().forEach(User::toString);        long endStream = System.currentTimeMillis();        System.out.println(&quot;Stream:&quot; + (endStream - startStream));        //java8中新的parallelStream+forEach        long startParallelStream = System.currentTimeMillis();        listUser.parallelStream().forEach(User::toString);        long endParallelStream = System.currentTimeMillis();        System.out.println(&quot;ParallelStream:&quot; + (endParallelStream - startParallelStream));    }    private static List&lt;User&gt; getListUsers() {        List&lt;User&gt; listUser = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 1; i++) {            listUser.add(new User(&quot;user&quot; + i, i));        }        return listUser;    }}</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code class="Java">集合中数量为1Simple:0Lambda:55Stream:2ParallelStream:4</code></pre><pre><code class="Java">集合中数量为10Simple:0Lambda:38Stream:2ParallelStream:4</code></pre><pre><code class="Java">集合中数量为100Simple:1Lambda:47Stream:2ParallelStream:5</code></pre><pre><code class="Java">集合中数量为1000Simple:2Lambda:61Stream:3ParallelStream:6</code></pre><pre><code class="Java">集合中数量为10000Simple:7Lambda:48Stream:6ParallelStream:9</code></pre><pre><code class="Java">集合中数量为100000Simple:36Lambda:76Stream:13ParallelStream:9</code></pre><pre><code class="Java">集合中数量为1000000Simple:1028Lambda:131Stream:93ParallelStream:45</code></pre><pre><code class="Java">集合中数量为10000000Simple:3514Lambda:621Stream:642ParallelStream:381</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在数量级1<del>10000之间，采用普通的<strong>for循环性能最优</strong>，但是几毫秒的性能差异并不是太影响在性能峰值之外的区域，考虑到代码简洁等其他因素，还是可以采用stream流循环的形式。<br>在数量级10000</del>10000000之间，在不考虑线程安全的情况下采用并行流<strong>ParallelStream性能最优</strong>，在单线程的情况下<strong>stream的性能最优</strong>。</p><p><strong>因此无论何时，都不要直接使用xxxList.foreach()的方式来进行循环遍历，在只考虑性能或性能占比较大的情况下推荐使用stream流和ParallelStream流的形式进行遍历</strong></p>]]></content>
    
    
    <categories>
      
      <category>性能分析</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>性能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot和Mybatis的组合问题</title>
    <link href="undefined2020/07/10/%E9%94%99%E8%AF%AF/Mybatis/springboot%E5%92%8Cmybatis%E7%9A%84%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <url>2020/07/10/%E9%94%99%E8%AF%AF/Mybatis/springboot%E5%92%8Cmybatis%E7%9A%84%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题状况"><a href="#问题状况" class="headerlink" title="问题状况"></a>问题状况</h2><pre><code class="java">List&lt;Audioconverttochn&gt; audioConvertToCHNList = gameService.selectAudioConvertToCHN(hangUpList);audioConvertToCHNList.removeIf(audioConvertToCHN -&gt; StringUtils.isNotBlank(audioConvertToCHN.getResult()));public List&lt;Audioconverttochn&gt; selectAudioConvertToCHN(List&lt;UserCreditReport&gt; list) {    if (CollectionUtils.isEmpty(list)) {        list = new ArrayList&lt;&gt;();        UserCreditReport userCreditReport = new UserCreditReport();        userCreditReport.setUserNo(0);        userCreditReport.setGamerecordNo(0);        list.add(userCreditReport);    }    return new ArrayList&lt;&gt;(gameDao.selectAudioConvertToCHN(list));}// 第二次返回的接口地址和第一次的相同，正常sql查询 会有3条记录，但是对象中只存在一条List&lt;Audioconverttochn&gt; audioConvertToCHNList = gameService.selectAudioConvertToCHN(hangUpList);</code></pre><p>传入一个参数<br>如果你在service方法中传入相同的参数，会得到同一个对象</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>new ArrayList(creditDao.selectxxx());</p>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP操作数据库的注意事项</title>
    <link href="undefined2020/07/10/%E9%94%99%E8%AF%AF/PHP/PHP%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>2020/07/10/%E9%94%99%E8%AF%AF/PHP/PHP%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="关于时间的sql语句"><a href="#关于时间的sql语句" class="headerlink" title="关于时间的sql语句"></a>关于时间的sql语句</h2><p><strong>一定要将与时间比较的变量用单引号包起来</strong></p><pre><code class="php">public function weekIn($cpId, $start, $end) {    $pdo = $this-&gt;GetPdo();    $sql = &#39;SELECT SUM(intimacy_add) as weekIn FROM cp_intimacy_record             WHERE delsign = 0 and cp_id = &#39; . $cpId . &#39; and createtime BETWEEN \&#39;&#39; . $start . &#39;\&#39; and \&#39;&#39; . $end . &#39;\&#39;&#39;;    $prepare = $pdo-&gt;prepare($sql);    $prepare-&gt;execute();    return $prepare-&gt;fetchAll(PDO::FETCH_ASSOC);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误处理</title>
    <link href="undefined2020/07/02/%E5%90%8E%E7%AB%AF/php/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>2020/07/02/%E5%90%8E%E7%AB%AF/php/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><blockquote><p>指的是系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员</p></blockquote><h2 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h2><ol><li>语法错误：用户书写的代码不符合PHP的语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行（Parse error）</li><li>运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（runtime error）</li><li>逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性错误，导致代码正常执行，但是得不到想要的结果</li></ol><h2 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h2><p>所有看到的错误代码在PHP中都被定义成了系统常量（可以直接使用）</p><ol><li>系统错误：<br> E_PARSE: 编译错误，代码不会执行<br> E_ERROR: fatal error,致命错误，会导致代码不能正确继续执行（出错的位置断掉）<br> E_WARING: warning,警告错误，不会影响代码执行，但是可能得到意想不到的结果<br> E_NOTICE: 通知错误，不会影响代码执行</li><li>用户错误: E_USER_ERROR、E_USER_WARNING、E_USER_NOTCE<br> 用户在使用自定义错误出发的时候，会使用到的错误代号（系统不会用到）</li><li>其他: E_ALL代表所有错误（通常在进行错误控制的时候使用比较多），建议在开发过程中使用</li></ol><p>所有已E开头的错误常量（代号）起始都是由一个字节存储，然后每一种错误占据一个对应的位，如果想进行一些错误的控制，可以使用位运算进行操作。</p><p>排除通知级别notice: E_ALL &amp; ~E_NOTICE<br>只要警告和通知：E_WARNING | E_NOTICE</p><h2 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h2><p>程序运行时触发：胸痛自动根据错误发生后，对比对应的错误信息，输出给用户：主要针对代码的语法错误和运行时错误<br>人为触发：指导某些逻辑可能会出错，从而使用对应的判断代码来触发相应的错误提示</p><pre><code class="php">// PHP错误处理// 处理脚本让浏览器按照指定字符集解析的方法header(&#39;Content-type:text/html;charset=utf-8&#39;);$a  = 100;echo $a;if ($a != 0) {    // 人为触发错误    trigger_error(&#39;除数不能为0&#39;);    trigger_error(&#39;除数不能为0&#39;, E_USER_ERROR);}echo &#39;hello&#39;;</code></pre><p>trigger_error可以通过第二个参数来进行严格性控制</p><h2 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h2><p>错误显示设置：那些错误该显示，以及该如何显示</p><p>在PHP中，其实又两种方式来设置当前脚本的错误处理</p><ol><li>PHP的配置文件：全局配置：php.ini文件<br> Display_errors: 是否显示错误<br> Error_reporting: 显示什么级别的错误</li><li>可以在运行的PHP脚本中去设置: 在脚本中定义的配置级别比配置文件高<br> Error_reporting（）：设置对应的错误显示级别<br> Ini_set(‘配置文件中的配置项’，配置值)<br> Ini_set(‘error_reporting’,E_ALL)<br> Ini_set(‘display_errors’,1)</li></ol><h2 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h2><p>在实际生产环境中，不糊i直接让错误展示给用户</p><ol><li>不友好</li><li>不安全：错误会暴漏网站很多信息（路径、文件名）</li></ol><p>所以正在生产环境中，一般不显示错误，但是不可能避免会出现错误，这个时候不希望看到，但是又下往捕捉到可以让后台程序员去修改：需要保存到日志文件，需要在PHP配置文件中或者代码中（ini_set）设置对应error_log配置项</p><ol><li>开启日志功能<br> log_errors = On</li><li>指定路径<br> error_log = ‘E:/…/php_error.log’</li></ol><h2 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h2><p>最简单的错误处理：trigger_errors()函数，但是该函数不会阻止系统报错<br>PHP系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加到操作系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。</p><ol><li>如何将用户自定义的函数放到系统中？set_error_handler()</li><li>自定义错误处理函数，系统有要求</li></ol><pre><code class="php">&lt;?php// 自定义错误处理机制header(&#39;Content-type:text/html;charset=utf-8&#39;);// 自定义函数/** * @param $err * @param $errstr * @param $errdile * @param $errline */function my_error($errno, $errstr, $errfile, $errline){    // 判断：当前会碰到的错误有哪些    if (!(error_reporting() &amp; $errno)) { // error_reporting没有参数代表获取当前系统错误处理对应的级别        return false;        // error_reporting没有参数代表获取当前系统错误处理对应的界别    }    // 开始判断错误类型    switch ($errno) {        case E_ERROR:        case E_USER_ERROR:            echo &quot;fatal error in file $errfile on line $errline &lt;br/&gt;&quot;;            echo &quot;error info : $errstr&quot;;            break;        case E_WARNING:        case E_USER_WARNING:            echo &quot;Warning error in file $errfile on line $errline &lt;br/&gt;&quot;;            echo &quot;Warning info : $errstr&quot;;            break;        case E_NOTICE:        case E_USER_NOTICE:            echo &quot;Notice error in file $errfile on line $errline &lt;br/&gt;&quot;;            echo &quot;Notice info : $errstr&quot;;            break;    }}// 报错echo $a;// 修改错误机制set_error_handler(&#39;my_error&#39;);echo $a;</code></pre><p>当前属于简单自定义模式，如果要复杂，可以在某些影响代码功能的错误发生后，让用户跳转到某个指定界面。</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的查询异常</title>
    <link href="undefined2020/06/22/%E9%94%99%E8%AF%AF/Java/JedisDataException/"/>
    <url>2020/06/22/%E9%94%99%E8%AF%AF/Java/JedisDataException/</url>
    
    <content type="html"><![CDATA[<pre><code class="Java">[MG][ERROR][2020-06-19 09:08:58,904]|REDIS查询异常|[qtp1371957475-16]redis.clients.jedis.exceptions.JedisDataException: value sent to redis cannot be null    at redis.clients.util.SafeEncoder.encode(SafeEncoder.java:28) ~[werewolf-client-jp.jar:?]    at redis.clients.jedis.Client.hget(Client.java:211) ~[werewolf-client-jp.jar:?]    at redis.clients.jedis.Jedis.hget(Jedis.java:760) ~[werewolf-client-jp.jar:?]    at com.mega.server.jedis.MegaJedisUtil.getHashValue(MegaJedisUtil.java:24) ~[werewolf-client-jp.jar:?]    at com.mega.werewolf.server.handler.EnterRoomHandler.handle(EnterRoomHandler.java:35) ~[werewolf-client-jp.jar:?]    at com.mega.werewolf.server.HttpHandler.dispatch(HttpHandler.java:71) ~[werewolf-client-jp.jar:?]    at com.mega.werewolf.server.HttpHandler.handle(HttpHandler.java:55) ~[werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:127) ~[werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.Server.handle(Server.java:500) ~[werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.HttpChannel.lambda$handle$1(HttpChannel.java:383) ~[werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.HttpChannel.dispatch(HttpChannel.java:547) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:375) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:270) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:311) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:103) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.io.ChannelEndPoint$2.run(ChannelEndPoint.java:117) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:806) [werewolf-client-jp.jar:?]    at org.eclipse.jetty.util.thread.QueuedThreadPool$Runner.run(QueuedThreadPool.java:938) [werewolf-client-jp.jar:?]    at java.lang.Thread.run(Thread.java:748) [?:1.8.0_191]</code></pre><p>redis.set(key, value)</p><p>1.如果key是null</p><p>redis.clients.jedis.exceptions.JedisDataException: value sent to redis cannot be null</p><p>2.如果value是null</p><p>redis.clients.jedis.exceptions.JedisDataException: value sent to redis cannot be null</p><p>所以说，哪个都不能为null。</p><pre><code class="Java">String port = MegaJedisUtil.getHashValue(ServerWerewolfConst.WF_ROOM_SERVER, String.valueOf(roomNo));String ip = MegaJedisUtil.getHashValue(ServerWerewolfConst.WF_PORT_IP, port);if (StringUtil.isEmpty(ip) ||StringUtil.isEmpty(port)) {    LogTool.logError(&quot;ip或port为空&quot;);    JSONObject object = new JSONObject();    object.put(&quot;sign&quot;, &quot;0&quot;);    return object;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误,Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php文件包含</title>
    <link href="undefined2020/06/22/%E5%90%8E%E7%AB%AF/php/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>2020/06/22/%E5%90%8E%E7%AB%AF/php/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><blockquote><p>定义：文件包含，就是在一个要运行的PHP脚本中，去将另外一个PHP脚本中的代码拿过来，并且可以使用其被包含的文件里的内容，或者说将自己的内容能够在另外一个被包含的文件中使用。</p></blockquote><ol><li>文件包含基本语法：PHP中提供了四种文件包含的方法，分别是include和include_once，require和require_once，其中四种方式的用法完全一样<br> <code>include/include_once/require/equire_once &#39;文件所在路径及文件名&#39;;</code><br> <code>include/include_once/require/equire_once(&#39;文件所在路径及文件名&#39;);</code></li><li>文件包含的意义：文件包含的目的有两个<ul><li>向上包含：即先包含某个文件，目的为了使用某个文件中的代码或者数据（使用公共代码）</li><li>向下包含：即先写好代码，后包含文件，目的是为了在被包含文件中使用当前的数据（使用已产生数据）</li></ul></li><li>文件包含的语法区别：四种包含方式都能够包含文件并使用<br> include和require的区别在于，如果包含的文件不存在的时候，include只是报警告错误，而不影响自身代码执行；而require会报致命错误，而且中断代码执行<br> include和<strong>include_once</strong>区别：include不论如何都会执行包含操作，而include_once会记录是否已经包含过对应文件，对同一文件多次包含只操作一次（对于函数/类这种结构不允许重复的，是个好方法）。</li><li>文件包含原理：文件包含本质就是将被包含文件的所有代码，在进行包含操作那一行全部引入并运行。但是文件包含语句是在运行时才会执行，因此不能先访问被包含文件中的内容，后包含文件。</li></ol><h2 id="php中require，include，use的区别"><a href="#php中require，include，use的区别" class="headerlink" title="php中require，include，use的区别"></a>php中require，include，use的区别</h2><ol><li>require，include都是导入文件，但是require如果找不到文件，直接error，程序退出；include是warning，继续执行；</li><li>use是使用命名空间，相当于java中的导包，前提是包中的文件需要提前require或者include进来。</li><li>namespace命名空间，相当于java中的package，定义一个包</li><li>use使用的时候后面的需要写全空间名+类名 ，例如命名空间Person1/Person; 其中Person1是命名空间，Person是类名；</li></ol><pre><code class="php">use Sdbean\Helpers\Controller;use Sdbean\Service\GetHallBannerService;include_once(&quot;../tools/toolIndex.php&quot;);</code></pre><h3 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h3><p>PHP代码的执行流程</p><ol><li>读取代码（PHP程序）</li><li>编译：将PHP代码转换成字节码（生成opcode）</li><li>zendengine来解析opcode，按照字节码去进行逻辑运算</li><li>转换成对应的HTML代码</li></ol><p>文件加载原理：</p><ol><li>当文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</li><li>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置</li><li>在PHP中被包含的文件时单独进行编译的</li></ol><p>PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句对的时候才会报错。</p><h3 id="include和require区别"><a href="#include和require区别" class="headerlink" title="include和require区别"></a>include和require区别</h3><p>include和include_once区别：<br>include系统会碰到一次，执行一次；如果对同一个文件进行多次加载，那么系统会执行多次；<br>include_once：系统碰到措辞，也只会执行一次</p><pre><code class="php">include1.php$a = 1;define(&#39;PI&#39;,3.14);include2.php// 包含文件include &#39;include1.php&#39;; // 包含当前文件include2.php所在文件夹下的include1.phpecho $a,PI;// 再次包含include &#39;include1.php&#39;;13.14报错：PI常量已经存在</code></pre><p>include的错误级别比较轻：不会阻止代码执行<br>require要求较高：如果包含出错代码不再执行（require后面的代码）</p><h3 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h3><p>文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。</p><p>文件的加载路径包含两大类：</p><ol><li>绝对路径：<br> 从磁盘的根目录开始（本地绝对路径）<br> Windows：盘符C:/路径/PHP文件<br> Linux：/路径/PHP文件<br> 从网站根目录开始（网络绝对路径）<br> /: 相对于网站主机名字对应的路径<br> localhost/index.php-&gt;E:/server/xampp/htdoc/index.php</li><li>相对路径：从当前文件所在目录开始的路径<br> .或者./ : 表示当前文件夹<br> ../ : 上级目录（当前文件夹的上一层文件夹）</li></ol><p>绝对路径和相对路径的加载区别：</p><ol><li>绝对路径相对效率偏低，但是相对安全</li><li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li></ol><h3 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h3><p>文件嵌套包含：一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件。</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用系统函数</title>
    <link href="undefined2020/06/21/%E5%90%8E%E7%AB%AF/php/%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/"/>
    <url>2020/06/21/%E5%90%8E%E7%AB%AF/php/%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基本概念"><a href="#函数的基本概念" class="headerlink" title="函数的基本概念"></a>函数的基本概念</h3><p>函数：function,是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）。</p><h3 id="函数定义语法"><a href="#函数定义语法" class="headerlink" title="函数定义语法"></a>函数定义语法</h3><p>函数有几个对应的关键点：function关键字、函数名、参数（形参和实参）、函数体和返回值</p><p>基本语法如下：<br>Function 函数名([参数]){<br>    // 函数体<br>    // 返回值：return 结果<br>}</p><p>定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）<br>函数的使用：通过访问函数的名字+(); // 如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数：函数是一种结构不会自动运行，必须通过调用才会执行。<br>函数是在代码执行阶段，碰到函数名字的时候才会调用，不是在编译阶段。</p><p>函数执行的内存分析：</p><ol><li>读取代码进入到代码段（编译：将代码编程字节码存储带内存）</li><li>根据代码逐行执行</li></ol><p>以上原因：编译和执行时分开的（先编译后执行）</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数的参数分为两种：形参和实参</p><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>形参：形式参数，不具有实际意义的参数，是在函数定义时使用的参数</p><h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><p>实参：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数</p><p>形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算，那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：需要实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>默认值：default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。<br>通常默认值是用在一些，一定会有</p><pre><code class="php">function jian($num = 0,$num1 = 0){ // 当前的$num1是形参，在编译时不执行，即便执行也是在jian函数内部，不会与玩不的$num1变量冲突    echo $num - $num1;}// 调用：默认值如果存在，可以不用传入jian(2);</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>默认值的定义是放在最后边的（多个），不能左边形参有默认值，但是右边没有</li></ol><p>函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的；如果多个函数使用同样的形参名字也不冲突。</p><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递：将实参（如果是变量或者常量或者其他表达式）的结果取出来赋值给形参：形参与外部实际传入的参数本身没有任何关联关系，只是结构一样。<br><strong>只有变量能够引用传递</strong></p><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>返回值：return，指的是将函数实现的结果，通过return关键字，返回给函数外部(函数调用处)：在PHP中所有的函数都有返回值。如果没有明确return使用，那么系统默认返回NULL）</p><h3 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h3><blockquote><p>当前有一个变量所保存的值，刚好是一个函数的名字，那么捷克语使用变量+()来充当函数名使用。</p></blockquote><pre><code class="php">$a = &#39;display&#39;;function display($num=0){    echo $num;}s$a();</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>没有名字的函数</p></blockquote><pre><code class="php">$a = function (){    // 函数体};$a();var_dump($a());//object(Closure)#1 (0) { }  </code></pre><p>变量保存匿名函数，本质得到的是一个对象。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><blockquote><p>Closure,一词源于一下两者的结合：要执行的代码块（由于自由变量呗包含在代码块中，这些自由变量以及他们引用的对象没有被释放）和为自由变量提供绑定的计算机环境（作用域）</p></blockquote><h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><ol><li>print(): 类似于echo输出提供的内容，本质是一种结构（不是函数），返回1，可以不需要使用括号</li><li>print_r(): 类似于var_dump,但是比var_dump简单，不会输出数据的类型，只会输出值</li></ol><pre><code class="php">$a = &#39;hello world&lt;br/&gt;&#39;;echo print $a;  // hello world 1print $a; // hello worldprint_r($a); // hello worldhello world1hello worldhello world</code></pre><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><ol><li>date(): 按照9指定格式对应的时间戳（从1970年格林威治时间开始计算的秒数）如果没有特定格式的时间戳，返回time函数的时间戳</li><li>time(): 获取当前时间对应的时间戳</li><li>microtime(): 获取微秒级别的时间</li><li>Strtotime(): 按照规定格式的字符串转换成时间戳</li></ol><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ol><li>max(): 指定参数中最大的值，可以传数组，或两个值</li><li>min(): 得到两个数中较小的值</li><li>rand([int $min], max): 得到指定遇见的随机整数</li><li>mt_rand(): 效率比rand高（建议使用）</li><li>round(): 四舍五入</li><li>ceil(): 向上取整</li><li>floor(): 向下取整</li><li>pow(): 求指定数字的指定指数次结果<code>pow(2,8) == 2^8==256</code></li><li>abs(): 绝对值</li><li>sqrt(): 求平方根</li></ol><h2 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h2><ol><li>function_exit(): 判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）</li><li>func_get_arg(): 在自定义函数中去获取指定数值对应的参数</li><li>func_get_args(): 在自定义函数中获取所有的参数（数组）</li><li>func_mun_args(): 获取当前自定义函数的参数数量</li></ol><pre><code class="php">echo &#39;&lt;pre&gt;&#39;;function test($a,$b){    // 获取指定参数    var_dump(func_get_arg(1));    // 获取所有参数    var_dump(func_get_args());    // 获取参数数量    var_dump(func_num_args());}function_exists(&#39;test&#39;) &amp;&amp; test(1,&#39;2&#39;,3,4);string(1) &quot;2&quot;array(4) {  [0]=&gt;  int(1)  [1]=&gt;  string(1) &quot;2&quot;  [2]=&gt;  int(3)  [3]=&gt;  int(4)}int(4)</code></pre><p>func_get_args和func_num_args都是统计的对应的实参数量</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch 新旧索引数据迁移(_reindex)</title>
    <link href="undefined2020/06/12/%E5%90%8E%E7%AB%AF/Elasticsearch/Elasticsearch%20%E6%96%B0%E6%97%A7%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB(_reindex)/"/>
    <url>2020/06/12/%E5%90%8E%E7%AB%AF/Elasticsearch/Elasticsearch%20%E6%96%B0%E6%97%A7%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB(_reindex)/</url>
    
    <content type="html"><![CDATA[<p>Elasticsearch 新旧索引数据迁移(_reindex)</p><p>举个例子，在输入“1992-02-27”这样格式的数据，es会把他默认为是date数据类型，但是有时候我们希望它是text类型，在原索引中已经有数据的情况下该如何操作。</p><ol><li>创建原索引</li></ol><pre><code>PUT /aaron_index/aaron_type/1{  &quot;name&quot;:&quot;张辽&quot;,&quot;age&quot;:27,&quot;content&quot;:&quot;1992-02-27&quot;}PUT /aaron_index/aaron_type/2{  &quot;name&quot;:&quot;曹阿瞒&quot;,&quot;age&quot;:28,&quot;content&quot;:&quot;1991-02-19&quot;}</code></pre><ol start="2"><li>创建新索引</li></ol><pre><code>PUT /aaron_index_new{  &quot;mappings&quot;: {    &quot;aaron_type&quot;:{      &quot;properties&quot;:{        &quot;content&quot;:{&quot;type&quot;:&quot;text&quot;},        &quot;name&quot;:{&quot;type&quot;:&quot;text&quot;}      }    }  }}</code></pre><pre><code>PUT /aaron_index_new/aaron_type/2{  &quot;name&quot;:&quot;曹操&quot;,&quot;content&quot;:&quot;1991-02-19,28岁&quot;}</code></pre><p>3.查看两个索引的mapping类型</p><pre><code>GET /aaron_index/_mappingGET /aaron_index_new/_mapping</code></pre><p>4.将原索引全部放入新索引中，_id冲突的以原索引为准</p><p>虽然新索引中只有两个字段(原索引中有三个)，也会将原索引中的数据插入新索引中，并覆盖_id相同的数据。</p><pre><code>POST _reindex{  &quot;source&quot;: {&quot;index&quot;: &quot;aaron_index&quot;},  &quot;dest&quot;: {&quot;index&quot;: &quot;aaron_index_new&quot;}}</code></pre><p>5.将原索引放入新索引中，_id冲突的以新索引为准</p><p>虽然新索引中只有两个字段(原索引中有三个)，也会将原索引中的数据插入新索引中，但不覆盖_id相同的数据。</p><pre><code>POST _reindex{  &quot;conflicts&quot;: &quot;proceed&quot;,  &quot;source&quot;: {&quot;index&quot;: &quot;aaron_index&quot;},  &quot;dest&quot;: {&quot;index&quot;: &quot;aaron_index_new&quot;,&quot;op_type&quot;: &quot;create&quot;}}</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「羲凡丞相」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42003671/article/details/96485675" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42003671/article/details/96485675</a></p>]]></content>
    
    
    <categories>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php文件操作</title>
    <link href="undefined2020/06/11/%E5%90%8E%E7%AB%AF/php/php%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>2020/06/11/%E5%90%8E%E7%AB%AF/php/php%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="readfile读取文件"><a href="#readfile读取文件" class="headerlink" title="readfile读取文件"></a>readfile读取文件</h3><blockquote><p>传入一个文件路径，输出一个文件。</p></blockquote><pre><code class="php">int readfile ( string $文件名)//linux类的读了方式readfile(&quot;/home/paul/test.txt&quot;);//windows类的读取方式readfile(&quot;c:\\boot.ini&quot;);</code></pre><p>注意：上面的代码中windows的斜线是\斜线，可能会转义掉一些字符。因此，我们写的时候写上两个斜线。</p><h3 id="file-get-contents打开文件"><a href="#file-get-contents打开文件" class="headerlink" title="file_get_contents打开文件"></a>file_get_contents打开文件</h3><blockquote><p>传入一个文件或文件路径，打开这个文件返回文件的内容。文件的内容是一个字符串。</p></blockquote><pre><code class="php">string file_get_contents ( string filename)//假设我们有一个多行的文件叫NoAlike.txt，没有的话你可以新建一个这个文件$filename = &#39;NoAlike.txt&#39;;//打开这个文件，将文件内容赋值给$filestring$filestring = file_get_contents($filename);//因为每一行有一个回车即\n，我用\n来把这个字符串切割成数组$filearray = explode(&quot;\n&quot;, $filestring);//把切割成的数组，下标赋值给$key,值赋值给$val，每次循环将$key加1。while (list($key, $val) = each($filearray)) {    ++$key;    $val = trim($val);    //用的单引号，单引号不解释变量进行了拼接而已    print &#39;Line&#39; . $key .&#39;:&#39;.  $val.&#39;&lt;br /&gt;&#39;;}</code></pre><h3 id="fopen、fread、fclose操作读取文件"><a href="#fopen、fread、fclose操作读取文件" class="headerlink" title="fopen、fread、fclose操作读取文件"></a>fopen、fread、fclose操作读取文件</h3><pre><code class="php">resource fopen ( string $文件名, string 模式)string fread ( resource $操作资源, int 读取长度)bool fclose ( resource $操作资源 )</code></pre><p>通过上面的函数我们来讲解资源类型的通常操作方式：</p><ol><li>打开资源</li><li>使用相关函数进行操作</li><li>关闭资源</li></ol><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><p>fopen函数的功能是打开文件，参数主要有两个：</p><ol><li>文件打开的路径</li><li>打开文件的模式</li></ol><p>返回类型是一个资源类型，我们第一次遇到了之前基础类型的时候讲到的资源类型。<br>资源类型需要其他的函数来操作这个资源。所有的资源有打开就要有关闭。</p><h5 id="fopen的模式"><a href="#fopen的模式" class="headerlink" title="fopen的模式"></a>fopen的模式</h5><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>只读方式打开，将文件指针指向文件头。</td></tr><tr><td>r+</td><td>读写方式打开，将文件指针指向文件头。</td></tr><tr><td>w</td><td>写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建</td></tr><tr><td>w+</td><td>读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建</td></tr><tr><td>a</td><td>写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建</td></tr><tr><td>a+</td><td>读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之</td></tr><tr><td>x</td><td>创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建</td></tr><tr><td>x+</td><td>创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建</td></tr></tbody></table><h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><blockquote><p>函数的功能的功能是读取打开的文件资源。读取指定长度的文件资源，读取一部份向后移动一部份。至到文件结尾。</p></blockquote><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><blockquote><p>fclose函数的功能是关闭资源。资源有打开就有关闭。</p></blockquote><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="file-put-contents写入文件"><a href="#file-put-contents写入文件" class="headerlink" title="file_put_contents写入文件"></a>file_put_contents写入文件</h3><pre><code class="php">int file_put_contents ( string $文件路径, string $写入数据])</code></pre><p>功能：向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度</p><h3 id="fwrite配合fopen进行写入操作"><a href="#fwrite配合fopen进行写入操作" class="headerlink" title="fwrite配合fopen进行写入操作"></a>fwrite配合fopen进行写入操作</h3><pre><code class="php">int fwrite ( resource $文件资源变量, string $写入的字符串 [, int 长度])// 注：fwrite的别名函数是fputs</code></pre><pre><code class="php">&lt;?php   $filename = &#39;test.txt&#39;;   $fp= fopen($filename, &quot;w&quot;);   $len = fwrite($fp, &#39;我是一只来自北方的狼，却在南方冻成了狗&#39;);   fclose($fp);   print $len .&#39;字节被写入了\n&#39;;</code></pre><p>总结：</p><ol><li>不论有没有新建都会打开文件重新写入</li><li>原有的文件内容会被覆盖掉</li><li>文件不存在会创建</li></ol><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>我们之前创建的文件都是永久文件。</p><p>而创建临时文件在我们平时的项目开发中也非常有用。创建临时文件的几个好处：</p><p>文完后即删除</p><p>不需要去维护这个文件的删除状态</p><p>例如：我需要把A的文件内容转存B里面，把B的文件内容转存到C里面。</p><pre><code class="php">resource tmpfile ( )</code></pre><p>功能：创建一个临时文件，返回资源类型。关闭文件即被删除。</p><pre><code class="php">//创建了一个临时文件$handle = tmpfile();//向里面写入了数据$numbytes = fwrite($handle, &#39;写入临时文件&#39;);//关闭临时文件，文件即被删除fclose($handle);echo  &#39;向临时文件中写入了&#39;.$numbytes . &#39;个字节&#39;;向临时文件中写入了18个字节</code></pre><h2 id="移动、拷贝和删除文件"><a href="#移动、拷贝和删除文件" class="headerlink" title="移动、拷贝和删除文件"></a>移动、拷贝和删除文件</h2><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><pre><code class="php">bool rename($旧名,$新名);这个函数返回一个bool值，将旧的名字改为新的名字。</code></pre><pre><code class="php">//旧文件名$filename = &#39;test.txt&#39;;//新文件名$filename2 = $filename . &#39;.old&#39;;//复制文件rename($filename, $filename2);</code></pre><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><pre><code class="php">bool copy(源文件,目标文件)功能：将指定路径的源文件，复制一份到目标文件的位置。</code></pre><pre><code class="php">//旧文件名$filename = &#39;copy.txt&#39;;//新文件名$filename2 = $filename . &#39;_new&#39;;//修改名字。copy($filename, $filename2);</code></pre><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php数组与数据结构</title>
    <link href="undefined2020/06/03/%E5%90%8E%E7%AB%AF/php/php%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>2020/06/03/%E5%90%8E%E7%AB%AF/php/php%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h3><ol><li>数组可以存入多个不同类型的数据，是一个复合数据类型。</li><li>数组的英文是array，学一了一下最简单的数组声明。</li></ol><pre><code class="php">$shu = array(1 , 1.5 , true ,&#39;天王盖地虎，小鸡炖蘑菇&#39;);echo &#39;&lt;pre&gt;&#39;;var_dump($shu);echo &#39;&lt;/pre&gt;&#39;;结果是：array(4) {  [0]=&gt;  int(1)  [1]=&gt;  float(1.5)  [2]=&gt;  bool(true)  [3]=&gt;  string(33) &quot;天王盖地虎，小鸡炖蘑菇&quot;}</code></pre><ol><li>array(size = 4) 说明里面有4个元素</li><li>0 =&gt; int 1 我们知道int是整型的意思，1是一个整型的数值。那前面的0,1,2,3和=&gt;代表什么意思呢？</li><li>最新前的0，1，2，3代表的是值的读取标识号，我们称之为下标或者键（英文：key）</li><li>=&gt; 是一个符号标准叫法叫作：键值对应符。因此，以后再看到 0=&gt; int 1 可以这样来说。 下标访问符0对应整型的1。</li><li>我们还称数组里面的键值对为元素，元素就是键值对的组合。</li></ol><pre><code class="php">$kele = array(           &#39;只有不断努力才能博得未来&#39;,           &#39;a&#39; =&gt; &#39;NoAlike&#39;,           &#39;PHP中文网&#39; ,           &#39;去PHP中文网学PHP&#39;,           19 =&gt; &#39;凤姐和芙蓉我都爱&#39; ,           &#39;杨幂我最爱&#39;       );//打印显示$keleecho &#39;&lt;pre&gt;&#39;;var_dump($kele);echo &#39;&lt;/pre&gt;&#39;;结果是：array(6) {  [0]=&gt;  string(36) &quot;只有不断努力才能博得未来&quot;  [&quot;a&quot;]=&gt;  string(7) &quot;NoAlike&quot;  [1]=&gt;  string(12) &quot;PHP中文网&quot;  [2]=&gt;  string(21) &quot;去PHP中文网学PHP&quot;  [19]=&gt;  string(24) &quot;凤姐和芙蓉我都爱&quot;  [20]=&gt;  string(15) &quot;杨幂我最爱&quot;}</code></pre><ol><li>索引数组若不强制声明他的下标，他的下标是从0开始的。（我们的第一个数组的值：只有不断努力才能博得未来。这个值的下标为0）。</li><li>如果我指定过下标他的下标就为我指定的值。如下标为10和下标为19的，都是我指定过的值。</li><li>若某个值（如NoAlike），强制指定了下标（下标为10）。在它后面加上的值（PHP中文网），不指定下标的话。他们的下标增长规律为最大值+1。</li></ol><p>一、直接用之前未声明的变量，用变量名后面接中括号的方式声明数组。</p><pre><code class="php">    //直接写一个变量后面加上中括号，声明变量    $qi[] = &#39;可口可乐&#39;;    $qi[10] =&#39;百事可乐&#39;;    echo &#39;&lt;pre&gt;&#39;;    var_dump($qi);    echo &#39;&lt;/pre&gt;&#39;;</code></pre><p>二、每次用array()写的太麻烦了，还可以不用写array哟，更简单。</p><h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><pre><code class="php">$minren = array(           &#39;杨幂&#39;,           &#39;王珞丹&#39;,           &#39;刘亦菲&#39;,           &#39;黄圣依&#39;       );//如何向这$minren这个数组中增加元素呢//猜猜范冰冰的下标是多少？$minren[] = &#39;范冰冰&#39;;$minren[100] = &#39;范爷&#39;;//它的下标又为几呢？$minren[] = &#39;李晨&#39;;</code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre><code class="php">$minren = array(           &#39;杨幂&#39;,           &#39;王珞丹&#39;,           &#39;刘亦菲&#39;,           &#39;黄圣依&#39;,           &#39;范冰冰&#39;       );//假设我不喜欢：黄圣依，如何将黄圣依给删掉掉呢？//如果删除掉后范冰冰的下标为多少呢？//如果在后面再追加一个元素，会填掉：“黄圣依”留下来的空吗？unset($minren[3]);$minren[] = &#39;金星&#39;;echo &#39;&lt;pre&gt;&#39;;var_dump($minren);echo &#39;&lt;/pre&gt;&#39;;</code></pre><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><h3 id="​foreach遍历关联数组"><a href="#​foreach遍历关联数组" class="headerlink" title="​foreach遍历关联数组"></a>​foreach遍历关联数组</h3><pre><code class="php">foreach( 要循环的数组变量 as [键变量 =&gt;] 值变量){//循环的结构体}</code></pre><h3 id="list、each函数遍历数组"><a href="#list、each函数遍历数组" class="headerlink" title="list、each函数遍历数组"></a>list、each函数遍历数组</h3><p>list ( mixed $变量1 [, mixed $变量n ] )</p><pre><code class="php">&lt;?phplist($one, $two, $three) = array(2 =&gt; &#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;);echo &#39;$one----&#39; . $one . &#39;&lt;br /&gt;&#39;;echo &#39;$two----&#39; . $two . &#39;&lt;br /&gt;&#39;;echo &#39;$three----&#39; . $three . &#39;&lt;br /&gt;&#39;;?&gt;$one----$two----$three----张三</code></pre><ol><li>因为是一一对应原则，$one找不到下标为0的数组元素，$two找不到下标为1的数组元素，只有$three找到了下标为2的数组元素</li><li>在list($one, $two, $three)，我只写了三个变量。对应完成，无需再对应后面的变量了，丢弃李四和王五。</li></ol><p>array each ( array &amp;$array )</p><pre><code class="php">&lt;?php//定义一个变量叫$kongjie(空姐)$kongjie=[   &#39;gao&#39;=&gt;&#39;穿黑衣服的&#39;,   &#39;shou&#39;=&gt;&#39;退特别长特别细&#39;,   &#39;mei&#39;=&gt;&#39;好白&#39;,   ];//第一次each$data = each($kongjie);echo &#39;&lt;pre&gt;&#39;;var_dump($data);echo &#39;&lt;/pre&gt;&#39;;echo &#39;-----华丽丽分割线------&lt;br /&gt;&#39;;//第2次each$data = each($kongjie);echo &#39;&lt;pre&gt;&#39;;var_dump($data);echo &#39;&lt;/pre&gt;&#39;;echo &#39;-----华丽丽分割线------&lt;br /&gt;&#39;;//第3次each【执行到了最后一个元素了】$data = each($kongjie);echo &#39;&lt;pre&gt;&#39;;var_dump($data);echo &#39;&lt;/pre&gt;&#39;;echo &#39;-----华丽丽分割线------&lt;br /&gt;&#39;;//第4次【此时，后面已没有可操作的元素了，看返回什么】$data = each($kongjie);echo &#39;&lt;pre&gt;&#39;;var_dump($data);echo &#39;&lt;/pre&gt;&#39;;echo &#39;-----华丽丽分割线------&lt;br /&gt;&#39;;?&gt;array(4) {  [1]=&gt;  string(15) &quot;穿黑衣服的&quot;  [&quot;value&quot;]=&gt;  string(15) &quot;穿黑衣服的&quot;  [0]=&gt;  string(3) &quot;gao&quot;  [&quot;key&quot;]=&gt;  string(3) &quot;gao&quot;}-----华丽丽分割线------array(4) {  [1]=&gt;  string(21) &quot;退特别长特别细&quot;  [&quot;value&quot;]=&gt;  string(21) &quot;退特别长特别细&quot;  [0]=&gt;  string(4) &quot;shou&quot;  [&quot;key&quot;]=&gt;  string(4) &quot;shou&quot;}-----华丽丽分割线------array(4) {  [1]=&gt;  string(6) &quot;好白&quot;  [&quot;value&quot;]=&gt;  string(6) &quot;好白&quot;  [0]=&gt;  string(3) &quot;mei&quot;  [&quot;key&quot;]=&gt;  string(3) &quot;mei&quot;}-----华丽丽分割线------bool(false)-----华丽丽分割线------</code></pre><ol><li>读一次向后移动一次【可以想象有一个记录的箭头在移动】，将其中的每个元素拆解成一个新数组。</li><li>读取到最后，没有可操作的元素了，所以返回了false。</li></ol><h3 id="list、each配合使用"><a href="#list、each配合使用" class="headerlink" title="list、each配合使用"></a>list、each配合使用</h3><pre><code class="php">&lt;?php//定义一个变量叫$kongjie(空姐)$kongjie=[   &#39;gao&#39;=&gt;&#39;穿黑衣服的&#39;,   &#39;shou&#39;=&gt;&#39;腿特别长特别细&#39;,   &#39;mei&#39;=&gt;&#39;好白&#39;,   ];list($key,$value) = each($kongjie);echo $key. &#39;-----&#39; .$value .&#39;&lt;br /&gt;&#39;;?&gt;gao-----穿黑衣服的&lt;?php//定义一个变量叫$kongjie(空姐)$kongjie=[   &#39;gao&#39;=&gt;&#39;穿黑衣服的&#39;,   &#39;shou&#39;=&gt;&#39;退特别长特别细&#39;,   &#39;mei&#39;=&gt;&#39;好白&#39;,   ];while(list($key,$value) = each($kongjie)){   echo $key. &#39;-----&#39; .$value .&#39;&lt;br /&gt;&#39;;}?&gt;gao-----穿黑衣服的shou-----退特别长特别细mei-----好白</code></pre><h2 id="PHP中的替代语法"><a href="#PHP中的替代语法" class="headerlink" title="PHP中的替代语法"></a>PHP中的替代语法</h2><p>PHP中具体有哪些替代语法呢？<br>PHP应该在HTML中制作数据输出，输出通常伴有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的替代语法：全部都是对应的一个模式：<br>左大括号{使用冒号替代:<br>有大括号}使用end+对应的起始标记替代</p><pre><code class="php">if,switch,for,while,foreach都可以进行替代</code></pre><h2 id="数组相关函数"><a href="#数组相关函数" class="headerlink" title="数组相关函数"></a>数组相关函数</h2><h3 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h3><ol><li>sort(): 顺序排序(下标重排)</li><li>rsort(): 逆序排序</li><li>asort(): 顺序排序（下表保留）</li><li>arsort(): 逆序排序</li><li>ksort(): 顺序排序，按照键名（下标）</li><li>kesort(): 逆序排序</li></ol><h3 id="指针排序"><a href="#指针排序" class="headerlink" title="指针排序"></a>指针排序</h3><ol><li>reset(): 重置指针，将数组指针回到首位</li><li>end(): 重置指针，将数组指针指到末尾</li><li>next(): 指针下移，取得下一个元素的值，可能会移出数组</li><li>prev(): 指针上移，取得上一个元素的值，可能会移出数组</li><li>current(): 获得当前指针对应的元素值</li><li>key(): 或崎岖当前指针对应的下标值</li></ol><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol><li>count(): 统计数组中元素的数量</li><li>array_count: 往数组中加入一个元素(数组后面)</li><li>array_pop(): 从数组中取出一个元素(数组后面)</li><li>array_shift(): 从数组中取出一个元素(数组)</li><li>array_unshift(): 从数组中加入一个元素(数组前面)</li><li>array_reverse(): 数组翻转</li><li>in_array(): 判断一个元素在数组中是否存在</li><li>array_keys(): 获取一个数组的所有下标，返回一个索引数组</li><li>array_values(): 获取一个数组的所有值，返回一个索引数组</li></ol>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ResultSet</title>
    <link href="undefined2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResultSet/"/>
    <url>2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResultSet/</url>
    
    <content type="html"><![CDATA[<p>继承Wrapper接口和AutoCloseable接口</p><p>Wrapper是包装类，对原生的int、float。。。进行封装<br>AutoCloseable是自动关闭资源</p><p>ResultSet虽然继承了AutoCloseable可以自动关闭连接释放资源，但是还是要手动关闭，因为官方文档中说：<br>通常，立即释放此Statement对象的数据库和JDBC资源，而不是等待它自动关闭时发生。 最好在资源使用完毕后立即释放资源，以避免占用数据库资源。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ResourceBundle</title>
    <link href="undefined2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResourceBundle/"/>
    <url>2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResourceBundle/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个类主要用来解决国际化和本地化问题。国际化和本地化可不是两个概念，两者都是一起出现的。可以说，国际化的目的就是为了实现本地化。比如对于“取消”，中文中我们使用“取消”来表示，而英文中我们使用“cancel”。若我们的程序是面向国际的（这也是软件发展的一个趋势），那么使用的人群必然是多语言环境的，实现国际化就非常有必要。而ResourceBundle可以帮助我们轻松完成这个任务：当程序需要一个特定于语言环境的资源时（如 String），程序可以从适合当前用户语言环境的资源包（大多数情况下也就是.properties文件）中加载它。这样可以编写很大程度上独立于用户语言环境的程序代码，它将资源包中大部分（即便不是全部）特定于语言环境的信息隔离开来。</p></blockquote><p>这使编写的程序可以：<br>    轻松地本地化或翻译成不同的语言<br>    一次处理多个语言环境<br>    以后可以轻松进行修改，以便支持更多的语言环境</p><p>说的简单点，这个类的作用就是读取资源属性文件（properties），然后根据.properties文件的名称信息（本地化信息），匹配当前系统的国别语言信息（也可以程序指定），然后获取相应的properties文件的内容。</p><p>使用这个类，properties需要遵循一定的命名规范，一般的命名规范是： 自定义名语言代码国别代码.properties，如果是默认的，直接写为：自定义名.properties。</p><p>比如：</p><p>myres_en_US.properties<br>myres_zh_CN.properties</p><p>myres.properties</p><p>当在中文操作系统下，如果myres_zh_CN.properties、myres.properties两个文件都存在，则优先会使用myres_zh_CN.properties，当myres_zh_CN.properties不存在时候，会使用默认的myres.properties。</p><p>没有提供语言和地区的资源文件是系统默认的资源文件。</p><p>资源文件都必须是ISO-8859-1编码，因此，对于所有非西方语系的处理，都必须先将之转换为Java Unicode Escape格式。转换方法是通过JDK自带的工具native2ascii.</p><p>狼人杀项目中的例子</p><img src="/2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResourceBundle/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="undefined" class="" title="配置文件"><img src="/2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResourceBundle/%E4%B8%AD%E6%96%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="undefined" class="" title="中文"><img src="/2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/ResourceBundle/%E6%97%A5%E6%96%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" srcset="undefined" class="" title="日文">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PreparedStatement和Statement</title>
    <link href="undefined2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/PreparedStatement%E5%92%8CStatement/"/>
    <url>2020/06/03/%E5%90%8E%E7%AB%AF/Java/%E5%B7%A5%E5%85%B7%E7%B1%BB/PreparedStatement%E5%92%8CStatement/</url>
    
    <content type="html"><![CDATA[<p>网上有很多文章讨论PrepardStatement与Statement的区别，不过要完完全全的作出比较难度很大，因为每个数据库对底层的实现及应用场合不一样，Oracle对PrepardStatement的支持最好，Mysql对PrepardStatement支持最差。Statement执行单个sql语句速度较快而PrepardStatement执行批处理的效率较高。</p><p>以Oracle为例</p><ol><li><p>Statement为每一条Sql语句生成执行计划， 如果要执行两条sql语句<br> select colume from table where colume=1;<br> select colume from table where colume=2;<br> 会生成两个执行计划，一千个查询就生成一千个执行计划。而生成计划是非常消耗资源的</p></li><li><p>PreparedStatement用于使用绑定变量重用执行计划<br> select * from xxx.sometable t where t.id=?;<br> 通过set方法给sql语句按占位符”?”先后顺序赋值，只需要生成一个执行计划，可以重复使用。</p></li></ol><p>当处理批量SQL语句时，这个时候就可以体现PrepareStatement的优势，由于采用Cache机制，则预先编译的语句，就会放在Cache中，下次执行相同SQL语句时，则可以直接从Cache中取出来,效率要比statement高好几倍</p><p>PrepardStatement的优点<br>&lt;1&gt;、用PrepardStatement写成的sql语句，容易阅读，维护方便。<br>&lt;2&gt;、批处理效率高，执行速度快。<br>&lt;3&gt;、安全，可以防止sql注入攻击。</p><p>缺点:当执行批处理时，你无法得知这个批处理总共影响了多少行。</p><pre><code class="java">/*** PrepareStatement 测试插入数据库*//*** 如果使用Statement，那么就必须在SQL语句中，实际地去嵌入值，比如之前的insert语句** 但是这种方式有一个弊端，第一，是容易发生SQL注入，SQL注入，简单来说，就是，你的网页的用户* 在使用，比如论坛的留言板，电商网站的评论页面，提交内容的时候，可以使用&#39;1 or 1&#39;，诸如此类的* 非法的字符，然后你的后台，如果在插入评论数据到表中的时候，如果使用Statement，就会原封不动的* 将用户填写的内容拼接在SQL中，此时可能会发生对数据库的意外的损坏，甚至数据泄露，这种情况就叫做* SQL注入** 第二种弊端，就是性能的低下，比如insert into test_user(name,age) values(&#39;张三&#39;,25)* insert into test_user(name,age) values(&#39;李四&#39;,26)* 其实两条SQL语句的结构大同小异，但是如果使用这种方式，在MySQL中执行SQL语句的时候，却需要对* 每一条SQL语句都实现编译，编译的耗时在整个SQL语句的执行耗时中占据了大部分的比例* 所以，Statement会导致执行大量类似SQL语句的时候的，性能低下** 如果使用PreparedStatement，那么就可以解决上述的两个问题* 1、SQL注入，使用PreparedStatement时，是可以在SQL语句中，对值所在的位置使用?这种占位符的* 使用占位符之后，实际的值，可以通过另外一份放在数组中的参数来代表。此时PreparedStatement会对* 值做特殊的处理，往往特殊处理后，就会导致不法分子的恶意注入的SQL代码失效* 2、提升性能，使用PreparedStatement之后，其实结构类似的SQL语句，都变成一样的了，因为值的地方* 都会变成?，那么一条SQL语句，在MySQL中只会编译一次，后面的SQL语句过来，就直接拿编译后的执行计划* 加上不同的参数直接执行，可以大大提升性能*/private static void preparedStatement() {// 总结一下JDBC的最基本的使用过程// 1、加载驱动类：Class.forName()// 2、获取数据库连接：DriverManager.getConnection()// 3、创建SQL语句执行句柄：Connection.createStatement()// 4、执行SQL语句：Statement.executeUpdate()// 5、释放数据库连接资源：finally，Connection.close()// 定义数据库连接对象// 引用JDBC相关的所有接口或者是抽象类的时候，必须是引用java.sql包下的// java.sql包下的，才代表了java提供的JDBC接口，只是一套规范// 至于具体的实现，则由数据库驱动来提供，切记不要引用诸如com.mysql.jdbc包的类Connection conn=null;//定义SQL语句执行句柄:PrepareStatement对象//PreparedStatement对象,其实就是底层会基于Connection数据库连接//可以让我们方便的针对数据库中的表,执行增删改查的SQL语句//比如和insert update delete和select语句PreparedStatement ps=null;try {    // 第一步，加载数据库的驱动，我们都是面向java.sql包下的接口在编程，所以    // 要想让JDBC代码能够真正操作数据库，那么就必须第一步先加载进来你要操作的数据库的驱动类    // 使用Class.forName()方式来加载数据库的驱动类    // Class.forName()是Java提供的一种基于反射的方式，直接根据类的全限定名（包+类）    // 从类所在的磁盘文件（.class文件）中加载类对应的内容，并创建对应的Class对象    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    // 获取数据库的连接    // 使用DriverManager.getConnection()方法获取针对数据库的连接    // 需要给方法传入三个参数，包括url、user、password    // 其中url就是有特定格式的数据库连接串，包括“主协议:子协议://主机名:端口号//数据库”    conn = DriverManager.getConnection(            &quot;jdbc:mysql://localhost:3306/spark_project?characterEncoding=utf8&quot;,            &quot;root&quot;,            &quot;root&quot;    );    // 基于数据库连接Connection对象，创建SQL语句执行句柄，Statement对象    // prepareStatement对象，就是用来基于底层的Connection代表的数据库连接    // 允许我们通过java程序，通过prepareStatement对象，向MySQL数据库发送SQL语句    // 从而实现通过发送的SQL语句来执行增删改查等逻辑    // 第一个，SQL语句中，值所在的地方，都用问好代表    String sql = &quot;insert into user(name,age) values(?,?)&quot;;    ps = conn.prepareStatement(sql);    // 第二个，必须调用PreparedStatement的setX()系列方法，对指定的占位符设置实际的值    ps.setString(1,&quot;李四&quot;);    ps.setInt(2,26);    // Statement.executeUpdate()方法，就可以用来执行insert、update、delete语句    // 返回类型是个int值，也就是SQL语句影响的行数    // 第三个，执行SQL语句时，直接使用executeUpdate()即可，不用传入任何参数    int rtn = ps.executeUpdate();    System.out.println(&quot;SQL语句影响了【&quot; + rtn + &quot;】行。&quot;);}catch (Exception e){    e.printStackTrace();}finally {    try {        // 最后一定要记得在finally代码块中，尽快在执行完SQL语句之后，就释放数据库连接        if (ps != null){            ps.close();        }        if (conn !=null){            conn.close();        }    }catch (Exception e){        e.printStackTrace();    }}}</code></pre><p>jdbc(java database connectivity，java数据库连接)的api中的主要的四个类之一的java.sql.statement要求开发者付出大量的时间和精力。在使用statement获取jdbc访问时所具有的一个共通的问题是输入适当格式的日期和时间戳：2002-02-05 20:56 或者 02/05/02 8:56 pm。<br>通过使用java.sql.preparedstatement，这个问题可以自动解决。一个preparedstatement是从java.sql.connection对象和所提供的sql字符串得到的，sql字符串中包含问号（?），这些问号标明变量的位置，然后提供变量的值，最后执行语句，例如：</p><pre><code class="java">stringsql = &quot;select * from people p where p.id = ? and p.name = ?&quot;;preparedstatement ps = connection.preparestatement(sql);ps.setint(1,id);ps.setstring(2,name);resultset rs = ps.executequery();使用preparedstatement的另一个优点是字符串不是动态创建的。下面是一个动态创建字符串的例子：stringsql = &quot;select * from people p where p.i = &quot;+id;这允许jvm（javavirtual machine，java虚拟机）和驱动/数据库缓存语句和字符串并提高性能。preparedstatement也提供数据库无关性。当显示声明的sql越少，那么潜在的sql语句的数据库依赖性就越小。由于preparedstatement具备很多优点，开发者可能通常都使用它，只有在完全是因为性能原因或者是在一行sql语句中没有变量的时候才使用通常的statement。一个完整的preparedstatement的例子：package jstarproject;import java.sql.*;public class mypreparedstatement {    private final string db_driver=&quot;com.microsoft.jdbc.sqlserver.sqlserverdriver&quot;;    private final string url = &quot;jdbc:microsoft:sqlserver://127.0.0.1:1433;databasename=pubs&quot;;    public mypreparedstatement(){}    public void query() throws sqlexception{        connection conn = this.getconnection();        string strsql = &quot;select emp_id from employee where emp_id = ?&quot;;        preparedstatement pstmt = conn.preparestatement(strsql);        pstmt.setstring(1,&quot;pma42628m&quot;);        resultset rs = pstmt.executequery();        while(rs.next()){            string fname = rs.getstring(&quot;emp_id&quot;);            system.out.println(&quot;the fname is &quot; + fname);        }        rs.close();        pstmt.close();        conn.close();    }    private connection getconnection() throws sqlexception{        // class.        connection conn = null;        try {        class.forname(db_driver);        conn = drivermanager.getconnection(url,&quot;sa&quot;,&quot;sa&quot;);        }        catch (classnotfoundexception ex) {}        return conn;    }        //main    public static void main(string[] args) throws sqlexception {        mypreparedstatement jdbctest1 = new mypreparedstatement();        jdbctest1.query();    }}</code></pre><p>为什么要始终使用PreparedStatement代替Statement?为什么要始终使用PreparedStatement代替Statement?</p><p>在JDBC应用中,如果你已经是稍有水平开发者,你就应该始终以PreparedStatement代替Statement.也就是说,在任何时候都不要使用Statement.<br>基于以下的原因:<br>一.代码的可读性和可维护性.<br>虽然用PreparedStatement来代替Statement会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用Statement的代码高很多档次:</p><pre><code class="java">stmt.executeUpdate(&quot;insert into tb_name (col1,col2,col2,col4) values (&#39;&quot;+var1+&quot;&#39;,&#39;&quot;+var2+&quot;&#39;,&quot;+var3+&quot;,&#39;&quot;+var4+&quot;&#39;)&quot;);perstmt = con.prepareStatement(&quot;insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)&quot;);perstmt.setString(1,var1);perstmt.setString(2,var2);perstmt.setString(3,var3);perstmt.setString(4,var4);perstmt.executeUpdate();</code></pre><p>不用我多说,对于第一种方法.别说其他人去读你的代码,就是你自己过一段时间再去读,都会觉得伤心.</p><p>二.PreparedStatement尽最大可能提高性能.</p><p>每一种数据库都会尽最大努力对预编译语句提供最大的性能优化.因为预编译语句有可能被重复调用.所以语句在被DB的编译器编译后的执行代码被缓存下来,那么下次调用时只要是相同的预编译语句就不需要编译,只要将参数直接传入编译过的语句执行代码中(相当于一个涵数)就会得到执行.这并不是说只有一个Connection中多次执行的预编译语句被缓存,而是对于整个DB中,只要预编译的语句语法和缓存中匹配.那么在任何时候就可以不需要再次编译而可以直接执行.而statement的语句中,即使是相同一操作,而由于每次操作的数据不同所以使整个语句相匹配的机会极小,几乎不太可能匹配.比如:<br>insert into tb_name (col1,col2) values (‘11’,’22’);<br>insert into tb_name (col1,col2) values (‘11’,’23’);<br>即使是相同操作但因为数据内容不一样,所以整个个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.</p><p>当然并不是所以预编译语句都一定会被缓存,数据库本身会用一种策略,比如使用频度等因素来决定什么时候不再缓存已有的预编译结果.以保存有更多的空间存储新的预编译语句.</p><p>三.最重要的一点是极大地提高了安全性.</p><p>即使到目前为止,仍有一些人连基本的恶义SQL语法都不知道.<br>String sql = “select * from tb_name where name= ‘“+varname+”‘ and passwd=’”+varpasswd+”‘“;<br>如果我们把[‘ or ‘1’ = ‘1]作为varpasswd传入进来.用户名随意,看看会成为什么?</p><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;<br>因为’1’=’1’肯定成立,所以可以任何通过验证.更有甚者:<br>把[‘;drop table tb_name;]作为varpasswd传入进来,则:<br>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;有些数据库是不会让你成功的,但也有很多数据库就可以使这些语句得到执行.</p><p>而如果你使用预编译语句.你传入的任何内容就不会和原来的语句发生任何匹配的关系.只要全使用预编译语句,你就用不着对传入的数据做任何过虑.而如果使用普通的statement,有可能要对drop,;等做费尽心机的判断和过虑.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/堆栈练习题/阿里面试题</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[let a = {    n:1}let b = aa.x = a = {    n:2}console.log(a.x)console.log(b)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/堆栈练习题/数据类型检测</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[/*基于typeof检测出来的结果1. 首先是一个字符串2. 字符串中包含对应的类型局限性1. typeof null => "object" 但是null并不是对象2. 基于typeof无法细分出当前值是普通对象还是数组对象等，应为只要是对象数据类型，返回的结果都是"object"*/console.log(typeof 1)let a = NaNconsole.log(typeof a)console.log(1)console.log(typeof typeof typeof [])]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/堆栈练习题/index</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/index/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>Document</title>    <script src="./数据类型检测.js"/><meta name="generator" content="Hexo 4.2.1"></head><body>    </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/函数/index</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/index/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title><meta name="generator" content="Hexo 4.2.1"></head><body>    <script src="./1.js"></script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/函数/1</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/1/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/1/</url>
    
    <content type="html"><![CDATA[// 求两个数的和,算完和后乘以10，然除以2// sum使函数名，代表这个函数本身// sum（）是让函数执行，代表的使函数执行返回的结果function sum(a,b) {    console.log('形参变量',a,b)    if(a === undefined){        a = 0    }    if (typeof b === 'undefined') {         b = 0    }    console.log('结果',(a + b)*5)    return (a + b)*5}// ========= 形参的细节// 创建函数的时候我们设置了形参变量，但如果执行的时候并没有给传递对应的实参值，那么形参变量默认的值是：undefinedsum()sum(10)sum(10,20)sum(10,20,30)// =========== 函数中的返回值// 函数执行的时候，函数体内部创建的变量我们是无法获取和操作的（闭包），如果想要获取内部信息，我们需要基于return返回值机制，把信息返回才可以// return的一定是值// 没有写return，函数默认返回值是undefinedconsole.dir(console.log)function sum1(n,m){    if(n === undefined || m === undefined){        // 函数体中遇到return，后面代码则不再执行了        return    }    let result = n + m}// ========== 匿名函数// 匿名函数之函数表达式：把一个匿名函数本身作为值赋值给其他东西，这种函数一般不是手动触发执行，而是靠其他程序驱动触发执行// （例如：触发某个事件的时候把它执行等）document.body.onclick = function () {}setTimeout(function(){},1000) // =》设置定时器，1000MS后执行匿名函数// 匿名函数之自执行函数：创建完一个匿名函数，紧接着就把当前函数加小括号执行(function(n){    // n => 100})(100);// 创建完成后立刻执行]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/全局作用域/例子</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/%E4%BE%8B%E5%AD%90/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/%E4%BE%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title><meta name="generator" content="Hexo 4.2.1"></head><body>    <!-- <script type="text/javascript">        fun()        // 函数声明，会被提前创建        function fun() {            console.log("我是一个fun函数")        }        // 函数表达式，不会被提前创建        // fun2() undefined        var fun2 = function  (){                    }        fun2()    </script> -->    <script>        var obj = {            name: '孙悟空',            age:18,            gender:'男',            sayName:function(){                alert(this.name)            }        }        /*        * 使用工程方法创建对象        */        function createPerson(){            // 创建一个新的对象            var obj = new Object()            // 向对象中添加属性            obj.name = "孙悟空"            obj.age= 18            obj.gender = '男'            obj.sayName = function(){                console.dir(obj)            }            // 将新的对象返回            return obj        }    </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/鼠标点击切换显示详情</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>鼠标滑过显示详情</title>    <!-- import css -->    <style>        * {            margin: 0;            padding: 0;        }        .box {            /* CSS3新盒子模型属性：控制WIDTH/HEIGHT是盒子最终的宽高*/            box-sizing: border-box;            margin: 20px auto;            width: 200px;            height: 40px;            line-height: 40px;            text-align: center;            border: 1px solid lightcoral;            position: relative;        }        .box .detail{            display: none;            width: 500px;            height: 100px;            line-height: 100px;            text-align: center;            border: 1px solid lightcoral;            box-sizing: border-box;            position: absolute;            right: -1px;            top: 38px;            /* 父div的级别调高子的也会受影响，所以应该将子的div级别调低*/            z-index: -1;            cursor: pointer;        }    </style><meta name="generator" content="Hexo 4.2.1"></head><body>    <!-- 基于CSS实现，我们需要让详情区域是按钮的子元素 -->    <div class="box" id = "box">        <span>购物车</span>        <div class="detail" id="detail" style="display: none;">            购物车相关信息        </div>    </div>    <!--         传统基于操作DOM的方式实现业务需求        1. 想操作谁就先获取谁        2. 给某元素绑定某事件        3. 在事件触发的时候修改元素的样式等     -->     <!-- import js -->     <script>         // document.getElementById([ID])：在整个文档中，通过元素的ID获取到当前这个元素对象         let box = document.getElementById('box')         let detail = document.getElementById('detail')         // 元素对象.onxxx = function(){}: 事件绑定，xxx事件类型（click/mouseover/mousedown/keydown...）         box.onclick = function () {             // 元素对象.style.xxx = xxx 修改元素的某一个样式值(操作的是元素行内样式，             // 所以如果我们没有把样式写在行内上，在JS中基于.style.xxx的方式是无法获取到样式的)             // 1. 首先获取DETAIL原有的样式（显示还是隐藏）：元素.style.xxx就是获取某一个样式             // 前提：需要在元素行内设置这个样式才能获取到             if (detail.style.display === 'none') {                // 当前是隐藏的，我们让其显示                detail.style.display = 'block'                box.style.borderBottomColor = '#FFF'             }else {                detail.style.display = 'none'                box.style.borderBottomColor = 'lightcoral'             }         }     </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/鼠标滑过显示详情</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>鼠标滑过显示详情</title>    <!-- import css -->    <style>        * {            margin: 0;            padding: 0;        }        .box {            /* CSS3新盒子模型属性：控制WIDTH/HEIGHT是盒子最终的宽高*/            box-sizing: border-box;            margin: 20px auto;            width: 200px;            height: 40px;            line-height: 40px;            text-align: center;            border: 1px solid lightcoral;            position: relative;        }        .box .detail{            display: none;            width: 500px;            height: 100px;            line-height: 100px;            text-align: center;            border: 1px solid lightcoral;            box-sizing: border-box;            position: absolute;            right: -1px;            top: 38px;            /* 父div的级别调高子的也会受影响，所以应该将子的div级别调低*/            z-index: -1;            cursor: pointer;        }    </style><meta name="generator" content="Hexo 4.2.1"></head><body>    <!-- 基于CSS实现，我们需要让详情区域是按钮的子元素 -->    <div class="box" id = "box">        <span>购物车</span>        <div class="detail" id="detail">            购物车相关信息        </div>    </div>    <!--         传统基于操作DOM的方式实现业务需求        1. 想操作谁就先获取谁        2. 给某元素绑定某事件        3. 在事件触发的时候修改元素的样式等     -->     <!-- import js -->     <script>         // document.getElementById([ID])：在整个文档中，通过元素的ID获取到当前这个元素对象         let box = document.getElementById('box')         let detail = document.getElementById('detail')         // 元素对象.onxxx = function(){}: 事件绑定，xxx事件类型（click/mouseover/mousedown/keydown...）         box.onclick = function () {             // 元素对象.style.xxx = xxx 修改元素的某一个样式值            detail.style.display = 'block'            box.style.borderBottomColor = '#FFF'         }     </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/隔行变色</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%9A%94%E8%A1%8C%E5%8F%98%E8%89%B2/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%9A%94%E8%A1%8C%E5%8F%98%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>隔行变色</title>    <!-- IMPORT CSS -->    <style>    * {        margin: 0;        padding: 0;    }    ul {        list-style: none;    }    #newsBox {        box-sizing: border-box;        width: 300px;        margin: 20px auto;        padding: 20px;        border: 2px solid lightblue;    }    #newsBox li {        line-height: 35px;        border-bottom: 1px dashed lightcoral;    }    #newsBox li:nth-last-child(1) {        /* 获取LI中的倒数第一个 */        border-bottom: none;    }    /* 基于CSS实现 */    /* #newsBox li:nth-child(even) {        background: lightgray;    }    #newsBox li:hover {        background: lightgreen;    } */    </style><meta name="generator" content="Hexo 4.2.1"></head><body>    <ul id="newsBox">        <li>我是地1个LI</li>        <li>我是地2个LI</li>        <li>我是地3个LI</li>        <li>我是地4个LI</li>        <li>我是地5个LI</li>    </ul>    <!-- IMPORT JS -->    <script>        // [content].getElementsByTagName([tagname]): 在执行的context范围之内，通过标签名获取一组元素（元素集合）        // 集合和数组很相似，也是以数字索引作为属性名，由length属性存储长度，但是不是数组，属于“类数组”        let newsBox = document.getElementById('newsBox')        let newsList = newsBox.getElementsByTagName('li')        console.dir(newsList)        // 1.循环所有获取的LI，判断每一个LI的奇偶行，让其由不同的背景颜色        for (let i = 0; i < newsList.length; i++) {            //一轮 i=0 操作第一个LI newsList[0]            //二轮 i=1 操作第一个LI newsList[1]            // newsList[i] 当前本轮循环我们要操作的这个LI            let curLi = newsList[i]            // i=0(偶数) 第一个LI 奇数行            // i=1(奇书) 第二行LI 偶数行            //=》当前这一行的索引如果是偶数，那么它是奇数行，否则是偶数行            // 偶数判断的标准：能被2整除（除以2的余数为0） n/2除法 n%2            if (i % 2 === 0) {                // 索引是偶数，代表奇数行                curLi.style.background = '#FFF'            } else {                // 索引是奇数，代表偶数行                curLi.style.background = '#DDD'            }            // 2.循环的时候给每一个LI都绑定mouseover/mouseout事件            let color            curLi.onmouseover = function () {                // this : 当前操作的这个LI                color = this.style.background                this.style.background = 'lightblue'            }            curLi.onmouseout = function () {                this.style.background = color            }        }    </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/判断数字案例</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E6%A1%88%E4%BE%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>案例练习</title>    <style>        #numInp,#submit{            box-sizing: border-box;            padding: 0 15px;            height: 35px;            border: 2px solid red;        }        #submit{            cursor: pointer;        }    </style><meta name="generator" content="Hexo 4.2.1"></head><body>    <input type="text" id="numInp">    <button id="submit">点击计算</button>    <script>        let numInp = document.getElementById('numInp')        let submit = document.getElementById('submit')        submit.onclick = function () {            //1.获取文本框种的信息            let n = numInp.value            // console.log(typeod n); 文本框种的信息是字符串格式的"string"            n = Number(n)            //2. 验证是否为有效数字            if(!isNaN(n)){                // 有效数字                if(n>0){                    console.log('当前数字为正数')                }else if(n === 0){                    console.log('当前数字为0')                }else {                    console.log('当前数字为负数')                }            }else {                console.log('当前输入的信息为非有效数字！')            }        }    </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/点击变色</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E7%82%B9%E5%87%BB%E5%8F%98%E8%89%B2/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E7%82%B9%E5%87%BB%E5%8F%98%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Document</title>    <style>        * {            margin: 0px;            padding: 0px;        }        html,body {            width: 100%;/* 可以省略 */            height: 100%;            overflow: hidden;        }        button {            margin: 20px;            padding: 40px;            line-height: 40px;        }    </style><meta name="generator" content="Hexo 4.2.1"></head><body style="background-color: white;">    <button id="changeBtn">点击变颜色白->红->绿->蓝->白...</button>    <!-- import js -->    <script>        let body = document.body        let changeBtn = document.getElementById('changeBtn')        let i = 0        changeBtn.onclick = function () {            // changeColor()            i++            changeColor2(i)        }        function changeColor () {            // 获取当前的而背景颜色，只能获取内联样式的颜色颜色再样式中使用16进制方式，JS中获取到的是RGB的值            let bg = body.style.backgroundColor            switch (bg) {                case 'white':                     body.style.backgroundColor = 'red'                    break                case 'red':                     body.style.backgroundColor = 'green'                    break                 case 'green':                     body.style.backgroundColor = 'blue'                    break                default:                    body.style.backgroundColor = 'white'            }        }        function changeColor2 (i) {            let ary = ['white','pink','lightblue','lightgreen','black']            i = i % ary.length            body.style.backgroundColor = ary[i]        }    </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/选项卡案例</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%80%89%E9%A1%B9%E5%8D%A1%E6%A1%88%E4%BE%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%80%89%E9%A1%B9%E5%8D%A1%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>选项卡</title>    <!-- IMPORT CSS -->    <link rel="stylesheet" href="css/tab.css"><meta name="generator" content="Hexo 4.2.1"></head><body>    <div id="tabBox">        <ul id="navBox">            <li class="active" >编程</li>            <li>读书</li>            <li>运动</li>        </ul>        <div class="active">编程使我快乐</div>        <div>读书使我幸福</div>        <div>运动使我健康</div>    </div>    <!-- IMPORT JS -->    <script>        let tabBox = document.getElementById('tabBox')        var tabList = tabBox.getElementsByTagName('div')        var navBox = document.getElementById('navBox')        var navList = navBox.getElementsByTagName('li')        // 解决办法一：自定义属性解决办法        // 循环三个LI，给每一个LI都绑定点击事件        for (var i = 0; i < navList.length; i++) {            // navList[i] : 当前循环下我们要操作的那个LI（I存储的值是我们需要获取指定元素的索引）            // 在循环给每个LI绑定点击事件的时候，我们给每一个LI（元素对象）设置一个自定义属性clickIndex,属性值存储的是当前LI的索引            navList[i].clickIndex = i            navList[i].onclick = function () {                changeTab(this.clickIndex)            }            /*             * 只有JS代码加载完成才能看到页面，只有看到也米娜用户才能点击             * 加载到循环代码 i=0 i<3 i++             * i=0 navList[0].onclick=function(){...} 绑定事件的时候方法没有执行，点击第一个LI的时候它才执行             * 循环结束后i已经是3了             * 循环结束看到了页面，用户去点击了某一个页卡，接下来开始执行绑定的方法，方法中遇到了一个i，但此时i已经是循环结束后的3了             */        }        // 其他方式        // 闭包解决法        // for (var i = 0; i < navList.length; i++) {        //     navList[i].onclick = (function (i){        //         return function () {        //             changeTab(i)        //         }        //     })(i)        // }        // ES6中的LET解决方案        // for ( let i = 0; i < navList.length; i++ ){        //     navList[i].onclick = function() {        //         changeTab(i)        //     }        // }        // 封装一个函数实现选项卡的切换        // clickIndex:创建函数的时候还不知道点的是谁，所以定义一个入口        // (点击这一项的索引)，执行方法的时候把点击这一项的索引传递进来即可        function changeTab (clickIndex) {            // 1.先让所有的LI和DIV都没有选中的样式            for (var i = 0; i < navList.length; i++) {                navList[i].className = ''                tabList[i].className = ''            }            // 2.点击的是谁就给谁加选中样式类            navList[clickIndex].className = 'active'            tabList[clickIndex].className = 'active'        }    </script></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS样例/css/tab</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/css/tab/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/css/tab/</url>
    
    <content type="html"><![CDATA[* {    margin: 0;    padding: 0;}ul {    list-style: none111;}#tabBox{    box-sizing: border-box;    width: 500px;    margin: 20px auto;   }#navBox {    /* 只要把容器设置为FLEX弹性盒子容器，那么容器中的子元素默认在容器主轴（x轴）水平靠左排列 */    display: flex;    position: relative;    top: 1px;}#navBox li{    box-sizing: border-box;    margin-right: 10px;    padding: 0 10px;    line-height: 35px;    border: 1px solid #999;    list-style: none;    cursor: pointer;}#navBox li.active{    border-bottom-color: #FFF;}#tabBox>div{    display: none;    box-sizing: border-box;    padding: 10px;    height: 150px;    border: 1px solid #999;}#tabBox>div.active{    display: block;}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中的逻辑语句/JS中的逻辑语句</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[let a = 10;if (a <= 0) {    console.log('哈哈')} else if (a > 0 && a < 10) {    console.log('呵呵')} else {    console.log('吼吼')}if(!a) {    // 条件可以多样性：等于、大于、小于的比较或一个值或者取反等 =>最后都是要计算出TRUE或FALSE}// 三元运算符// 条件？条件成立处理的事情：不成立处理的事情// 1. 如果处理的事情比较多，我们用括号抱起来，每一件事情用逗号分隔// 2. 如果不需要处理事情，可以使用null/undefined占位a >= 10 ? console.log('呵呵') : console.log('吼吼')(a > 0 && a < 20) ? (a++, console.log(a)) : null// switch case: 一个变量再不同值情况下的不同操作// 1. 每一种case情况结束后最好都加上BREAK// 2. default等价于else，以上都不成立干的事情// 3. 不加break，当前条件成立执行完成后，后面条件不论是否成立都要执行，指导遇到break为止// 4. 每一种case情况的比较用的都是==="绝对相等"let b = '10'if(b === 1) {    console.log('aaaaa')}else if(b === 5){    console.log('bbbbb')}else if (b == 10){    console.log('cccccc')}else {    console.log('jjjjjjjj')}switch(b){    case 1 :        console.log('aaaaa')        break    case 5 :        console.log('bbbbb')        break    case 10 :        console.log('ccccc')        break    default :        console.log('jjjjjjjj')}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中的逻辑语句/JS种的for循环</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/JS%E7%A7%8D%E7%9A%84for%E5%BE%AA%E7%8E%AF/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/JS%E7%A7%8D%E7%9A%84for%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[/** * 1. 创建循环初始值 * 2. 设置（验证）循环执行的条件 * 3. 条件成立执行循环体种的内容 * 4. 当前循环结束执行步长累计操作 */// for (var i = 0; i < 5; i++) {//     console.log(i)// }// console.log(i)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/数据类型的区别</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[// let a = 12// let b = a// b = 13// console.log(a)// let n = { name: '张议' }// let m = n// m.name = '周家豪'// console.log(n.name)// let n = [10,20]// let m = n// let x = m// m[0] = 100// x = [30,40]// x[0] = 200// m = x// m[1] = 300// n[2] = 400// // n,m,x分别时多少// console.log('n:',n)// console.log('m:',m)// console.log('x:',x)// 答案 n：【100，20，400】m：【200，300】x：【200，300】let a = {    n:1}let b = aa.x = a = {    n:2}console.log(a.x)console.log(b)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/string字符串数据类型</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[// let a = 12// console.log(a.toString()) // =>'12'// console.log((NaN).toString())//null和undefined是禁止直接toString的//(null).toString // =>报错// 但是和undefined一样转换为字符串的结果就是'null'/'undefined'// console.log([].toString())// console.log([12].toString())// console.log([12,23].toString())// console.log(/^$/.toString())//普通对象.toString()的结果是"[object Object]" => ?//Object.prototype.toString方法不是转换为字符串的，而是用来检测数据类型的console.log({name:'xxx',age:12}.toString())//===========字符串拼接//四则运算法则中，除加法之外，其余都是数学计算，只有假发可能存在字符串拼接（一旦遇到字符串，则不是数学运算，而是字符串拼接）console.log('10'+10)//=》'1010'//用Number来转换（默认）console.log('10'-10)console.log('10px'-10)//=》NaN-10=NaNlet a = 10 + null + true + [] + true + undefined + '珠峰' + null + 32 + false + {name:"sss"}/*10 + null -> 10 + 0 = 1010 + true -> 10 + 1 = 1111 + [] -> 11 + '' = '11' 空数组变为数字，先要经历变为空字符串，遇到字符串直接变为字符串拼接*/console.log(a)// 11trueundefined珠峰null32false[object Object]]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/number数字类型</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/number%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/number%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[//console.log([val]):在控制台输出内容//==:进行比较// console.log(1==2)// console.log('AA'==NaN)// console.log(10==NaN)// console.log(NaN==NaN)// console.log('---------------')//isNaN([val])// console.log(isNaN(10))//false// console.log(isNaN('AAA'))//true/* * Number('AAA') => NaN * isNaN(NaN) =>true */// console.log(isNaN('10'))//false/* * Number('10') => 10 * isNaN(10) =>FALSE */// console.log(isNaN(NaN))//ture//把字符串转换为数字，只要字符串中包含任意一个非有效数字字符（第一个点除外）结果都是NaN，空字符串会变为数字零// console.log(Number('12.5'))//12.5// console.log(Number('12.5px'))//NaN// console.log(Number('12.5.4'))//NaN// console.log(Number(''))//0// console.log(Number(true))//1// console.log(Number(false))//0// console.log(isNaN(false))//false// console.log(Number(null))//0// console.log(Number(undefined))//NaN// //把引用数字类型转换为数字，是先把它基于toString方法转换为字符串，然后再转换为数字// console.log(Number({name:'10'}))//NaN// console.log(Number({}))//NaN// //{}/{xxx:'xxx'}.toString() => "[object Object]" => NaN// console.log(Number([]))//0// //[].toString => '' => 0// console.log(Number([12]))//12// //[12].toString => '12' => 12// console.log(Number([12,23]))//NaN//[12,23].toString => '12,23' => NaNlet str = '12.5px'console.log(Number(str))//NaNconsole.log(parseInt(str))//12console.log(parseFloat(str))//12.5console.log(parseFloat('width:12.5px'))//NaNconsole.log('10'==10)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/object对象数据类型</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/object%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/object%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[// let person = {//     "name" : '易烊千玺',//     'age' : 40,//     height : '185cm',//     weight : '70kg',//     1 : 100// }// // 获取属性名对应的属性值// // 对象.属性名// // 对象[属性名] 属性名是数字或者字符串格式的// console.log(person.name)// console.log(person['age'])// // console.log(person[age]) 会报错// // 如果当前属性名不存在，默认的属性值是undefined// console.log(person.sex)//undefined// console.log(person['1'])// console.log(person[1])// // 如果属性名是数字，则不能使用点的方式获取属性值// // console.log(person.1) 报错SyntaxError：语法错误// //设置属性名属性值// person.sex = '男'// person.GF = '袁娜'// console.log(person.sex)// console.log(person.GF)// // 属性名不能重复，如果属性名已经存在，不属于新增属于修改属性值// person.name = '李易峰'// console.log(person.name)// // 删除属性// // 真删除：把属性彻底干掉// // 假删除：属性还在，值为空// person.weight = null// console.log(person)// delete person[1]// console.log(person)/** * 数组是特殊的对象 *  1. 我们中括号中设置的是属性值，它的属性名是默认生成的数字，从零开始递增，而且这个数字代表每个项的位置， * 我们把其称为“索引”=》从零开始，连续递增，代表每一项位置的数字属性名 * 2. 天生默认一个属性名length，存储数组的长度 *  */let ary = [12, '哈哈', true, 13]console.log(ary)console.log(ary.length)console.log(ary['length'])//第一项索引0 最后以相ary.length - 1console.log(ary[0])console.log(ary[ary.length - 1])//向数组末尾追加内容ary[ary.length] = 100console.log(ary)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/Boolean布尔数据类型</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Boolean%E5%B8%83%E5%B0%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Boolean%E5%B8%83%E5%B0%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[console.log(Boolean(0))console.log(Boolean(''))console.log(Boolean(' '))console.log(Boolean(null))console.log(Boolean(undefined))console.log(Boolean([]))console.log(Boolean([12]))// !:取反（先转为布尔，然后取反）// !!:取反（取反再取反，只相当于转换为布尔）《=》Booleanconsole.log(![12])//falseconsole.log(!![12])//true//如果条件只是一个值，不是==/===/!=/>=/<=等这些比较,是要把这个值先转换为布尔类型，然后验证真假if(1){    console.log('哈哈')}if('3px' + 3){    console.log('哈哈')}if('3px' - 3){//NaN-3=>NaN    console.log('哈哈')}]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/JS/JS中常用的数据类型/index</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>number数字类型</title><meta name="generator" content="Hexo 4.2.1"></head><body>    <!-- <script src="./number数字类型.js"></script> -->    <!-- <script src="./string字符串数据类型.js"></script> -->    <!-- <script src="./Boolean布尔数据类型.js"></script> -->    <!-- <script src="./object对象数据类型.js"></script> -->    <script src="./数据类型的区别.js"></script>    </body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端/CSS/CSS样例/鼠标滑过显示详情</title>
    <link href="undefined2020/06/02/%E5%89%8D%E7%AB%AF/CSS/CSS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/"/>
    <url>2020/06/02/%E5%89%8D%E7%AB%AF/CSS/CSS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>鼠标滑过显示详情</title>    <!-- import css -->    <style>        * {            margin: 0;            padding: 0;        }        .box {            /* CSS3新盒子模型属性：控制WIDTH/HEIGHT是盒子最终的宽高*/            box-sizing: border-box;            margin: 20px auto;            width: 200px;            height: 40px;            line-height: 40px;            text-align: center;            border: 1px solid lightcoral;            position: relative;        }        .box:hover {            border-bottom-color: #ffffff;        }        .box .detail{            display: none;            width: 500px;            height: 100px;            line-height: 100px;            text-align: center;            border: 1px solid lightcoral;            box-sizing: border-box;            position: absolute;            right: -1px;            top: 38px;            /* 父div的级别调高子的也会受影响，所以应该将子的div级别调低*/            z-index: -1;            cursor: pointer;        }        .box:hover .detail{            display: block;        }        /* 如果是点击实现显示没不需要基于JS也可以，可以基于:target实现手风琴效果*/    </style><meta name="generator" content="Hexo 4.2.1"></head><body>    <!-- 基于CSS实现，我们需要让详情区域是按钮的子元素 -->    <div class="box">        <span>购物车</span>        <div class="detail">            购物车相关信息        </div>    </div></body></html>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php语法基础</title>
    <link href="undefined2020/05/28/%E5%90%8E%E7%AB%AF/php/php%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>2020/05/28/%E5%90%8E%E7%AB%AF/php/php%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="PHP语法"><a href="#PHP语法" class="headerlink" title="PHP语法"></a>PHP语法</h2><blockquote><p>PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中</p></blockquote><p>ASP标记：&lt;% php代码 %&gt;<br>短标记： <? php代码 ?> ，以上两种基本启用，如果要使用那么需要在配置文件中开启<br>脚本标记: &lt; script script script language=”php”&gt;php代码&lt; / script&gt;<br>标准标记（常用）：&lt;?php php代码 ?&gt;</p><h2 id="PHP注释"><a href="#PHP注释" class="headerlink" title="PHP注释"></a>PHP注释</h2><p>行注释<br>//: 后面的所有内容都是注释<br>#: 与//一样</p><p>块注释<br>/* */</p><h2 id="PHP语句分隔符"><a href="#PHP语句分隔符" class="headerlink" title="PHP语句分隔符"></a>PHP语句分隔符</h2><p>语句分隔符：在PHP照片那个，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号</p><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><ol><li>PHP中标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符”;”</li><li>PHP中起始很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符?&gt;,PHP会自动从开始到最后全部认为是PHP代码，从而解析。</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>PHP是一种动态网站开发的脚本语言，动态语言特点是交互性，会有数据的传递，而PHP作为中间人，需要进行数据的传递，传递的前提就是PHP能自己存储数据（临时存储）</p><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ol><li>PHP中的所有变量都必须使用“$”</li><li>名字由数字、字母、下划线过程，数字不能开头</li></ol><p>删除变量unset(变量名)</p><pre><code class="php">$var = 2;unset($var);</code></pre><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>$_GET: 获取所有表单以get方式提交的数据<br>$_POST: 获取所有表单以post方式提交的数据<br>$_REQUEST: GET和POST提交的都会保存<br>$_GLOBALS: PHP中所有的全局变量<br>$_SERVER:服务器信息<br>$_SESSION: session会话数据<br>$_COOKIE: cookie会话数据<br>$_ENV: 环境信息<br>$_FILES: 用户上传的文件信息</p><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><blockquote><p>如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值，在变量前面多加一个$符号</p></blockquote><pre><code class="php">$a = &#39;b&#39;;$b = 31232;echo $$a;</code></pre><h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><blockquote><p>将变量保存到额值赋值一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p></blockquote><pre><code class="php">$a = &#39;b&#39;;$b = $a;echo $b;</code></pre><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><blockquote><p>将变量保存的值所在的内存地址，传递给另外的一个变量：两个变量指向同一块内存空间（两个变量是同一个值）</p></blockquote><pre><code class="php">$a = &#39;b&#39;;$b = &amp;$a;echo $b;</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote><p>数据类型：data type，在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</p></blockquote><p>在PHP中将数据分为3大类8小类</p><ol><li>简单数据类型：4小类<ol><li>整型：int、integer，系统分配4个字节存储，表示整数类型（有前提）</li><li>浮点型：float、double，系统分配8个字节存储，表示小数或者整数存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串（引号）</li><li>布尔类型：bool、boolean，表示布尔类型，只有两个值：true、false</li></ol></li><li>符合数据类型<ol><li>对象类型：object，存放对象</li><li>数据类型：array，存储多个数据（一次性）</li></ol></li><li>特殊数据类型<ol><li>资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值NULL（不能运算）</li></ol></li></ol><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为：</p><p>1.10进制 <code>$zhengshu = 1000;</code><br>2.8进制  <code>$zhengshu = 033145;</code> 以0开始，后面跟0-7的整数<br>3.16进制 <code>$zhengshu = 0x6ff;</code>  以0x开始，后面跟0-f的，0x的abcdef不区分大小写。</p><p>整型（整数）在计算机里面是有最大值和最小值范围的。</p><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>布尔值=false<br>整数值=0<br>浮点数=0.0<br>空字符串<br>空数组</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>在PHP语言中声明字符串有三种方式：</p><ol><li>用单引号声明</li><li>用双引号声明</li><li>用字界符声明（需要输入非常大段的字符串时使用）<br> 1).在变量后面的等号写三个小于号（&lt;&lt;&lt;）。<br> 2).然后在&lt;&lt;&lt;后面写上字符（建议英文大写字符）。如下例中的：ABC<br> 3).然后换行写上任意想写的字符<br> 4).写完后，顶行。在行最开始处，再写上&lt;&lt;&lt;后面的字符和分号。如下例中的：ABC;</li></ol><pre><code class="php">$zhifu = &#39;曾经有操蛋的爱情摆在我面前，我珍惜了。当我得到的时候才感到后悔莫及。如果非要在这段爱情前面加上一段三个字，我愿意说三个字：滚犊子&#39;;$str = &quot;如果非要在滚犊子前面加上一个时间的话我愿意是马上。&quot;;$dingjie = &lt;&lt;&lt;ABC  如果       非要在这个滚犊子   前       面&lt;br /&gt;      加上一段   &lt;i&gt;距离的话&lt;/i&gt;   我想说：&lt;h1&gt;思想有多远，你就跟我滚多远&lt;/h1&gt;ABC;$str1= &quot;asb{$str}dwqd&quot; // asb如果非要在滚犊子前面加上一个时间的话我愿意是马上。dwqd</code></pre><h5 id="双引号和单引号有什么区别"><a href="#双引号和单引号有什么区别" class="headerlink" title="双引号和单引号有什么区别"></a>双引号和单引号有什么区别</h5><ol><li>双引号解析变量，但是单引号不解析变量。</li><li>在双引号里面插入变量，变量后面如果有英文或中文字符，它会把这个字符和变量拼接起来，视为一整个变量。一定要在变量后面接上特殊字符，例如空格等分开。</li><li>如果在双引号里面插变量的时候，后面不想有空格，可以拿大括号将变量包起来。</li><li>双引号解析转义字符，单引号不解析转义字符。但，单引号能解析&#39; 和\</li><li>单引号效率高于双引号，尽可能使用单引号</li><li>双号和单引号可以互插！！！双引号当中插入单引号，单引号当中插入变量，这个变量会被解析。</li><li>神奇的字符串拼接胶水——（.）点，用来拼接字符串。</li><li>我们将定界符声明字符串视为双引号一样的功能来看待。</li></ol><h5 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h5><ol><li>转换函数：implode() , explode() , str_split()</li><li>截取函数：trim() , ltrim() , rtrim()</li><li>截取函数：substr(), strstr()</li><li>大小转换函数：strtltlower() , strtoupper() , ucfirst()</li><li>查找函数: strpos() , strrpos()<br>Strops(): 判断字符在目标字符串中出现的位置（首次）。注意判断为null需要用全等<br>Strrpos(): 判断字符在目标字符串中最后出现的位置</li><li>替换函数：str_replace()<br>Str_replace(匹配目标，替换内容, 字符串本身): 将目标字符串中部分字符串进行替换</li><li>格式化函数：printf() , sprintf()</li><li>其他：str_repeat() , str_shuffle()<br>str_repeat(): 重复某个字符串N次<br>str_shuffle(): 随机打乱字符串</li></ol><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>小数类型以及超过整形所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右<br>声明方式分为两种：普通声明，科学声明</p><pre><code class="php">$f = 1.23;$f = 1.23e10 // 科学计数法，其中e表示底10</code></pre><h4 id="NULL类型"><a href="#NULL类型" class="headerlink" title="NULL类型"></a>NULL类型</h4><p>主要有以下三空情况会产生空（null）类型：</p><p>1.通过变量赋值明确指定为变量的值为NULL<br>2.一个变量没有给任何值<br>3.使用函数unset()将变量销毁掉</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前PHP取得的数据），转换成目标数据类型</p><p>在PHP中有两个类型转换方式：</p><ol><li>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</li><li>强制（手动）转换：认为根据需要的目标类型转换</li></ol><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>函数定义时后括号里面接的变量是形式上的参数（形参），与函数体外的变量没有任何关系。仅仅是在函数内部执行</p><p>函数内声明的变量也与函数外的变量没关系。</p><p>但是，我们实际的处理情况中会遇到这样的一个情况：</p><p>我想在函数体内定义的变量在函数体外用</p><p>我想把函数体外的变量拿到函数体内来使用</p><p>这个时候我们就需要用到超全局变量。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><blockquote><p>static，是在函数内部定义的变量，使用static关键字修饰，用来实现跨函数共享数据的变量：函数运行结束所有局部变量都会清空，如果重新运行一下函数，所有的局部变量优惠重新初始化。声明一个静态变量，第二次调用函数的时候，静态变量不会再初始化变量，会在原值的基础上读取执行。</p></blockquote><pre><code class="php">&lt;?phpfunction demo(){   $a = 0;   echo $a;   $a++;}function test(){   static $a = 0;   echo $a;   $a++;}demo();demo();demo();demo();demo();demo();demo();demo();demo();demo();for($i = 0 ;$i &lt; 10 ; $i++){   test();}?&gt;结果为00000000000123456789</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在代码中的定义、书写方式：</p><ol><li><code>define(常量名，常量值)</code></li><li>const 常量名 = 值;</li></ol><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ol><li>常量不需要使用$符号，一旦使用系统就会认为是变量；</li><li>常量的名字组成由数字、字母和下划线组成，不能以数字开头；</li><li>常量的名字通常是以大写字母为主（与变量以示区别）；</li><li>常量的命名规则比变量松散，可以使用特殊字符，但只能用define定义</li></ol><pre><code class="php">define(&#39;-_-&#39;,&#39;smile&#39;);特殊的常量只能通过constant函数来声明print constant(&#39;-_-&#39;);</code></pre><h4 id="系统内置的常量"><a href="#系统内置的常量" class="headerlink" title="系统内置的常量"></a>系统内置的常量</h4><table><thead><tr><th>常量名</th><th>说明</th></tr></thead><tbody><tr><td><strong>LINE</strong></td><td>当前所在的行</td></tr><tr><td><strong>FILE</strong></td><td>当前文件在服务器的路径</td></tr><tr><td><strong>FUNCTIOIN</strong></td><td>当前函数名</td></tr><tr><td><strong>CLASS</strong></td><td>当前类名</td></tr><tr><td><strong>METHOD</strong></td><td>当前成员方法名</td></tr><tr><td><strong>PHP_OS</strong></td><td>PHP运行的操作系统</td></tr><tr><td><strong>PHP_VERSION</strong></td><td>当前PHP的版本</td></tr><tr><td><strong>TRAITTrait</strong> 的名字,php5.</td><td>4新加</td></tr><tr><td><strong>DIR</strong></td><td>文件所在的目录</td></tr><tr><td><strong>NAMESPACE</strong></td><td>当前命名空间的名称（区分大小写）</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><pre><code class="php">function 函数名([参数名1[=值1], 参数名2[=值2], 参数名n[=值n]]){       函数中的功能体    [return 返回值]}</code></pre><ol><li>函数以function开始</li><li>function后面接空格，空格后接函数名</li><li>函数名与变量命名规则基本一样，但是不同的是：函数名不区分大小写</li><li>所谓参数其实就是变量</li><li>函数名后接括号，括号内跟参数，参数全都有[]（中括号）括起来了，代表参数可填可不填</li><li>如果有参数的话，参数后可以接（＝）等号，等号接默认值。参数值也是用[]（中括号）括起来的，代表选填</li><li>函数后的参数变量，主要功能是把函数体外的变量值，传入函数体内来使用，函数体的变量和函数体外的变量通常是两个不         同的变量。</li><li>函数中的具体功能（功能体）用大括号括起来，代表这是一个函数的功能区间</li><li>函数可以有返回值也可以没有返回值，用[]（中括号）括起来的，代表选填。</li><li>return后接空格，空格后接返回值，若有return,return后的代码均不执行。</li><li>函数的执行没有顺序关系，可以在定义处之前的位置调用</li><li>函数不能被定义两次，即函数不能被重载</li></ol><h3 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h3><p>可变函数，我们也会称呼为变量函数。</p><pre><code class="php">&lt;?phpfunction demo(){    echo &#39;天王盖地虎&#39;;}function test(){    echo &#39;小鸡炖蘑菇&#39;;}$fu = &#39;demo&#39;;//把$fu变为了demo,把demo后加上了一个括号，就执行函数了$fu();//把$fu的值改为test字符串再试试？结果：天王盖地虎?&gt;</code></pre><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p>注意事项：</p><ol><li>内部函数名，不能是已存在的函数名</li><li>假设在函数a里面定义了一个内部函数，不能定用两次函数a。</li></ol><pre><code class="php">&lt;?phpfunction foo(){ echo &#39;我是函数foo哟，调一下我才会执行定义函数bar的过程&lt;br /&gt;&#39;; function bar(){      echo &#39;在foo函数内部有个函数叫bar函数&lt;br /&gt;&#39;; }}//现在还不能调用bar()函数，因为它还不存在bar();foo();//现在可以调用bar()函数了，因为foo()函数的执行使得bar()函数变为已定义的函数bar();//再调一次foo()看看是不是会报错？foo();?&gt;1.foo()调用两次会报错2.如果不调foo()函数无法执行bar函数，因为bar是在foo的内部</code></pre><h3 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h3><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><blockquote><p>bool copy ( string $source , string $dest [, resource $context ] )</p></blockquote><p>这个函数的功能为： 拷备一个文件</p><p>返回值为为： bool型值，就是成功返回true，失败返回false</p><p>参数为： 两个字符串的值，一个是copy的源文件，一个为目标文件。第三个参数可选的，不常用，我们不管它。</p><pre><code class="php">&lt;?phpif(copy(&#39;abc.txt&#39;,&#39;bcd.txt&#39;)){   echo &#39;复制成功&#39;;}else{   echo &#39;复制失败&#39;;}?&gt;</code></pre><h4 id="Array-unshift"><a href="#Array-unshift" class="headerlink" title="Array_unshift()"></a>Array_unshift()</h4><blockquote><p>int array_unshift ( array &amp;$array , mixed $value1 [, mixed $… ] )</p></blockquote><p>功能： 操作一个数组，向数组中之前插入其他类型的参数。</p><p>返回值： int 类型，可能就是插入成功最后的个数</p><p>参数： 第一个参数为&amp;符，也就是在操作的过程中，改变了第一个参数的值。引用传参。也就是操作这个数组，向这个数组中传入参数。会直接改变这个数组的值。</p><p>第二个参数为mixed，因为数组可以存入多个不同的类型.mixed是指混合的意思。因此，mixed是指可传入任意类型</p><p>第三个数数加了中括号，我们所有遇到中括号的。都是指后面的参数可传，也可以不传。</p><p>第四，最后还看到了三个…(省略号)。代表可以传入任意多个参数。</p><pre><code class="php">&lt;?phpif(copy(&#39;abc.txt&#39;,&#39;bcd.txt&#39;)){   echo &#39;复制成功&#39;;}else{   echo &#39;复制失败&#39;;}?&gt;结果为Array ( [0] =&gt; 杨幂 [1] =&gt; 姚晨 [2] =&gt; 凤姐 [3] =&gt; 芙蓉 )</code></pre><h4 id="array-walk"><a href="#array-walk" class="headerlink" title="array_walk"></a>array_walk</h4><blockquote><p>bool array_walk ( array &amp;$array , callable $callback [, mixed $userdata = NULL ] )</p></blockquote><p>功能：传入一个回调函数，将数组的原来的组操作，并且发生变化。</p><p>返回值：bool 值 也就是意味着，提示成功或者失败</p><p>参数：<br>第一个参数是要操作的数组。</p><p>第二个参数是callback 代表着可以传入函数或者匿名函数。</p><h3 id="时期时间信息函数"><a href="#时期时间信息函数" class="headerlink" title="时期时间信息函数"></a>时期时间信息函数</h3><h4 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h4><p>这个概念，之前大家听说过很多。我们来啰嗦两句，我们现实生活中使用的实区，在电脑里面也是一样有规定的。<br>1884年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为24个时区。<br>在中国采用首都北京所在地东八区的时间为全国统一使用时间。</p><p>设置时区<br>   1). date_default_timezone_get()<br>   2).date_default_timezone_set()</p><h4 id="世界时"><a href="#世界时" class="headerlink" title="世界时"></a>世界时</h4><p>不光是天文学家使用格林尼治时间（英文简写:GMT），就是在新闻报刊上也经常出现这个名词。我们知道各地都有各地的地方时间。如果对国际上某一重大事情，用地方时间来记录，就会感到复杂不便．而且将来日子一长容易搞错。因此，天文学家就提出一个大家都能接受且又方便的记录方法，那就是以格林尼治（英国某地区）的地方时间为标准。</p><h4 id="unix时间戳"><a href="#unix时间戳" class="headerlink" title="unix时间戳"></a>unix时间戳</h4><p>电脑本身不认识时间，我们在电脑里面设置一个时间方便运算。于是我们规定了一种计算方式，unix时间戳。<br>从Unix纪元（1970 年 1月1日零时）开始到一个时间经过的秒数。</p><p>time()获取当前的unix时间戳</p><p>string date ( string $forrnat [, int $tirnestamp] )<br>在参数列表中:</p><p>$timestamp是一个时间戳，函数将这个时间戳按$format规定的格式输出。</p><p>如果$timestamp没有输入值，则默认为当前的时间。</p><p>$format是一个时间输出格式的字符串，需要使用规定的字符构造输出格式。</p><h4 id="date函数的格式参数表"><a href="#date函数的格式参数表" class="headerlink" title="date函数的格式参数表"></a>date函数的格式参数表</h4><p>|字符|说明|返回值|<br>|–|–|<br>|d|月份中的第几天，有前导零的2 位数字|01 到31|<br>|D|英文星期几，3个字母|Mon到Sun|<br>|j|月份中的第几天，没有前导零|1 到31|<br>|l|   (字母)英文星期几|Sunday到 Saturday|<br>|N|1格式数字表示的星期|1（表示星期一）到7（表示星期天)|<br>|S|每月天数后面的英文后缀，2个字符|st，nd，rd或者th。可以和jg一起用|<br>|w|星期中的第几天，数字表示|0（表示星期天）到 6（表示星期六）|<br>|z|一年中的第几天|0到366|<br>|W|年份中的第几周，每周从星期一开始|42（当年的第42周）|<br>|F|月份，完整的文本格式|January 到 December|<br>|m|数字表示月份，有前导零|01 到 12|<br>|M|3个字母缩写表示的月份|Jan 到Dec|<br>|n|数字表示月份，没有前导零|1 到 12|<br>|t|给定月份所应有的天数|28 到 31|<br>|L|是否为闰年|如果是闰年为1，否则为o|<br>|o|格式年份数字|例如2007|<br>|Y|4 位数字完整表示年份|例如1999或2008|<br>|y|2 位数字表示的年份|例如99或08|<br>|a|小写的上午和下午值|am或pm|<br>|A|大写的上午和下午值|AM或PM|<br>|g|小时，12小时格式，没有前导零|1到12|<br>|G|小时，24小时格式，没有前导零|0 到 23|<br>|i|有前导零的分钟数|00 到 59|<br>|s|秒数，有前导零|00到59|<br>|e|时区标识||<br>|U|从Unix纪元开始至今的秒数|长整型数字|</p><pre><code class="php">&lt;?php//定义一下时区常量，以后你可以放到配置文件里define(&#39;TIME_ZONE&#39;,&#39;Asia/shanghai&#39;);//执行函数date_default_timezone_set(TIME_ZONE);echo date(&#39;Y-m-d H:i:s&#39;);?&gt;</code></pre><h4 id="日期验证函数"><a href="#日期验证函数" class="headerlink" title="日期验证函数"></a>日期验证函数</h4><p>bool checkdate ( int $month , int $day , int $year )<br>如果是有效的时间就返回真，如果不是有效的时间就返回假。</p><pre><code class="php">&lt;?phpvar_dump(checkdate(12, 31, 2018));var_dump(checkdate(2, 29, 2011));?&gt;bool(true) bool(false)</code></pre><h3 id="包含函数"><a href="#包含函数" class="headerlink" title="包含函数"></a>包含函数</h3><p>|函数|包含失败|特点|<br>|–|–|–|–|<br>|Inlcude|返回一条警告|文件继续向下执行。通常用于动态包含|<br>|Require|一个致命的错|代码就不会继续向下执行。通常包含极为重要的文件，整个代码甭想执行|<br>|Include_once|返回一条警告|除了原有include的功能以外，它还会做once检测，如果文件曾经已经被被包含过，不再包含|<br>|Require_once|一个致命的错|除了原的功能一外，会做一次once检测，防止文件反复被包含|</p><p>注意：</p><ol><li>少用_once带once，因为它会消耗更多的资源去做检测的工作。</li><li>Include文件只需要编译一次，因为每次包含include都会再执行一次对应的代码，如何减少include再次执行时，需要重新解析的过程。</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h3><p>. 将两个字符串连接到一起<br>.= 复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量<br><code>A.=b   =&gt; A = A . b</code></p><h3 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h3><p><code>@()</code>()内填写语句，如果报错可以抑制不显示，直接继续执行，一般用在生产环境</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装问题</title>
    <link href="undefined2020/05/28/%E9%94%99%E8%AF%AF/GO/%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <url>2020/05/28/%E9%94%99%E8%AF%AF/GO/%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="导包的问题"><a href="#导包的问题" class="headerlink" title="导包的问题"></a>导包的问题</h2><p>安装GO需要配置的参数<br>配置参数：</p><ol><li>GOROOT （GO的位置）</li><li>GOPATH   （GO的工作空间位置）</li><li>GOPROXY  （远程代理url）</li><li>GO111MODULE = on</li></ol><p>在配置正确，且项目路径正确的前提下输入<code>go mod tudy</code><br>下载mod，如果出现报错，就检查报错的文件所在位置是否正确<br><strong>正确的依赖位置应该在GOPATH里的pkg中，如果不是请删除该位置的包！！！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>错误,GO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php环境搭建</title>
    <link href="undefined2020/05/26/%E5%90%8E%E7%AB%AF/php/php%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>2020/05/26/%E5%90%8E%E7%AB%AF/php/php%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="php执行流程"><a href="#php执行流程" class="headerlink" title="php执行流程"></a>php执行流程</h2><img src="/2020/05/26/%E5%90%8E%E7%AB%AF/php/php%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/php%E6%A6%82%E5%BF%B5.png" srcset="undefined" class="" title="php概念"><h2 id="下载xampp"><a href="#下载xampp" class="headerlink" title="下载xampp"></a>下载xampp</h2><p>直接安装运行，在xamp-&gt;hits文件夹下放置项目,之后可本地访问</p>]]></content>
    
    
    <categories>
      
      <category>php</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的字符串</title>
    <link href="undefined2020/05/24/%E5%90%8E%E7%AB%AF/python/python%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>2020/05/24/%E5%90%8E%E7%AB%AF/python/python%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p>原始字符串的使用非常简单，只需要在字符串前加一个字母r即可，<strong>注意，原始字符串不能在结尾放\会报错</strong></p><pre><code class="python">str1 = r&#39;C:\now&#39;str2 = r&#39;C:\now\fish\a\&#39;会报错</code></pre><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol><li>在后面拼接<code>str = r&#39;C:\new\aaa\bbb&#39;+&#39;\\&#39;</code></li><li>在后面加上[:-1] <code>str = r&#39;C:\new\aaa\bbb\\&#39;[:-1]</code></li></ol><h2 id="长字符串"><a href="#长字符串" class="headerlink" title="长字符串"></a>长字符串</h2><p>如果想得到一个跨越多行的字符串，我们就需要使用三重引号<code>&quot;&quot;&quot;dsdssdsds&quot;&quot;&quot;</code></p><h2 id="字符串的分片操作"><a href="#字符串的分片操作" class="headerlink" title="字符串的分片操作"></a>字符串的分片操作</h2><pre><code class="python">str1 = &quot;I love you&quot;str1[:6] =&gt; &#39;I love&#39;</code></pre><h2 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h2><pre><code class="python">s = &#39;Wusirs22&#39;t1 = s.count(&#39;a&#39;) # 在字符串中查找指定字符有多少个t2 = s.upper() # 将字符串中的字符全部大写t3 = s.lower() # 将字符串中的字符全部小写t4 = s.title() # 非字母隔开的每个单词的首字母大写t5 = s.find(&#39;a&#39;) # 通过元素获取其索引,找到第一个就返回,找不到会返回-1。t6 = s.index(&#39;a&#39;) # 通过元素获取其索引,找到第一个就返回，找不到会报错。t7 = s.capitalize() # 将字符串中的首字母大写t8 = s.replace(&#39;a&#39;,&#39;nb&#39;,2) # 替换,由什么替换成什么,替换几次t9 = s.startswith(&#39;w&#39;) # 判断以什么为开头 可以切片t10 = s.startswith(&#39;i&#39;,3,) # 判断以什么为开头 可以切片,取索引3后面的所有字符t11 = s.endswith(&#39;i&#39;,3) # 判断以什么结尾，可以切片,取索引3后面的所有字符t12 = s.swapcase() # 大小写反转t13 = s.isupper() # 判断字符串中所有字母是否为大写，返回布尔值t14 = s.islower() # 判断字符串中所有字母是否为小写，返回布尔值t15 = s.isdigit() # 字符串只由数字组成t16 = s.isalpha() # 字符串只由字母组成t17 = s.isalnum() # 字符串由字母或数字组成---------------------------------------------------------------t18 = s.strip(&#39;W&#39;) # 默认去除字符串两边的空格，换行符，制表符,只是去除左边--&gt;lstrip()去除右边--&gt;rstrip(),可设置去除的字符t19 = s.split() # 默认按照空格分割,t20 = s.split(&#39;r&#39;) # 指定字符进行分割,t21 = s.split(&#39;s&#39;,2) # 指定字符进行分割,且指定分割次数---------------------------------------------------------------join 连接符l1 = [&#39;wusir&#39;, &#39;alex&#39;, &#39;taibai&#39;] # 操作列表时，列表里面的内容必须全部是字符串类型t22 = &#39;&#39;.join(l1) # 默认连接t23 = &#39;-&#39;.join(l1)   # 指定字符连接---------------------------------------------------------------字符串的格式化输出第一种情况m = &#39;姓名:{} 年龄:{} 性别:{}&#39;w = m.format(&#39;烟雨江南&#39;,20,&#39;男&#39;)print(w)第二种情况m = &#39;姓名:{0} 年龄:{1} 性别:{2} 我永远{1}岁&#39;w = m.format(&#39;烟雨江南&#39;,18,&#39;男&#39;)print(w)第三种情况m = &#39;姓名:{name} 年龄:{age} 性别:{sex} 我永远{age}岁&#39;w = m.format(name = &#39;烟雨江南&#39;,age = 18,sex = &#39;男&#39;)print(w)</code></pre><h2 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h2><ol><li>通过大括号+索引来进行替换</li><li>通过关键字来进行替换</li></ol><pre><code class="python"># 索引来进行替换&quot;{0} love {1}.{2}&quot;.format(&quot;I&quot;,&quot;you&quot;,&quot;li&quot;)&#39;I love you.li&#39;# 关键字来进行替换&quot;{a} love {b}.{c}&quot;.format(a=&quot;I&quot;,b=&quot;you&quot;,c=&quot;li&quot;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础</title>
    <link href="undefined2020/05/19/%E5%90%8E%E7%AB%AF/python/python%E5%9F%BA%E7%A1%80/"/>
    <url>2020/05/19/%E5%90%8E%E7%AB%AF/python/python%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>在使用变量之前，需要对其赋值</li><li>变量名可以报考字母、数字、下划线，但变量名不能以数字开头</li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h4><p>原始字符串的使用非常简单，只需要在字符串前加一个字母r即可，<strong>注意，原始字符串不能在结尾放\会报错</strong></p><pre><code class="python">str1 = r&#39;C:\now&#39;str2 = r&#39;C:\now\fish\a\&#39;会报错</code></pre><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>在后面拼接<code>str = r&#39;C:\new\aaa\bbb&#39;+&#39;\\&#39;</code></li><li>在后面加上[:-1] <code>str = r&#39;C:\new\aaa\bbb\\&#39;[:-1]</code></li></ol><h4 id="长字符串"><a href="#长字符串" class="headerlink" title="长字符串"></a>长字符串</h4><p>如果想得到一个跨越多行的字符串，我们就需要使用三重引号<code>&quot;&quot;&quot;dsdssdsds&quot;&quot;&quot;</code></p><h4 id="字符串的分片操作"><a href="#字符串的分片操作" class="headerlink" title="字符串的分片操作"></a>字符串的分片操作</h4><pre><code class="python">str1 = &quot;I love you&quot;str1[:6] =&gt; &#39;I love&#39;</code></pre><h4 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h4><pre><code class="python">s = &#39;Wusirs22&#39;t1 = s.count(&#39;a&#39;) # 在字符串中查找指定字符有多少个t2 = s.upper() # 将字符串中的字符全部大写t3 = s.lower() # 将字符串中的字符全部小写t4 = s.title() # 非字母隔开的每个单词的首字母大写t5 = s.find(&#39;a&#39;) # 通过元素获取其索引,找到第一个就返回,找不到会返回-1。t6 = s.index(&#39;a&#39;) # 通过元素获取其索引,找到第一个就返回，找不到会报错。t7 = s.capitalize() # 将字符串中的首字母大写t8 = s.replace(&#39;a&#39;,&#39;nb&#39;,2) # 替换,由什么替换成什么,替换几次t9 = s.startswith(&#39;w&#39;) # 判断以什么为开头 可以切片t10 = s.startswith(&#39;i&#39;,3,) # 判断以什么为开头 可以切片,取索引3后面的所有字符t11 = s.endswith(&#39;i&#39;,3) # 判断以什么结尾，可以切片,取索引3后面的所有字符t12 = s.swapcase() # 大小写反转t13 = s.isupper() # 判断字符串中所有字母是否为大写，返回布尔值t14 = s.islower() # 判断字符串中所有字母是否为小写，返回布尔值t15 = s.isdigit() # 字符串只由数字组成t16 = s.isalpha() # 字符串只由字母组成t17 = s.isalnum() # 字符串由字母或数字组成---------------------------------------------------------------t18 = s.strip(&#39;W&#39;) # 默认去除字符串两边的空格，换行符，制表符,只是去除左边--&gt;lstrip()去除右边--&gt;rstrip(),可设置去除的字符t19 = s.split() # 默认按照空格分割,t20 = s.split(&#39;r&#39;) # 指定字符进行分割,t21 = s.split(&#39;s&#39;,2) # 指定字符进行分割,且指定分割次数---------------------------------------------------------------join 连接符l1 = [&#39;wusir&#39;, &#39;alex&#39;, &#39;taibai&#39;] # 操作列表时，列表里面的内容必须全部是字符串类型t22 = &#39;&#39;.join(l1) # 默认连接t23 = &#39;-&#39;.join(l1)   # 指定字符连接---------------------------------------------------------------字符串的格式化输出第一种情况m = &#39;姓名:{} 年龄:{} 性别:{}&#39;w = m.format(&#39;烟雨江南&#39;,20,&#39;男&#39;)print(w)第二种情况m = &#39;姓名:{0} 年龄:{1} 性别:{2} 我永远{1}岁&#39;w = m.format(&#39;烟雨江南&#39;,18,&#39;男&#39;)print(w)第三种情况m = &#39;姓名:{name} 年龄:{age} 性别:{sex} 我永远{age}岁&#39;w = m.format(name = &#39;烟雨江南&#39;,age = 18,sex = &#39;男&#39;)print(w)</code></pre><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>e记法：科学计数法</p><pre><code class="python">15000 == 1.5e40.001 == 1e-3</code></pre><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>true为1，false为0</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><pre><code class="python">int(&#39;222&#39;)int(3.2) == 3float(520) == 520.0float(&#39;23.4&#39;) = 23.4str(5e2) == &#39;5e+2&#39;</code></pre><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><pre><code class="python">type(5e0) -&gt; floattype(&#39;ewew&#39;) -&gt; strisinstance(333,int) -&gt; trueisinstance(false,bool) -&gt; true</code></pre><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><pre><code class="python">if 条件 :    条件为真执行的操作elif 条件 :    条件为真执行的操作else:    条件为假执行的操作</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><pre><code class="python">while 条件 :    条件为真执行的操作for 目标 in 表达式:    循环体</code></pre><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p>语法：range([start,] stop[, step=1])</p><ul><li>这个BIF有三个参数，其中中括号括起来的两个表示可选</li><li>step=1表示第三个参数默认为1</li><li>range这个BIF的作用是生成一个从start参数的值开始到stop参数的值结束的数字序列</li></ul><p>语法：range</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h3><pre><code class="python">3 / 2 = 1.53 // 2 = 1- True = -1** 幂运算操作符3 ** 2 == 9</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code class="python">not 4 = False</code></pre><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>幂运算 &gt; 正负号 &gt; 算数运算符 &gt; 比较运算符 &gt; 逻辑运算符</p><h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><pre><code class="python">small = x if x &gt; y else y如果x&gt;y就将x给small否则将y给small</code></pre><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>assert这个关键字我们称之为断言，当这个关键字后边的条件为假的时候，程序自动崩溃并跑出AssertionError的异常</p><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h2><h3 id="向列表中添加元素"><a href="#向列表中添加元素" class="headerlink" title="向列表中添加元素"></a>向列表中添加元素</h3><p>append()向列表后添加1个元素</p><pre><code class="python">member = [1,2,3]member.append(1)</code></pre><p>extend()向列表后追加列表</p><pre><code class="python">member = [1,2,3]member.extend([1,2,3])member = [1,2,3,1,2,3]</code></pre><p>insert()向列表中插入1个元素</p><pre><code class="python">member = [1,2,3]member.insert(1,&quot;哈哈&quot;)member = [1,&quot;哈哈&quot;,2,3]</code></pre><h3 id="向列表中删除元素"><a href="#向列表中删除元素" class="headerlink" title="向列表中删除元素"></a>向列表中删除元素</h3><p>remove()删除某一个元素，需要知道元素名，如果该数组中不存在该元素，会报错</p><pre><code class="python">member = [1,&quot;哈哈&quot;,2,3]member.remove(&quot;哈哈&quot;)member = [1,2,3]</code></pre><p><code>del 列表</code> 删除该列表,del的删除只是清除member元素内的索引值，也就是说member2 = member后del.member,member2依然有值，但是remove一个元素后悔影响memebr2的显示，因为他们指向同一处内存。</p><pre><code class="python">member = [1,&quot;哈哈&quot;,2,3]del member再次输出member会报错，需要再次声明</code></pre><p>pop()默认删除列表的最后一个元素，括号中可以填写要删除的索引值，<strong>有返回值</strong></p><pre><code class="python">member = [1,&quot;哈哈&quot;,2,3]member.pop(2)如果索引值大于数组长度会报错</code></pre><h3 id="列表分片（Slice）"><a href="#列表分片（Slice）" class="headerlink" title="列表分片（Slice）"></a>列表分片（Slice）</h3><ul><li>利用索引值，每次我们可以从列表获取一个元素，但是我们总是贪心的，如果一次性需要获取多个元素，有没有办法实现呢？<br>  利用列表分片，我们可以简单的实现这个要求。</li></ul><p>列表[开始索引:结束索引] 分片的列表并不会影响原列表，是原列表的拷贝，列表从开始索引到结束索引的前一位</p><pre><code class="python">member = [1,&quot;哈哈&quot;,2,3]member[1:4] = [&#39;哈哈&#39;, 2, 3]member[1:] = [&#39;哈哈&#39;, 2, 3]member[:3] = [1, &#39;哈哈&#39;, 2]member2 = member[:]这是将memebr的值拷贝给member2，操作memeber不会影响memeber2</code></pre><h3 id="列表的常用操作符"><a href="#列表的常用操作符" class="headerlink" title="列表的常用操作符"></a>列表的常用操作符</h3><h4 id="列表的比较"><a href="#列表的比较" class="headerlink" title="列表的比较"></a>列表的比较</h4><pre><code class="python">list1 = [123]list2 = [456]list1 &lt; list2 =&gt;返回True</code></pre><p>当列表中有多个元素，只比较第一个</p><h4 id="列表的加法"><a href="#列表的加法" class="headerlink" title="列表的加法"></a>列表的加法</h4><pre><code class="python">list1 = [123]list2 = [456]list1 + list2 =&gt;返回[123,456]</code></pre><p>但是，列表的加法不能与非列表类型元素相加，也就是说list1+’123’是错误的，但是list1+[123]是正确的</p><h4 id="列表的乘法"><a href="#列表的乘法" class="headerlink" title="列表的乘法"></a>列表的乘法</h4><pre><code class="python">list1 = [123] * 2list1 =&gt;返回[123,123]</code></pre><h4 id="列表的成员操作符"><a href="#列表的成员操作符" class="headerlink" title="列表的成员操作符"></a>列表的成员操作符</h4><pre><code class="python">list1 = [123,455,&#39;455&#39;,[556,755]]&#39;455&#39; in list1 =&gt;返回True556 in list1 =&gt;返回False556 in list1[3] =&gt;返回True</code></pre><h3 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h3><h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p>统计参数在列表中的数量</p><pre><code class="python">list1 = [123,455,&#39;455&#39;,[556,755,123],123]list1.count(123) =&gt; 2</code></pre><h4 id="index"><a href="#index" class="headerlink" title="index()"></a>index()</h4><pre><code class="python">list1 = [123,455,&#39;455&#39;,[556,755,123],123]list1.index(123,2,4) =&gt; 2list1.index(123,1,5) =&gt; 4list1.index(123,1,4) =&gt; not in list1</code></pre><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>反转列表</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>对列表进行从小到大的排序<br>有一个参数list1.sort(reverse=True)，设置后变成从大到小排序</p><p>第二个参数是起始位置，第三个参数是终止位置，范围包含起始位置但不包含终止位置</p><h2 id="元组-typle-：带上了枷锁的列表"><a href="#元组-typle-：带上了枷锁的列表" class="headerlink" title="元组(typle)：带上了枷锁的列表"></a>元组(typle)：带上了枷锁的列表</h2><ul><li>由于和列表是近亲关系，所以元组和列表在实际使用上是非常相似的。</li></ul><h3 id="创建和访问元组"><a href="#创建和访问元组" class="headerlink" title="创建和访问元组"></a>创建和访问元组</h3><p>创建列表使用中括号，但是创建元组使用小括号</p><pre><code class="python">tuple1 = (1,2,3,4,5,6)tuple1[5:] =&gt; 6</code></pre><p>但是<strong>只使用小括号创建的也有可能不是元组</strong></p><pre><code class="python">tuple1 = (1)type(tuple1) =&gt; class &#39;int&#39;</code></pre><p>如果你想创建的元组只有一个元素的话，必须在后面加上逗号</p><pre><code class="python">tuple1 = (1,)type(tuple1) =&gt; class &#39;tuple&#39;</code></pre><h3 id="更新元组"><a href="#更新元组" class="headerlink" title="更新元组"></a>更新元组</h3><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><table><thead><tr><th>Operation</th><th>Big-O Efficiency</th></tr></thead><tbody><tr><td>index []</td><td>O(1)</td></tr><tr><td>index assignment</td><td>O(1)</td></tr><tr><td>append</td><td>O(1)</td></tr><tr><td>pop()</td><td>O(1)</td></tr><tr><td>pop(i)</td><td>O(n)</td></tr><tr><td>insert(i,item)</td><td>O(n)</td></tr><tr><td>del operator</td><td>O(n)</td></tr><tr><td>iteration</td><td>O(n)</td></tr><tr><td>contains (in)</td><td>O(n)</td></tr><tr><td>get slice [x:y]</td><td>O(k)</td></tr><tr><td>del slice</td><td>O(n)</td></tr><tr><td>set slice</td><td>O(n+k)</td></tr><tr><td>reverse</td><td>O(n)</td></tr><tr><td>concatenate</td><td>O(k)</td></tr><tr><td>sort</td><td>O(n log n)</td></tr><tr><td>multiply</td><td>O(nk)</td></tr></tbody></table><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><blockquote><p>dir(对象),返回这个对象可以调用的方法</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP通信程序</title>
    <link href="undefined2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F/"/>
    <url>2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><h3 id="两端通信时步骤"><a href="#两端通信时步骤" class="headerlink" title="两端通信时步骤"></a>两端通信时步骤</h3><ol><li>服务器端先启动</li><li>服务器端不会主动的请求客户端</li><li>必须使用客户端请求服务器端</li><li>客户端和服务端就会建立一个逻辑连接</li><li>而这个连接中包含一个对象</li><li>这个对象就是IO对象</li><li>客户端和服务器端就可以使用</li><li>IO对象进行通信</li><li>通信的数据不仅仅是字符</li><li>所以IO对象是字节流对象</li></ol><p>服务端程序，需要事先启动，等待客户端的连接<br>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</p><p>服务端必须明确两件事情：</p><ol><li>多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互在服务器端有一个方法，叫accept客户端获取到请求的客户端对象</li><li>多个客户端同时和服务器进行交互，就需要使用多个IO流对象<br> 服务器是没有IO流的，服务器可以获取到请求的客户端对象Socket<br> 使用每个客户单Socket中提供的IO流和客户端进行交互<pre><code> 服务器使用客户端的字节流读取客户端发送的数据 服务器使用客户端的字节流输出给客户端回写数据</code></pre></li></ol><h3 id="在Java中，提供了两个类用于事先TCP通信程序"><a href="#在Java中，提供了两个类用于事先TCP通信程序" class="headerlink" title="在Java中，提供了两个类用于事先TCP通信程序"></a>在Java中，提供了两个类用于事先TCP通信程序</h3><ol><li>客户端：java.net.Socket类标识。创建Socket对象，想服务端发送连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：java.net,ServerSocket类表示。创建ServerSocket对象，相当于开启一个读物，并等待客户端的连接。</li></ol><h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><p>Socket类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点</p>]]></content>
    
    
    <categories>
      
      <category>Socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程入门</title>
    <link href="undefined2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <url>2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h2><ul><li>C/S结构：全程为Client/Server结构，是指客户端和服务器结构。常见程序有QQ、迅雷等软件。<img src="/2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/cs.png" srcset="undefined" class="" title="cs"></li><li>B/S结构：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。<img src="/2020/05/14/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket%E5%A5%97%E6%8E%A5%E5%AD%97/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/bs.png" srcset="undefined" class="" title="bs"></li></ul><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><ul><li>网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li>TCP/IP协议：传输控制协议/因特网互联协议（Transmission Control Protocol/Internet Protocol）是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在他们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>协议:计算机网络通信必须遵守的规则。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>IP地址：指互联网协议地址（Internet Protocol Address）,俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。加入我们把个人电脑比作一台电话的话，那么IP地址就相当于电话号码。</li><li>IP地址分类<ul><li>IPV4：4个字节组成，</li><li>IPV6：128位地址长度，每16字节一组，分成8组十六进制数</li></ul></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>查看本机IP地址：ipconfig</li><li>检查网络是否连通：ping IP地址</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说IP地址可以唯一标识网络中的设备，那么端口号捷克语唯一标识设备中的进程了。</p><ul><li>端口号：用两个字节标识的整数，它的取值范围是0-65535.其中，0-1023之间的端口号用于一些知名的网络服务和应用，普通的应该程序需要使用1024以上的端口号。如果端口号呗另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用协议+IP地址+端口号三元组合，捷克语标识网络中的进程了，那么进程间的通信就可以利用这个标识与其他进程进行交互。</p>]]></content>
    
    
    <categories>
      
      <category>Socket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语句</title>
    <link href="undefined2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="sql">SELECT … FROMa,bWHERE a.x = b.xSELECT … FROM aINNER JOIN bon a.x = b.xSELECT … FROM aJOIN bon a.x = b.x</code></pre><p>Q：上述这些语法是否有区别？<br>A：没有任何区别<br>Q：哪个性能更好？<br>A：没有任何区别<br>A：好吧，如果要认真算的话，那么3最好，因为字节数最少<br>Q：那为什么需要不同的语法？<br>A：ANSI SQL 89、ANSI SQL 92语法标准<br>A：ANSI 92标准开始支持OUTER JOIN<br>A：INNER JOIN可以省略INNER关键字</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>• nested_loop join<br>    • simple nested-loop join<br>    • index nested-loop join<br>    • block nested-loop join<br>• classic hash join<br>    • Only support in MariaDB<br>• bached key access join<br>    • from MySQL 5.6</p><h4 id="simple-nested-loop-join"><a href="#simple-nested-loop-join" class="headerlink" title="simple nested_loop join"></a>simple nested_loop join</h4><p>扫描成本： O（Rn×Sn）</p><img src="/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/simple.png" srcset="undefined" class="" title="simple"><h4 id="index-nested-loop-join"><a href="#index-nested-loop-join" class="headerlink" title="index nested_loop join"></a>index nested_loop join</h4><p>使用前提是每张表都要有索引<br>添加索引减少扫描成本，因为添加索引后扫描的时间是固定的<br>扫描成本： O（Rn）<br>优化器倾向于使用小表做驱动表<br>理由是2^100 &gt; 100^2</p><h4 id="block-nested-loop-join"><a href="#block-nested-loop-join" class="headerlink" title="block nested-loop join"></a>block nested-loop join</h4><p>• 优化simple nested-loop join<br>• 减少内部表的扫描次数</p><img src="/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/block.png" srcset="undefined" class="" title="block"><p>系统变量join_buffer_size决定了Join Buffer的大小<br>Join Buffer可被用于联接是ALL，index，range的类型<br>Join Buffer只存储需要进行查询操作的相关列数据，而不是整行的记录<br>扫描成本呢？</p><h3 id="classic-hash-join"><a href="#classic-hash-join" class="headerlink" title="classic hash join"></a>classic hash join</h3><p>基于block join增加了hash表，减少了比较次数，一般用于数据量大时</p><img src="/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/hash.png" srcset="undefined" class="" title="hash"><h2 id="sql问题"><a href="#sql问题" class="headerlink" title="sql问题"></a>sql问题</h2><h3 id="给查出的表格加行号"><a href="#给查出的表格加行号" class="headerlink" title="给查出的表格加行号"></a>给查出的表格加行号</h3><p>注意 变量a前面要加@并且后面用:=这样才不会报错，并且一定要给表加逗号取别名</p><pre><code class="sql">SELECT @a:=@a+1 as row ,id,usernameFROM `user`,(select @a:=0) u</code></pre><h3 id="排名问题"><a href="#排名问题" class="headerlink" title="排名问题"></a>排名问题</h3><p>按照规则并列的排相同的名次，10分第一名，20分第二名，30分并列第三，40分第四</p><p>当prev_value和rank_column相等就返回rank_count，如果不相等,就将rank_column赋值给prev_value，赋值语句一定返回true，然后将rank_count+1</p><img src="/2020/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/SQL%E8%AF%AD%E5%8F%A5/sql%E9%97%AE%E9%A2%98.png" srcset="undefined" class="" title="sql问题"><h3 id="查询中时间类型的比较"><a href="#查询中时间类型的比较" class="headerlink" title="查询中时间类型的比较"></a>查询中时间类型的比较</h3><p>用data_format来格式化时间，然后使用字符串进行比较，确保比较双方的格式一致</p><pre><code class="sql">select * from test where date_format(create_time,&#39;%Y-%m-%d&#39;) between &#39;2019-03-05&#39; and &#39;2019-03-08&#39;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表的创建与维护</title>
    <link href="undefined2020/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4/"/>
    <url>2020/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ul><li>表是关系数据库的核心</li><li>表=关系</li><li>表是记录的集合</li><li>二维表格模型易于人类理解</li><li>MySQL默认存储引擎都是基于行（记录）存储</li><li>每行记录都是基于列进行组织的</li></ul><h3 id="MySQL中数据库与表之间的关系"><a href="#MySQL中数据库与表之间的关系" class="headerlink" title="MySQL中数据库与表之间的关系"></a>MySQL中数据库与表之间的关系</h3><img src="/2020/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4/%E8%A1%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="undefined" class="" title="表和数据库的关系"><h3 id="CREATE-TABLE语法"><a href="#CREATE-TABLE语法" class="headerlink" title="CREATE TABLE语法"></a>CREATE TABLE语法</h3><pre><code class="sql">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name(create_definition,...)[table_options][partition_options]create_definition:col_name column_definition| [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...)[index_option] ...| {INDEX|KEY} [index_name] [index_type] (index_col_name,...)[index_option] ...| [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY][index_name] [index_type] (index_col_name,...)[index_option] ...| {FULLTEXT|SPATIAL} [INDEX|KEY] [index_name] (index_col_name,...)[index_option] ...| [CONSTRAINT [symbol]] FOREIGN KEY[index_name] (index_col_name,...) reference_definition| CHECK (expr)table_option:ENGINE [=] engine_name| AUTO_INCREMENT [=] value| AVG_ROW_LENGTH [=] value| [DEFAULT] CHARACTER SET [=] charset_name| CHECKSUM [=] {0 | 1}| [DEFAULT] COLLATE [=] collation_name| COMMENT [=] &#39;string&#39;| CONNECTION [=] &#39;connect_string&#39;| DATA DIRECTORY [=] &#39;absolute path to directory&#39;| DELAY_KEY_WRITE [=] {0 | 1}| INDEX DIRECTORY [=] &#39;absolute path to directory&#39;| INSERT_METHOD [=] { NO | FIRST | LAST }| KEY_BLOCK_SIZE [=] value| MAX_ROWS [=] value| MIN_ROWS [=] value| PACK_KEYS [=] {0 | 1 | DEFAULT}| PASSWORD [=] &#39;string&#39;| ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}| STATS_AUTO_RECALC [=] {DEFAULT|0|1}| STATS_PERSISTENT [=] {DEFAULT|0|1}| STATS_SAMPLE_PAGES [=] value| TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]| UNION [=] (tbl_name[,tbl_name]...)</code></pre><h3 id="CREATE-TABLE——外键约束"><a href="#CREATE-TABLE——外键约束" class="headerlink" title="CREATE TABLE——外键约束"></a>CREATE TABLE——外键约束</h3><p>外键约束主要是为了保持数据一致性</p><pre><code class="sql">[CONSTRAINT [symbol]] FOREIGN KEY[index_name] (index_col_name, ...)REFERENCES tbl_name (index_col_name,...)[ON DELETE reference_option][ON UPDATE reference_option]reference_option:RESTRICT | CASCADE | SET NULL | NO ACTIONRESTRICT = NO ACTION</code></pre><p>CASCADE：父表delete、update的时候，子表会delete、update掉关联记录；<br>SET NULL：父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；<br>RESTRICT：如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；<br>NO ACTION：同 RESTRICT，也是首先先检查外键；</p><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><pre><code class="sql">ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name[alter_specification [, alter_specification] ...][partition_options]如需在表中添加列，请使用下面的语法:ALTER TABLE table_nameADD column_name datatype如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：ALTER TABLE table_nameDROP COLUMN column_name要改变表中列的数据类型，请使用下面的语法：MySQL / Oracle：ALTER TABLE table_nameMODIFY COLUMN column_name datatype</code></pre><h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>• 将一个表或者索引分解为多个更小、更可管理的部分<br>• 目前只支持水平分区<br>• 局部分区索引<br>• 每个分区保存自己的数据与索引<br>• 分区列必须是唯一索引的一个组成部分</p><pre><code class="sql">mysql&gt; CREATE TABLE t1 (-&gt; col1 INT NOT NULL,-&gt; col2 DATE NOT NULL,-&gt; col3 INT NOT NULL,-&gt; col4 INT NOT NULL,-&gt; UNIQUE KEY (col1, col2)-&gt; )-&gt; PARTITION BY HASH(col3)-&gt; PARTITIONS 4;ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table&#39;s partitioning function</code></pre><h3 id="分区类型支持"><a href="#分区类型支持" class="headerlink" title="分区类型支持"></a>分区类型支持</h3><p>range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区<br>list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区<br>hash分区：基于给定的分区个数，把数据分配到不同的分区<br>key分区：类似于hash分区</p><pre><code class="sql">CREATE TABLE t(id INT PRIAMRY KEY)ENGINE=INNODBPARTITION BY RANGE (id)(PARTITION p0 VALUES LESS THAN (10),PARTITION p1 VALUES LESS THAN (20));mysql&gt; CREATE TABLE t (-&gt; a INT,-&gt; b INT)ENGINE=INNODB-&gt; PARTITION BY LIST(b)(-&gt; PARTITION p0 VALUES IN (1,3,5,7,9),-&gt; PARTITION p1 VALUES IN (0,2,4,6,8)-&gt; );CREATE TABLE t_hash (a INT,b DATETIME)ENGINE=InnoDBPARTITION BY HASH (YEAR(b))PARTITIONS 4;mysql&gt; CREATE TABLE t_key (-&gt; a INT,-&gt; b DATETIME)ENGINE=InnoDB-&gt; PARTITION BY KEY (b)     这里的key把b进行了内部hash所以也是int类型-&gt; PARTITIONS 4;</code></pre><p>如果没有索引，也可以使用分区。<br><strong>分区条件必须是INT类型</strong></p><h3 id="COLUMNS分区"><a href="#COLUMNS分区" class="headerlink" title="COLUMNS分区"></a>COLUMNS分区</h3><p>• COLUMNS分区支持以下的数据类型：<br>• 所有的整型类型，如INT，SMALLINT，TINYINT，BIGINT。FLOAT和DECIMAL则不予支持<br>• 日期类型，如DATE和DATETIME。其余的日期类型不予支持<br>• 字符串类型，如CHAR, VARCHAR, BINARY, 和VARBINARY。BLOB和TEXT类型不予支持</p><pre><code class="sql">CREATE TABLE t_columns_range(a INT,b DATETIME)ENGINE=INNODBPARTITION BY RANGE COLUMNS (B)(PARTITION p0 VALUES LESS THAN (&#39;2009-01-01&#39;),PARTITION p1 VALUES LESS THAN (&#39;2010-01-01&#39;));</code></pre><h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><p>• 在分区的基础上再进行分区<br>• 也称为复合分区<br>• 允许在RANGE和LIST的分区上再进行HASH或者是KEY的子分区</p><pre><code class="sql">mysql&gt; CREATE TABLE ts (a INT, b DATE)engine=innodb-&gt; PARTITION BY RANGE( YEAR(b) )-&gt; SUBPARTITION BY HASH( TO_DAYS(b) )-&gt; SUBPARTITIONS 2 (-&gt; PARTITION p0 VALUES LESS THAN (1990),-&gt; PARTITION p1 VALUES LESS THAN (2000),-&gt; PARTITION p2 VALUES LESS THAN MAXVALUE-&gt; );Query OK, 0 rows affected (0.01 sec)</code></pre><h3 id="查询每个分区的记录数量"><a href="#查询每个分区的记录数量" class="headerlink" title="查询每个分区的记录数量"></a>查询每个分区的记录数量</h3><pre><code class="sql">SELECT PARTITION_NAME, TABLE_ROWSFROM INFORMATION_SCHEMA.PARTITIONSWHERE TABLE_NAME = &#39;XXX&#39;;</code></pre><h3 id="查看是否通过分区表进行查询"><a href="#查看是否通过分区表进行查询" class="headerlink" title="查看是否通过分区表进行查询"></a>查看是否通过分区表进行查询</h3><pre><code class="sql">mysql&gt; EXPLAIN PARTITIONS SELECT * FROM Profile WHERE id=1\G;*************************** 1. row ***************************id: 1select_type: SIMPLEtable: Profilepartitions: p1type: constpossible_keys: PRIMARYkey: PRIMARYkey_len: 4ref: constrows: 1Extra:1 row in set (0.00 sec)</code></pre><p>Q：分区能提高性能吗？</p><p>不要因为数据量大而作分区，要为提高性能而使用分区</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="undefined2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Int类型"><a href="#Int类型" class="headerlink" title="Int类型"></a>Int类型</h2><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/int%E7%B1%BB%E5%9E%8B.png" srcset="undefined" class="" title="int类型"><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>UNSIGNED/SIGNED<ul><li>是否有符号</li></ul></li><li>ZEROFILL<ul><li>填充0（例如：0001）</li><li>显式属性</li><li>只不做任何修改</li></ul></li><li>AUTO_INCREMENT<ul><li>自增</li><li>每张表一个</li><li>必须是索引的一部分</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>推荐不要使用UNSIGNED</li><li>范围本质上没有大的改变</li><li>UNSIGNED可能会有一处现象发生</li><li>自增INT类型逐渐建议使用BIGINT</li></ul><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>• 单精度类型：FLOAT<br>• 双精度类型：DOUBLE<br>    单精度类型和双精度类型精度较低，M*G/G不一定等于M<br>• 高精度类型：DECIMAL</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B.png" srcset="undefined" class="" title="数值类型"><p>财务系统必须用DECIMAL类型<br>FLOAT(M,D)/DOUBLE(M,D)/DECIMAL(M,D) 表示显示M位整数，其中D位位于小数点后面</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" srcset="undefined" class="" title="字符串类型"><p>BLOB =&gt; VARBINARY<br>TEXT =&gt; VARCHAR</p><ul><li>在BLOB和TEXT列上创建索引时，必须制定索引前缀的长度</li><li>VARCHAR和VARBINARY前缀长度是可选的。</li><li>BLOB和TEXT列不能有默认值</li><li>BLOB和TEXT列排序时只使用该列的前max_sort_length个字节</li></ul><pre><code class="sql">mysql &gt; select @@global.max_sort_length;+----------------------------------------+| @@global.max_sort_length |+----------------------------------------+| 1024 |+----------------------------------------+1 row in set (0.00 sec)</code></pre><h3 id="字符串类型——字符集"><a href="#字符串类型——字符集" class="headerlink" title="字符串类型——字符集"></a>字符串类型——字符集</h3><p>• character set<br>• a set of symbols and encodings.<br>• 常见字符集：utf8、utf8mb4、gbk，gb18030</p><h3 id="字符串类型——字符集的设置"><a href="#字符串类型——字符集的设置" class="headerlink" title="字符串类型——字符集的设置"></a>字符串类型——字符集的设置</h3><p>• 配置参数character_set_server<br>• CREATE DATABASE<br>• CREATE TABLE</p><pre><code class="sql">CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name[create_specification] ...create_specification:[DEFAULT] CHARACTER SET [=] charset_name| [DEFAULT] COLLATE [=] collation_nameCREATE TABLE t( a CHAR(10))CHARSET=utf8mb4;CREATE TABLE t (a VARCHAR(10) CHARSET gbk, b VARCHAR (10) CHARSET latin1, c VARCHAR (10) ) CHARSET=utf8mb4;</code></pre><h3 id="字符串类型——排序规则"><a href="#字符串类型——排序规则" class="headerlink" title="字符串类型——排序规则"></a>字符串类型——排序规则</h3><p>• collation<br>• set of rules for comparing characters in a character set</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99.png" srcset="undefined" class="" title="排序规则"><p>ci代表大小写不敏感</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E7%A7%8D%E7%B1%BB.png" srcset="undefined" class="" title="排序规则种类"><p>如果要设置为大小写敏感并且区分空格就设置为utf8mb4_bin</p><h3 id="字符串类型——ENUM-amp-SET"><a href="#字符串类型——ENUM-amp-SET" class="headerlink" title="字符串类型——ENUM &amp; SET"></a>字符串类型——ENUM &amp; SET</h3><p>• 字符串类型——集合类型<br>• ENUM类型最多允许65536个值<br>• SET类型最多允许64个值<br>• 通过sql_mode参数可以用于约束检查</p><pre><code class="sql">mysql&gt; CREATE TABLE t (-&gt; user VARCHAR(30),-&gt; sex ENUM(&#39;male&#39;,&#39;female&#39;)-&gt; )ENGINE=InnoDB;Query OK, 0 rows affected (0.01 sec)mysql&gt; SET SQL_MODE=&#39;strict_trans_tables&#39;;Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO t SELECT &#39;David&#39;,&#39;male&#39;;Query OK, 1 row affected (0.00 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; INSERT INTO t SELECT &#39;John&#39;,&#39;bimale&#39;; ERROR 1265 (01000): Data truncated for column &#39;sex&#39; at row 1</code></pre>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时数据区</title>
    <link href="undefined2020/04/25/%E5%90%8E%E7%AB%AF/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>2020/04/25/%E5%90%8E%E7%AB%AF/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><img src="/2020/04/25/%E5%90%8E%E7%AB%AF/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" srcset="undefined" class="" title="运行时数据区"><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中由一些会随着虚拟机启动而创建,随着虚拟机退出而销毁.另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁.<br>灰色的为单独线程私有的,红色的为多个线程共享的.即:</p><blockquote><p>每个线程:独立包括程序计数器、栈、本地栈<br>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</p></blockquote><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p></li><li><p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同事创建。Java线程执行终止后，本地线程也会回收。</li></ul></li><li><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</p></li><li><p>如果你是用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p><ul><li><strong>虚拟机线程：</strong>这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾手机，线程栈手机，线程挂起以及偏向所撤销。</li><li><strong>周期任务线程：</strong>这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li><strong>GC线程：</strong>这种线程对在JVM里不同种类的垃圾手机行为提供了支持。</li><li><strong>编译线程：</strong>这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程：</strong>这种线程接收信号兵发送给JCM，在它内部通过调用适当的方法进行处理。</li></ul></li></ul><h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a>程序计数器（PC寄存器）</h2><p>JVM中的程序计数寄存器中，Register的命名源于CPU的寄存器，寄存器存储指令相关的线程信息。CPU只有把数据庄仔倒寄存器才能够运行。<br>这里，并非是广义上所指的物理寄存器，获取将其翻译为PC计数器（或指令计数器）会更加贴切（也成为了程序钩子），并且也不容易引起一些不必要的误会。JVM中PC寄存器是对物理PC寄存器的一种抽象模拟。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。有执行引擎读取下一条指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p>使用PC寄存器存储字节码指令地址有什么用呢？<br> 为什么使用PC寄存器记录当前线程的执行地址呢？</p><p> 因为CPU需要不停地切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br> JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p></li><li><p>PC寄存器为什么会被设定为线程私有？</p><p> 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致进场中断或回复，如何保证分好无差呢？<strong>为了能够准确地记录哥哥线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来哥哥线程之间便可以进行独立计算，从而不会出现相互干扰的情况。<br> 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个 内核，只会执行某个线程中的一条指令。<br> 这样必然导致经常中断或回复，如何保证分毫不差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在哥哥线程之间互不影响</p></li></ol><h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。<br>在宏观上:我们可以同时打开多个应用程序，每个程序并行，同时运行<br>但在微观上:由于只有一个CPPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><p>栈式运行时的单位，而堆时存储的单位。</p><p>即：栈解决程序的运行问题，何须如何执行，或者说如何处理数据。<br>堆解决的时数据存储的问题，即数据怎么放、放在哪儿。</p><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li>Java虚拟机栈式什么？<br>Java虚拟机栈，早起也叫Java栈。没干过线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用。<ul><li>是线程私有的</li></ul></li><li>生命周期和线程一直</li><li>作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li></ul><h3 id="栈的优点"><a href="#栈的优点" class="headerlink" title="栈的优点"></a>栈的优点</h3><ul><li>栈式一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个：<ul><li>每个方法执行，伴随着进栈</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题</li></ul><h3 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h3><ul><li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会跑出一个StackOverflowError异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会派出一个OutOfMemoryError异常</li></ul></li></ul><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><h4 id="栈中存储什么"><a href="#栈中存储什么" class="headerlink" title="栈中存储什么"></a>栈中存储什么</h4><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧的格式存在。</li><li>在这个线程上正在执行的每个方法都各子对应一个栈帧</li><li>栈帧时一个内存区块，是一个数据集，维系着方法执行过程种的各种数据信息。</li></ul><h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循现金后厨/后进先出原则</li><li>在一条活动线程种，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果在该方法种调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</li><li>不同线程中锁包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态连接</li><li>方法返回地址</li><li>一些附加信息</li></ul><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference）、以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li><strong>局部变量表所需的容量大小是在编译器确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数有栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表碰撞，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li><li>局部变量表中的变量旨在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul><h5 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h5><ul><li>参数值是放在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元时Slot（变量槽）</strong></li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。<ul><li>byte、shot、char在存储前被转换为int，boolean也被转换位int，0表示false，非0表示true。</li><li>long和doubele则占据两个Slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都非陪一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</li><li>如果需要访问局部变量表中的一个64bit的局部变量值时，只需要使用前一个索引即可。（比如访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><pre><code class="java">因此这也接释了为什么静态方法中无法引用this的原因，因为当前方法的局部变量表中没有this变量，只有构造方法和普通的实例方法才可以public static void jingtai(){  this.count;这是错误的！！！！}</code></pre><h6 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h6><p><strong>栈帧中的局部变量表中的槽位时可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><pre><code class="java">public void local(){  int a = 0;  {    int b = 0;    b = a+1;  }  // 变量c在使用之前已经销毁的变量b占据的slot的位置  int c = a+1;}</code></pre><img src="/2020/04/25/%E5%90%8E%E7%AB%AF/Java/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/slot%E7%9A%84%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8.png" srcset="undefined" class="" title="slot的重复利用"><h4 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h4><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li><li>我们直到类变量表有两次初始化的机会，第一次是在准备阶段，执行系统初始化，对类变量设置零值，另一次则是再初始化阶段，付妤程序员再代码中定义的初始值。</li><li>和类比哪里初始化不同的是，局部比哪里表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ul><pre><code class="java">变量得分类：按照数据类型分：1.基本数据类型 2.引用数据类型            按照在类中声明的位置分：1 成员变量：在使用前，都经历过默认初始化赋值                                            类变量：lingking得prepare阶段：给类变量默认赋值---&gt;initial阶段：给类变量显示赋值即静态代码块赋值                                            实例变量：随着对象得创建，会在堆空间中分配实例变量空间，并进行默认赋值                                  2 局部变量：在使用前，必须要进行显示赋值得！否则，编译不通过</code></pre><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>在栈帧中，与性能调优关系最为密切得部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以称之为表达式栈</li><li>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈/出栈<ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul><blockquote><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p></blockquote><ul><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这个方法的操作数栈时空的</strong></li><li>每个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值。</li><li>栈中的任何一个元素都是可以存放任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据刘分析阶段要再次验证。</li><li>另外，我们说Java虚拟机的接释引擎时基于栈的执行引擎，其中的栈值得就是操作数栈。</li></ul><h3 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h3><p>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低堆内存的读/写次数，提升执行引擎的执行效率。</p><h2 id="动态链接（或指向运行时常量池的方法引用）"><a href="#动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="动态链接（或指向运行时常量池的方法引用）"></a>动态链接（或指向运行时常量池的方法引用）</h2><ul><li>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码额能够实现动态连接</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li></ul><p>为什么需要常量池呢？</p><p>常量池的作用就是为了提供一些符号和常量，便于指令的识别。</p><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li>静态链接：<br>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li>动态链接：<br>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul><p>对应的方法的绑定机制为：早期绑定和晚期绑定，早期绑定和静态链接是对应的，晚期绑定和动态链接是对应的。绑定时一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li>早期绑定：<br>早期绑定就是指被调用的目标方法如果在编译器可知，且运行器保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟时哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li>晚期绑定<br>如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据时机的类型绑定相关的方法，这种绑定的方式也就被称之为晚期绑定。</li></ul><pre><code class="java">/** * @Description TODO 说明早期绑定和晚期绑定的例子 * @Author Matthew * @Date 2020/4/30 12:52 * @Version 1.0 */class Animal {    public Integer eat() {        System.out.println(&quot;动物进食&quot;);        return 1;    }}interface Huntable{    void hunt();}class Dog extends Animal implements Huntable {    @Override    public Integer eat() {        System.out.println(&quot;狗吃骨头&quot;);        return 2;    }    @Override    public void hunt() {        System.out.println(&quot;捕食耗子，多管闲事&quot;);    }}class Cat extends Animal implements Huntable {    public Cat() {        super();//表现为早期绑定    }    @Override    public Integer eat() {        super.eat();        System.out.println(&quot;猫吃鱼&quot;);        return 3;    }    @Override    public void hunt() {        System.out.println(&quot;捕食耗子，天经地义&quot;);    }}public class AnimalTest{    public void showAnimal(Animal animal) {        Integer eat = animal.eat();//表现为晚期绑定        System.out.println(eat);    }    public void showHunt(Huntable huntable) {        huntable.hunt();//表现为晚期绑定    }    public static void main(String[] args) {        AnimalTest animalTest = new AnimalTest();        animalTest.showAnimal(new Cat());    }}</code></pre><h3 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h3><p>非虚方法</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的，这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法成为虚方法。</li></ul><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li>普通调用指令：<ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法，除final外</li><li>invokeinterface：调用所有接口方法</li></ol></li><li>动态调用指令<ol start="5"><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ol></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h3 id="方法的调用：关于invokeddynamic指令"><a href="#方法的调用：关于invokeddynamic指令" class="headerlink" title="方法的调用：关于invokeddynamic指令"></a>方法的调用：关于invokeddynamic指令</h3><ul><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokeddynamic指令，这是<strong>Java为了实现【动态类型语言】支持而做的一种改进。</strong></li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。<strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></li></ul><h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><blockquote><p>对于类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言</p></blockquote><h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><p>Java语言中方法重写的本质：</p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程而技术；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li></ol><h4 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h4><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问，一般的这个会引起编译器异常。这个错误如果放生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ul><li>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此，<strong>为了提高性能</strong>，JVM采用在类的方法区建立一个虚方法表（Virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li><li>每个来中都有uige虚方法表，表中存放着各个方法的实际入口</li><li>那么虚方法表什么时候被创建？<br>虚方法表会在类加载的连接阶段被常见并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li></ul><h2 id="方法返回地址-return-address"><a href="#方法返回地址-return-address" class="headerlink" title="方法返回地址(return address)"></a>方法返回地址(return address)</h2><ul><li>存放调用该方法的PC寄存器的值</li><li>一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过一场表来确定，栈帧中一班不会保存这部分信息。</li></ul><blockquote><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、shezhiPC寄存器值等，让调用者方法继续执行下去。<br>正常完成处库和一场完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></blockquote><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="举例栈逸出的情况"><a href="#举例栈逸出的情况" class="headerlink" title="举例栈逸出的情况"></a>举例栈逸出的情况</h3><p>StackOverflowError<br>通过-Xss设置栈的大小；OOM</p><h3 id="调整栈大小，就能保证不出现溢出么"><a href="#调整栈大小，就能保证不出现溢出么" class="headerlink" title="调整栈大小，就能保证不出现溢出么"></a>调整栈大小，就能保证不出现溢出么</h3><p>不能</p><h3 id="分配的栈内存越大越好么"><a href="#分配的栈内存越大越好么" class="headerlink" title="分配的栈内存越大越好么"></a>分配的栈内存越大越好么</h3><p>不是，因为整个空间是有限的，栈的空间越大就会挤占其他资源的空间</p><h3 id="垃圾回收是否会涉及到虚拟机栈"><a href="#垃圾回收是否会涉及到虚拟机栈" class="headerlink" title="垃圾回收是否会涉及到虚拟机栈"></a>垃圾回收是否会涉及到虚拟机栈</h3><p>不会的，<br>程序计数器不存在Error和GC<br>虚拟机栈存在Error不存在GC<br>本地方法栈同上<br>方法区和堆存在Error也存在GC</p><h3 id="方法中定义的局部变量是否线程安全"><a href="#方法中定义的局部变量是否线程安全" class="headerlink" title="方法中定义的局部变量是否线程安全"></a>方法中定义的局部变量是否线程安全</h3><p>当这个变量可以被两个线程同时操作的时候，线程就是不安全的，如果只在这个线程自己的局部变量表中存在那么就是安全的。<br>例如：将这个局部变量作为返回值返回时，多个线程争抢可能会出现线程不安全问题。<br>只有这个变量在这个方法中产生并消亡，才是线程安全的。</p><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><h3 id="什么是本地方法"><a href="#什么是本地方法" class="headerlink" title="什么是本地方法"></a>什么是本地方法</h3><p>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern“C”告知C++编译器去调用一个C的函数。<br>本地接口的作用是融合不同的编程语言为Java所用，他的初衷是融合C/C++程序。</p><h3 id="为什么要使用Native-Method"><a href="#为什么要使用Native-Method" class="headerlink" title="为什么要使用Native Method"></a>为什么要使用Native Method</h3><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li>与Java环境外交互<br><strong>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法证实这一一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li><li>与操作系统交互<br>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统长城是强大的操作系统。**通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li><li>Sun’s Java<br><strong>Sun的解释器时用C实现的，这使得他能像一些普通的C一样与外部交互。</strong>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。录入：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0().这个本地方法是yogaC实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库提供，然后被JVM调用。</li></ul><h4 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h4><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生成设备，在企业级应用中已经比较少见。因为现状的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><ul><li>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</li><li>本地方法栈，也是线程私有的。</li><li>允许被是县城固定或者是可动态扩展的内存大小。（内存溢出方面是相同的）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会跑出一个StackOverflowError异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</li></ul></li><li>本地方法是使用C语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</li><li><strong>当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong><ul><li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区。</strong></li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul></li><li><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</strong>如果JVM产品不打算支持native方法，也可以无需事先本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载子系统</title>
    <link href="undefined2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><img src="/2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="undefined" class="" title="内存图"><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类加载子系统的作用"><a href="#类加载子系统的作用" class="headerlink" title="类加载子系统的作用"></a>类加载子系统的作用</h3><img src="/2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F.png" srcset="undefined" class="" title="类加载子系统.png"><ul><li>类加载子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件表示</li><li>ClassLoader治负责class文件的加载，至于它是否可以运行则由Execution Engine决定。</li><li>加载的类信息存放于一块成为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串紫米那里和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li></ol><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>验证（Verify）：</p><ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机的要求，保证加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul><p>准备（Prepare）：</p><ul><li>为类变了分配内存并且设置该类变了的默认初始值，即零值。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li><li>这里不会为实例变量分配初始化，类变了会分配在方法区中，而实例变量实惠随着对象一起分配到Java堆中。</li></ul><p>解析（Resolve）：</p><ul><li>将常量池内的符号引用转换为直接引用的过场。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li>&lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM会保证子类的&lt;clinit&gt;执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><ul><li>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader).</li><li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li><li>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：<img src="/2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB.png" srcset="undefined" class="" title="类加载器的分类">这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</li></ul><pre><code class="java">public class ClassLoaderTest {    public static void main(String[] args) {        // 获取系统类加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2        // 获取其上层：扩展类加载器        ClassLoader extClassLoader = systemClassLoader.getParent();        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@355da254        //获取其上层:获取不到引导类加载器        ClassLoader bootstrapClassLoader = extClassLoader.getParent();        System.out.println(bootstrapClassLoader);//null        //对于用户自定义类来说        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2        //String类使用引导类加载器进行加载的。---&gt;Java的核心类库都是使用引导类加载器进行加载的        ClassLoader classLoader1 = String.class.getClassLoader();        System.out.println(classLoader1);//null    }}</code></pre><p>用户是无法获取到BootStrap类加载器的。</p><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a>启动类加载器（引导类加载器，Bootstrap ClassLoader）</h4><ul><li>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</li><li>他用来加载Java的核心库（Java_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader,没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><h4 id="扩展类加载器（Extension-CLassLoader）"><a href="#扩展类加载器（Extension-CLassLoader）" class="headerlink" title="扩展类加载器（Extension CLassLoader）"></a>扩展类加载器（Extension CLassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于CLassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR方在此目录下，也会自动由扩展类加载器加载。</li></ul><h4 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a>应用程序类加载器（系统类加载器，AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>派生于CLassLoader类</li><li>父类加载器为扩展类加载器</li><li>他负责家在环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p><h4 id="为什么要自定义类加载器"><a href="#为什么要自定义类加载器" class="headerlink" title="为什么要自定义类加载器"></a>为什么要自定义类加载器</h4><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止远吗泄漏</li></ul><h4 id="用户自定义类加载器实现步骤"><a href="#用户自定义类加载器实现步骤" class="headerlink" title="用户自定义类加载器实现步骤"></a>用户自定义类加载器实现步骤</h4><ol><li>开发人员可以通过集成抽象类java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去集成ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去fugailoadClass()方法，而是建议把自定义的类加载逻辑卸载findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接集成URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java虚拟机对class文件采用的时按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，阿Java虚拟机采用的是双亲微拍模式，即吧请求交由父类处理，他是一种任务委派模式。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向还是那个委托，一次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。<img src="/2020/04/24/%E5%90%8E%E7%AB%AF/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" srcset="undefined" class="" title="双亲委派机制"></li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API呗随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart</li></ul></li></ul><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class),报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是杀向安全机制</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul></li><li><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不想等的。</p></li></ul><blockquote><p>JVM必须直到一个类型是由启动类加载器还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p></blockquote><p>Java程序对类的使用方式分为:主动使用和被动使用.</p><ul><li><p>主动使用,又分为七种情况:</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量,或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(比如:Class.forName(“String”))</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持:<br>java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul></li><li><p>除了以上七种情况，其他适用Java类的方式都被看做是对类的被动使用，都不会道指累的初始化。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM与Java体系结构</title>
    <link href="undefined2020/04/21/%E5%90%8E%E7%AB%AF/Java/JVM/JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>2020/04/21/%E5%90%8E%E7%AB%AF/Java/JVM/JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><img src="/2020/04/21/%E5%90%8E%E7%AB%AF/Java/JVM/JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/JVM%E4%BD%8D%E7%BD%AE.png" srcset="undefined" class="" title="JVM位置"><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</p><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一</p><p>它采用解释器与即时编译器并存的架构。<br>在今天，Java程序的云心性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</p><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于<strong>栈的指令集架构</strong>，另外一种指令集结构则是基于<strong>寄存器的指令集架构</strong>。</p><p>具体来说：这两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题，使用领地址指令方式分配。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是x86的二进制指令集:比如传统的PC以及Android的Davlik虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效；</li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以领地址指令为主。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的。</strong>不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，变异器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的寄主环境已经不局限于嵌入式平台了），那么为什么不降架构更换为基于寄存器的架构呢？</p><blockquote><p>栈：跨平台性、指令集小、指令多；执行性能比寄存器差</p></blockquote><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java下虚拟机的启动时通过引导类加载器（bootstap class loader）创建一个初始类（initial class）来完成的，这个类时由虚拟机的具体实现制定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li>执行一个所谓的Java程序的时候，真真正正在执行的时一个叫做Java虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某现场调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高性能缓存</title>
    <link href="undefined2020/04/20/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/"/>
    <url>2020/04/20/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="最简单缓存入手————HashMap"><a href="#最简单缓存入手————HashMap" class="headerlink" title="最简单缓存入手————HashMap"></a>最简单缓存入手————HashMap</h2><h2 id="并发安全要保证————用synchronized实现"><a href="#并发安全要保证————用synchronized实现" class="headerlink" title="并发安全要保证————用synchronized实现"></a>并发安全要保证————用synchronized实现</h2><ul><li>性能差</li><li>代码复用能力差</li></ul><h2 id="给HashMap加final关键字"><a href="#给HashMap加final关键字" class="headerlink" title="给HashMap加final关键字"></a>给HashMap加final关键字</h2><ul><li>属性被声明为final后，该变量则只能被复制一次，且一旦被复制，final的百年来就不能再被改变。</li><li>所以我们把它加上final关键字，增强安全性。</li></ul><h2 id="代码有重构空间————用装饰者模式"><a href="#代码有重构空间————用装饰者模式" class="headerlink" title="代码有重构空间————用装饰者模式"></a>代码有重构空间————用装饰者模式</h2><ul><li>我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情</li><li>缺点<ul><li>性能差</li><li>当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差</li></ul></li></ul><h2 id="性能待优化————引出锁性能优化经验：缩小锁的粒度"><a href="#性能待优化————引出锁性能优化经验：缩小锁的粒度" class="headerlink" title="性能待优化————引出锁性能优化经验：缩小锁的粒度"></a>性能待优化————引出锁性能优化经验：缩小锁的粒度</h2><ul><li>虽然提高了并发效率，但是并不意味着就是线程安全的，还需要考虑到同时读写等情况</li><li>但是起始没必要自己实现线程安全的HashMap，也不应该加synchronized，因为我们自己实现的性能远不如现有的并发集合</li><li>我们来使用ConcurrentHashMap优化我们的缓存</li></ul><h3 id="用并发集合————ConcurrentHashMap"><a href="#用并发集合————ConcurrentHashMap" class="headerlink" title="用并发集合————ConcurrentHashMap"></a>用并发集合————ConcurrentHashMap</h3><ul><li>缺点：在计算完成前，另一个要求计算相同值得请求到来，会导致计算两遍，这和缓存想避免多次计算得初衷恰恰相反，是不可接受的</li></ul><h4 id="避免重复计算————Future和Callable的妙用"><a href="#避免重复计算————Future和Callable的妙用" class="headerlink" title="避免重复计算————Future和Callable的妙用"></a>避免重复计算————Future和Callable的妙用</h4><ul><li>动机：现在不同的线程进来以后，确实可以同时计算，但是如果两个线程前脚后，也就是相差无几的进来请求同一个数据，那么我们来看看会出现什么问题：重复计算</li><li>这个例子只有2个线程，并不可怕，但是如果是100个线程都请求同样的内容，却都需要重新计算，那么会造成巨大的浪费</li></ul><h4 id="依然存在重复的可能————用原子操作putIfAbsent"><a href="#依然存在重复的可能————用原子操作putIfAbsent" class="headerlink" title="依然存在重复的可能————用原子操作putIfAbsent"></a>依然存在重复的可能————用原子操作putIfAbsent</h4><ul><li>如果有两个同时计算666的线程，同时调用cache.get方法，那么返回的结果都为null，后面还是会创建两个任务去计算相同的值<img src="/2020/04/20/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98/%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97.png" srcset="undefined" class="" title="重复计算"></li></ul><pre><code class="java">@Override    public V compute(A arg) throws Exception {        Future&lt;V&gt; future = cache.get(arg);        if (future == null) {            Callable&lt;V&gt; callable = () -&gt; c.compute(arg);            FutureTask&lt;V&gt; futureTask = new FutureTask&lt;&gt;(callable);            // putIfAbsent往里放，如果不存在就放入，并返回之前的value，因为初始arg为null所以就进行计算            // 如果有值就会返回之前放过的值            future = cache.putIfAbsent(arg, futureTask);            if (future == null) {                future = futureTask;                System.out.println(&quot;从Future调用了计算函数&quot;);                futureTask.run();            }        }        return future.get();    }</code></pre><h2 id="计算中抛出异常————ExcecutionException"><a href="#计算中抛出异常————ExcecutionException" class="headerlink" title="计算中抛出异常————ExcecutionException"></a>计算中抛出异常————ExcecutionException</h2><ul><li>这3种异常之所以用不同的catch块捕获，是因为它们的处理逻辑是不同的<ul><li>CancellationException和InterruptedException是人为取消的，那么我们应该立即终止任务</li><li>但是如果是计算错误，且我们明确直到多试几次就可以得到答案，那么我们的逻辑应该是重试，尝试多次直到正确的结果出现</li><li>在这里，我们加上while(true)来保证计算错误不会影响我们的逻辑，然后如果是计算错误，就进入下一个循环，重新计算，直到计算成功；如果是人为取消，那么就抛出异常然后结束运行</li></ul></li></ul><h2 id="高并发访问时"><a href="#高并发访问时" class="headerlink" title="高并发访问时"></a>高并发访问时</h2><ul><li>如果同时过期，那么同时都拿不到缓存，导致打爆CPU和MySQL，造成缓存雪崩，缓存击穿等高并发下的缓存问题</li><li>想测并发性能，所有线程同时访问缓存<ul><li>前一个类存在一个问题，就是大量的请求实际上不是同时到达的，而是分先后，但是这样就没办法给缓存造成压力，我们需要真正的同一时刻大量请求到达，此时可以用CountDownLatch来实现</li></ul></li></ul><pre><code class="java">package MultithReading.imoocacache;import MultithReading.imoocacache.computeble.ExpensiveFunction;import java.text.SimpleDateFormat;import java.util.Date;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Description TODO * @Author Matthew * @Date 2020/4/20 21:40 * @Version 1.0 */public class ImoocCache7 {    static ImoocCache6&lt;String, Integer&gt; expensiveComputer = new ImoocCache6&lt;&gt;(new ExpensiveFunction());    public static CountDownLatch countDownLatch = new CountDownLatch(1);    public static void main(String[] args) throws InterruptedException {        long start = System.currentTimeMillis();        ExecutorService service = Executors.newFixedThreadPool(10000);        for (int i = 0; i &lt; 10000; i++) {            service.submit(() -&gt; {                    Integer result = null;                try {                    System.out.println(Thread.currentThread() + &quot;开始等待&quot;);                    countDownLatch.await();                    SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormat.get();                    String format = dateFormat.format(new Date());                    System.out.println(Thread.currentThread() +&quot;--&quot;+ format+&quot;被放行&quot;);                    result = expensiveComputer.compute(&quot;666&quot;);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(result);            });        }        Thread.sleep(5000);        countDownLatch.countDown();        service.shutdown();//        service.shutdown();//        while (!service.isTerminated()) {//        }        System.out.println(&quot;总耗时：&quot;+ (System.currentTimeMillis()-start));    }}class ThreadSafeFormatter {    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormat = new ThreadLocal&lt;SimpleDateFormat&gt;(){        @Override        protected SimpleDateFormat initialValue() {            return new SimpleDateFormat(&quot;mm:ss&quot;);        }        @Override        public SimpleDateFormat get() {            return super.get();        }    };}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Future和Callable</title>
    <link href="undefined2020/04/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Future%E5%92%8CCallable/"/>
    <url>2020/04/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Future%E5%92%8CCallable/</url>
    
    <content type="html"><![CDATA[<h2 id="Runnable的缺陷"><a href="#Runnable的缺陷" class="headerlink" title="Runnable的缺陷"></a>Runnable的缺陷</h2><ul><li>不能返回一个返回值</li><li>不能抛出checked Exception</li></ul><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>类似于Runnable，被其他线程执行的任务</p><ul><li>实现call方法</li><li>有返回值</li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><h3 id="主要方法：一共5个"><a href="#主要方法：一共5个" class="headerlink" title="主要方法：一共5个"></a>主要方法：一共5个</h3><h4 id="get-方法：获取结果"><a href="#get-方法：获取结果" class="headerlink" title="get()方法：获取结果"></a>get()方法：获取结果</h4><p>get方法的行为取决于Callable任务的状态，只有以下这5种情况：</p><ol><li>任务正常完成：get方法回立刻返回结果</li><li>任务尚未完成（任务还没开始或进行中）：get将阻塞并直到任务完成</li><li>任务执行过程中抛出Exception：get方法回抛出ExecutionException：这里的抛出异常，是call()执行时产生的那个异常，看到这个异常类型时java.util.concurrent.ExecutionException。不论call()执行时抛出的异常类型时什么，最后get方法抛出的异常类型都是ExecutionException。</li><li>任务呗取消：get方法会抛出CancellationException</li><li>任务超时：get方法有一个重载方法，时传入一共延迟时间的，如果时间到了还没有获得结果，get方法就会抛出TimeoutException。</li></ol><h5 id="get-long-timeout-TimeUnit-unit-有超时的获取"><a href="#get-long-timeout-TimeUnit-unit-有超时的获取" class="headerlink" title="get(long timeout,TimeUnit unit):有超时的获取"></a>get(long timeout,TimeUnit unit):有超时的获取</h5><ul><li>超时的需求很常见</li><li>用get(long timeout,TimeUnit unit)方法时，如果call()在规定时间内完成了任务，那么就会正常获取到返回值；而如果再指定时间内没有计算除结果，那么就会抛出TimeoutException</li><li>超时不获取，任务需取消</li></ul><h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><ul><li>取消任务的执行</li></ul><ol><li>如果这个任务开没有开始执行，那么这种情况最简单，任务会被正常的取消，未来也不会被执行，方法返回true</li><li>如果任务已完成，或者已取消，那么cancel()方法会执行失败，返回false。</li><li>如果这个任务已经开始执行了，那么这个取消方法将不会执行取消该任务，而是会根据我们填的参数mayInterruptIfRunning做判断</li></ol><p>Future.cancel(true)适用于：<br>1.任务能够处理interrupt</p><p>Future.cancel(false)仅用于避免启动尚未启动的任务，适用于:</p><p>1.未能处理interrupt的任务<br>2.不清楚任务是否支持取消<br>3.需要等待已经开始的任务执行完成</p><h4 id="isDone方法"><a href="#isDone方法" class="headerlink" title="isDone方法"></a>isDone方法</h4><ul><li>isDone()方法：判断线程是否执行完毕</li></ul><h4 id="isCancelled-方法"><a href="#isCancelled-方法" class="headerlink" title="isCancelled()方法"></a>isCancelled()方法</h4><ul><li>isCancelled方法：判断是否被取消</li></ul><h3 id="用法2：用FutureTask来创建Future"><a href="#用法2：用FutureTask来创建Future" class="headerlink" title="用法2：用FutureTask来创建Future"></a>用法2：用FutureTask来创建Future</h3><ul><li>用FutureTask来获取Future和任务的结果</li><li>FutureTask是一种包装器，可以把Callable转化成Future和Runnable，它同时实现二者的接口</li><li>所以它既可以作为Runnable被线程执行，而可以作为Future得到Callable的返回值</li><li>把Callable实例当作参数，生成FutureTask的对象，然后把这个对象当作一共Runnable对象，用线程池或另起线程去执行这个Runnable对象，最后通过FututreTask获取刚才执行的结果</li></ul><h3 id="Future的注意点"><a href="#Future的注意点" class="headerlink" title="Future的注意点"></a>Future的注意点</h3><ul><li>当for循环批量获取future的结果时，容易发生一部分线程很慢的情况，get方法调用时应使用timeout限制</li><li>Future的生命周期不能后退<ul><li>声明周期只能前进，不能后退。就和线程池的生命周期一样，一旦完全完成了任务，他就永久停在了已完成的状态，不能重头再来。</li></ul></li></ul><h2 id="Callable和Future的关系"><a href="#Callable和Future的关系" class="headerlink" title="Callable和Future的关系"></a>Callable和Future的关系</h2><ul><li>我们可以用Future.get来获取Callable接口返回的执行结果，还可以通过Future.isDone()来判断任务是否已经执行完了，以及取消这个任务，显示获取任务的结果等</li><li>在call()未执行完毕之前，调用get()的线程（假定此时是主线程)会被阻塞，直到call()方法返回了结果后，此时future.get()才会得到该结果，然后主线程才会切换到runnable状态</li><li>所以Future是一个存储器，它存储了call()这个任务的结果，而这个任务的执行时间是无法提前确定的，因为这完全取决与call()方法执行的情况</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="undefined2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/"/>
    <url>2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/</url>
    
    <content type="html"><![CDATA[<h2 id="学习AQS的思路"><a href="#学习AQS的思路" class="headerlink" title="学习AQS的思路"></a>学习AQS的思路</h2><ul><li>学习AQS的目的主要是想理解原理、提高技术、以及应对面试</li><li>先从应用层面理解为什么需要他如何使用它，然后再看一看我们Java代码的设计者是如何使用它的了解它的应用场景</li><li>这样之后我们再去分析它的结构，这样的话我们就学习得更加轻松了</li></ul><h2 id="为什么需要AQS"><a href="#为什么需要AQS" class="headerlink" title="为什么需要AQS"></a>为什么需要AQS</h2><ul><li>锁和协作类有共同点：闸门<ul><li>我们已经学过了ReentrantLock和Semaphore，有没有发现他们有共同点？很相似?</li><li>事实上，不仅是ReentrantLock和Semaphore，包括CountDownLatch、ReentrantReadWriteLock都有这样类似得协作（或叫同步）功能，起始他们底层都用了一个共同得基类，这就是AQS</li></ul></li><li>因为上面得那些协作类，它们有很多工作都是类似得，所以如果能提取出一个工具类，那么就可以直接用，对于ReentrantLock和Semaphore而言就可以屏蔽很多细节，只关注它们自己得“业务逻辑”就可以了</li></ul><h2 id="Semaphore和AQS得关系"><a href="#Semaphore和AQS得关系" class="headerlink" title="Semaphore和AQS得关系"></a>Semaphore和AQS得关系</h2><ul><li>Semaphore内部有一个Sync类，Sync类继承了AQS</li><li>CountDownLatch也是一样的</li></ul><h2 id="如果没有AQS"><a href="#如果没有AQS" class="headerlink" title="如果没有AQS"></a>如果没有AQS</h2><ul><li><p>就需要每个协作工具自己实现：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞与解除阻塞</li><li>队列的管理</li></ul></li><li><p>在并发场景下，自己正确且高效实现这些内容，是相当有难度的，所以我们用AQS来帮我们把这些脏活累活都搞定，我们只关注业务逻辑就够了</p></li></ul><h2 id="AQS的作用"><a href="#AQS的作用" class="headerlink" title="AQS的作用"></a>AQS的作用</h2><ul><li>AQS是一个用于构建锁、同步器、协作工具类的工具类（框架）。有了AQS以后，更多的协作工具类都可以很方便被写出阿里</li><li>一句话总结：有了AQS，构建线程协作类就容易多了</li></ul><h2 id="AQS的重要性、地位"><a href="#AQS的重要性、地位" class="headerlink" title="AQS的重要性、地位"></a>AQS的重要性、地位</h2><ul><li>AbstractQueuedSynchronizer是Doug Lea写的，从JDK1.5加入的一个基于FIFO等待队列实现的一个用于实现同步器的基础框架。</li></ul><h2 id="AQS内部原理解析"><a href="#AQS内部原理解析" class="headerlink" title="AQS内部原理解析"></a>AQS内部原理解析</h2><ul><li>AQS最核心的就是三大部分:<ul><li>state</li><li>控制线程抢锁和配合的FIFO队列</li><li>期望协作公爵类去实现的获取/释放等重要方法</li></ul></li></ul><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><ul><li>这里的state的具体含义，会根据具体是实现类的不同而不同，比如在Semaphore里，它表示“剩余的许可证数量”，而在CountDownLatch里，它表示“还需要倒数的数量”</li><li>stae是volatile修饰的，会被并发地修改，所以所有修改state的方法都需要保证线程安全，比如getState、setState以及compareAndSetState操作来读取和更新这个状态。这些方法都依赖于j.u.catomic包的支持</li><li>在ReentrantLock中</li><li>state用来表示“锁”的占有情况，包括可重入计数</li><li>当state的值为0的时候，标识改Lock不被任何线程所占有</li></ul><h3 id="控制线程抢锁和配合的FIFO队列"><a href="#控制线程抢锁和配合的FIFO队列" class="headerlink" title="控制线程抢锁和配合的FIFO队列"></a>控制线程抢锁和配合的FIFO队列</h3><ul><li>这个队列用来存放“等待的线程”，AQS就是排队管理器，当多个线程正用同意把锁时，必须有排队机制将那些没能拿到锁的线程串在一起。当锁释放时，锁管理器就会挑选一个合适的线程来占有这个刚刚释放的锁</li><li>AQS会维护一个等待的线程队列，把线程都放到这个队列里</li><li>这是一个双向形式的队列<img src="/2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS/%E9%98%9F%E5%88%97.png" srcset="undefined" class="" title="队列"></li></ul><h3 id="期望协作工具类去实现的获取-释放等重要方法"><a href="#期望协作工具类去实现的获取-释放等重要方法" class="headerlink" title="期望协作工具类去实现的获取/释放等重要方法"></a>期望协作工具类去实现的获取/释放等重要方法</h3><ul><li>这里的获取和释放方法，时利用AQS的协作工具类里最重要的方法，时由协作类自己去实现的，并且含义各不相同</li></ul><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ul><li>获取操作会依赖state变量，经常会阻塞（比如获取不到锁的时候）</li><li>在Semaphore中，获取就是acquire方法，作用时获取一个许可证</li><li>而在CountDownLatch里面，获取就是await方法，作用时“等待，直到倒数结束”</li></ul><h4 id="释放方法"><a href="#释放方法" class="headerlink" title="释放方法"></a>释放方法</h4><ul><li>释放操作不会阻塞</li><li>在Semaphore中，释放就是release方法，作用时释放一个许可证</li><li>CountDownLatch里面，获取就是countDown方法，作用式“倒数1个数”</li></ul><h2 id="AQS用法"><a href="#AQS用法" class="headerlink" title="AQS用法"></a>AQS用法</h2><ol><li>写一个类，想好协作的逻辑，实现获取/释放方法。</li><li>内部写一个Sync类继承AbstractQueuedSynchronizer</li><li>根据是否独占来重写tryAcquire/tryReleasehuo tryAcquireShared(int acquires)和tryReleaseShared（int releases）等方法，在之前写的获取/释放方法中调用AQS的acquire/release或者Shared方法</li></ol><h3 id="CountDownLatch源码分析"><a href="#CountDownLatch源码分析" class="headerlink" title="CountDownLatch源码分析"></a>CountDownLatch源码分析</h3><ol><li>内部类Sync继承AQS</li><li>调用CountDownLatch的await方法时，便会尝试获取共享锁，不过一开始时获取不到该锁的，于是线程被阻塞</li><li>而共享锁可获取到的条件，就是锁计数器的值为0</li><li>而锁计数器的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将锁计数器-1</li><li>count个线程调用countDown()之后，锁计数器才为0，而前面提到的等待获取共享锁的线程才能继续运行。</li></ol><h3 id="AQS在Semaphore的应用"><a href="#AQS在Semaphore的应用" class="headerlink" title="AQS在Semaphore的应用"></a>AQS在Semaphore的应用</h3><ul><li>在Semaphore中，state表示许可证的剩余数量</li><li>看tryAcquire方法，判断nonfairTryAcquireShared大于等于0的话，代表成功</li><li>这里会先检查剩余许可证数量够不够这次需要的，用减法来计算，如果直接不够，那就返回负数，表示失败，如果够了，就用自旋加compareAndSetState来改变state状态，直到改变成功就返回正数；或者时期间如果被其他人修改了导致剩余数量不够了，那也返回负数代表获取失败</li><li>分析释放锁的方法tryRelease<ul><li>由于时可重入的，所以state代表重入的次数，每次释放锁，先判断是不是当前持有锁的线程释放的，如果不是就抛异常如果是的话，重入次数就减一，如果减到了0，就说明完全释放了，于是free就是true，并且把state设置0</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发流程</title>
    <link href="undefined2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是控制并发流程"><a href="#什么是控制并发流程" class="headerlink" title="什么是控制并发流程"></a>什么是控制并发流程</h2><ul><li>控制并发流程的工具类，作用就是帮助我们程序眼更容易得让线程之间合作</li><li>让线程之间相互配合，来满足业务逻辑</li><li>比如让线程A等待线程B执行完毕后再执行等合作策略</li></ul><img src="/2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.png" srcset="undefined" class="" title="控制并发流程的工具类"><h2 id="CountDownLatch倒计时门闩"><a href="#CountDownLatch倒计时门闩" class="headerlink" title="CountDownLatch倒计时门闩"></a>CountDownLatch倒计时门闩</h2><h3 id="CountDownLatch类的作用"><a href="#CountDownLatch类的作用" class="headerlink" title="CountDownLatch类的作用"></a>CountDownLatch类的作用</h3><p>并发流程控制工具</p><ul><li>倒数门闩</li><li>例子：购物拼团；大巴（游乐园坐过山车排队），人满发车</li><li>流程：倒数结束之前，一直处于等待状态，直到倒计时结束了，此线程才继续工作。</li></ul><h3 id="类的主要方法介绍"><a href="#类的主要方法介绍" class="headerlink" title="类的主要方法介绍"></a>类的主要方法介绍</h3><ul><li>CountDownLatch（int count）：仅有一个构造函数，参数count为需要倒数的数值。</li><li>await（）：调用await（）方法的线程会被挂起，它会等待直到count值为0才继续执行</li><li>countDown（）：将count值减1，直到为0时，等待的线程会被唤起。<img src="/2020/04/10/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%B5%81%E7%A8%8B/countDownLatch.png" srcset="undefined" class="" title="countDownLatch"></li></ul><h3 id="两个典型用法"><a href="#两个典型用法" class="headerlink" title="两个典型用法"></a>两个典型用法</h3><ul><li>类的主要方法介绍</li><li>用法一：一个线程邓艾多个线程都执行完毕，再继续自己的工作。</li><li>用法二：多个线程等待某一个线程的信号，同时开始执行。</li></ul><h3 id="CountDownLatch注意点"><a href="#CountDownLatch注意点" class="headerlink" title="CountDownLatch注意点"></a>CountDownLatch注意点</h3><ul><li>扩展用法：多个线程等待多个线程完成执行后，再同时执行</li><li>CountDownLatch是不能够重用的，如果需要重新技术，可以考虑适用CyclicBarrier或者创建新的CountDownLatch实例。</li></ul><h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><ul><li>Semaphore可以用来限制或管理数量有限的资源的使用情况。</li></ul><h3 id="信号量使用流程"><a href="#信号量使用流程" class="headerlink" title="信号量使用流程"></a>信号量使用流程</h3><ol><li>初始化Semaphore并指定许可证的数量</li><li>在需要被现在的代码前加acquire或者acquireUninterruptibly（）方法</li><li>在任务执行结束后，调用release（）来释放许可证</li></ol><h3 id="信号量主要方法介绍"><a href="#信号量主要方法介绍" class="headerlink" title="信号量主要方法介绍"></a>信号量主要方法介绍</h3><ul><li>new Semaphore(int permits,boolean fair):这里可以设置是否要使用公平策略，如果传入true，那么Semaphore会把之前等待的线程放到FIFO的队列里，以便于当有了新的许可证，可以分发给之前等了最长时间的线程。</li><li>acquire（）</li><li>acquireUninterruptibly（）</li><li>tryAcquire():看看现在有没有空闲的许可证，如果有的话就获取，如果没有的话也没关系，我不必陷入阻塞，我可以取做别的事，过一会再来查看许可证的空闲情况。</li><li>tryAcquire（timeout）：和tryAcquire（）一样，但是多了一个超时时间，比如“在3秒内获取不到许可证，我就去做别的事”。</li><li>release（）</li></ul><h3 id="信号量特殊用法"><a href="#信号量特殊用法" class="headerlink" title="信号量特殊用法"></a>信号量特殊用法</h3><ul><li>一次性获取或释放多个许可证<ul><li>比如TaskA会调用很销魂资源的method1（），而TaskB调用的是不太消耗西元的method2（），假设我们一共有5个许可证。那么我们就可以要求TaskA获取5个许可证才能执行，而TaskB只需要获取到一共许可证就恩那个执行，这样就避免了A和B同时运行的情况，我们可以根据自己的需求合理分配资源。</li></ul></li></ul><h3 id="信号量注意点"><a href="#信号量注意点" class="headerlink" title="信号量注意点"></a>信号量注意点</h3><ol><li>获取和释放的许可证数量必须一致，否则，比如每次都获取2个但是只释放1个甚至不释放，随着时间的推移，到最后许可证数量不够用，会导致成型卡死。（虽然信号量类并不对是否和获取的数量做规定，但是这是我们的变成规范，否则容易出错）</li><li>注意在初始化Semaphore的时候设置公平性，一般设置为true会更合理</li><li>并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对线程并无要求，也许是A获取了，然后由B释放，只要逻辑合理即可。</li><li>信号量的作用，除了控制临界区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才能开始工作，那么就线程1acquire(),而线程2完成任务后release(),这样的话，相当于是轻量级的CountDownLatch。</li></ol><h2 id="Condition接口（又称条件对象）"><a href="#Condition接口（又称条件对象）" class="headerlink" title="Condition接口（又称条件对象）"></a>Condition接口（又称条件对象）</h2><h3 id="Condition作用"><a href="#Condition作用" class="headerlink" title="Condition作用"></a>Condition作用</h3><ul><li>当线程1需要等待某个条件的时候，它就去执行condition.await()方法，一旦执行了await()方法，线程就会进入阻塞状态</li><li>然后通常会有另外一共线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就回去执行condition.signal()方法，这时JVM就会从被阻塞的线程里找，找到那些等待该condition的线程，当线程1就会收到可执行信号的时候它的线程状态就会变成Runnable可执行状态。</li></ul><h3 id="signalAll-和signal-区别"><a href="#signalAll-和signal-区别" class="headerlink" title="signalAll()和signal()区别"></a>signalAll()和signal()区别</h3><ul><li>signalAll()会换器所有的正在等待的线程</li><li>但是signal()是公平的，只会唤起那个等待时间最长的线程</li></ul><h3 id="Condition注意点"><a href="#Condition注意点" class="headerlink" title="Condition注意点"></a>Condition注意点</h3><ul><li>实际上，如果说Lock用来代替synchronized，那么Condition就是用来代替相对应的Object.wait/notify的，所以子啊用法和性质上，几乎都一样</li><li>await方法会自动释放持有的Lock锁，和Object.wait一样，不需要自己手动先释放锁</li><li>调用await的时候，必须持有锁，否则会抛出异常，和Object.wait一样</li></ul><h2 id="CyclicBarrier循环栅栏"><a href="#CyclicBarrier循环栅栏" class="headerlink" title="CyclicBarrier循环栅栏"></a>CyclicBarrier循环栅栏</h2><ul><li>CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程</li><li>当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以是用CyclicBarrier。CyclicBarrier可以构造一个集结点，当某一个线程执行完毕，他就会到集结点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程再统一出发，继续执行剩下的任务。</li><li>生活中的例子：“咱们3个人明天中午在学校碰面，都到齐后，一起讨论下学期的计划。”</li></ul><h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><ul><li>作用不同：CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说，CountDownLatch用于实践，但是CyclicBarrier是用于线程的。</li><li>可重用性不同：CountDownLatch在倒数到0并出发门闩打开后，就布恩那个再次使用了，除非新建新的实例；而CyclicBarrier可以重复使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发队列</title>
    <link href="undefined2020/04/07/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <url>2020/04/07/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要适用队列"><a href="#为什么要适用队列" class="headerlink" title="为什么要适用队列"></a>为什么要适用队列</h2><ul><li>队列可以在线程间传递数据：生产者消费者模式、银行转账</li><li>考虑锁等线程安全问题的重任从你转移到了队列上</li></ul><h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><ul><li><p>简介、地位</p><ul><li>阻塞队列是具有阻塞功能的队列，所以它首先是一个队列，其次是具有阻塞功能。</li><li>通常，阻塞队列的一端是给生产者方数据用，另一端给消费者拿数据用。阻塞队列线程安全的，所以生产者和消费者都可以是多线程的</li></ul></li><li><p>阻塞功能：最有特色的两个带有阻塞功能的方法是</p></li><li><p>take()方法：获取并逸出队列的头结点，一旦执行take的时候，队列里误数据，则阻塞，直到队列有数据</p></li><li><p>put()方法：插入元素。但是如果队列已满，那么就无法继续插入，则阻塞，知道队列有了空闲空间</p></li><li><p>是否有界（容量有多大）：这是一个非常重要的属性，无界队列意味着里面可以容纳非常多（Integer.MAX_VALUE,约为2的31次，是非常大的一个数，可以近似认为是无线容量）</p></li><li><p>阻塞队列和线程池的关系：阻塞队列是线程池的重要组成部分</p></li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li>put，take</li><li>add，remove，element</li><li>offer，poll，peek</li></ul><h3 id="常用实现"><a href="#常用实现" class="headerlink" title="常用实现"></a>常用实现</h3><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue<ul><li>无界</li><li>容量Integer.MAX_VALUE</li><li>内部结构：Node、两把锁。</li></ul></li><li>PriorityBlockingQueue</li><li>SynchronousQueue注意点<ul><li>SynchronousQueue没有peek等函数，因为peek的含义是取出头结点，但是SynchronousQueue的容量是0，所以连头结点都没有，也就没有peek方法。同理，没有iterate相关方法</li><li>是一个极好的用来直接传递的并发数据结构</li><li>SynchonousQueue是线程池Executors.newCachedThreadPool()适用的阻塞队列</li></ul></li><li>DelayQueue<ul><li>延迟队列，根据延迟时间排序</li><li>元素需要实现Delayed接口，规定排序规则</li></ul></li></ul><h2 id="非阻塞并发队列"><a href="#非阻塞并发队列" class="headerlink" title="非阻塞并发队列"></a>非阻塞并发队列</h2><ul><li>并发包种的非阻塞队列只有ConcurrentLinkedQueue这一种，顾名思义ConcurrentLinkedQueue是适用链表作为其数据结构的，适用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景。用的相对比较少一些</li><li>看源码的offer方法的CAS思想，内有p。casNext方法，用了UNSAFE.compareAndSwapObject</li></ul><h2 id="如何选择适合自己的队列"><a href="#如何选择适合自己的队列" class="headerlink" title="如何选择适合自己的队列"></a>如何选择适合自己的队列</h2><ul><li>边界</li><li>空间</li><li>吞吐量</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发容器</title>
    <link href="undefined2020/04/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <url>2020/04/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="古老和过时的同步容器"><a href="#古老和过时的同步容器" class="headerlink" title="古老和过时的同步容器"></a>古老和过时的同步容器</h2><ul><li>Vector和Hashtable<ul><li>并发性能差（synchronized修饰方法）</li></ul></li><li>ArrayList和HashMap<ul><li>虽然这两个类不是线程安全的，但是可以用Collections.synchronizedList(new ArrayList<E>())和Collections.synchronizedMap(new HashMap&lt;K,V&gt;())使之变成线程安全的，用的同步代码块</li></ul></li><li>ConcurrentHashMap和CopyOnWriteArrayList<ul><li>取代同步的HashMap和同步的Arraylist（时代巨轮滚滚向前）</li><li>绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好</li></ul></li></ul><h2 id="ConcurrentHashMap（重点、面试常考）"><a href="#ConcurrentHashMap（重点、面试常考）" class="headerlink" title="ConcurrentHashMap（重点、面试常考）"></a>ConcurrentHashMap（重点、面试常考）</h2><h3 id="为什么需要ConcurrentHashMap"><a href="#为什么需要ConcurrentHashMap" class="headerlink" title="为什么需要ConcurrentHashMap"></a>为什么需要ConcurrentHashMap</h3><ul><li>为什么不用Collections.synchronizedMap()?</li><li>为什么HashMap使线程不安全的？<ul><li>同时put碰撞导致数据丢失</li><li>同时put扩容导致数据丢失</li><li>死循环造成的CPU100%</li></ul></li></ul><h3 id="JDK1-7的ConcurrentHashMap实现和分析"><a href="#JDK1-7的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.7的ConcurrentHashMap实现和分析"></a>JDK1.7的ConcurrentHashMap实现和分析</h3><ul><li>Java7种的ConcurrentHashMap最外层使多个segment，每个segment的底层数据结构与HashMap类似，仍然使数组和联邦组成的拉链法</li><li>每个segment独立上ReentrantLock锁，每个segment之间互补影响，提高了并发效率</li><li>ConcurrentHashMap默认有16个Segments，所以最多可以同时支持16个线程并发写（操作分别分布在不同的Segment上）。这个默认值可以在初始化的适合设置为其他值，但是一旦初始化以后，使不可以扩容的。<img src="/2020/04/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/java7ConcurrentHashMap.png" srcset="undefined" class="" title="java7ConcurrentHashMap"></li></ul><h3 id="JDK1-8的ConcurrentHashMap实现和分析"><a href="#JDK1-8的ConcurrentHashMap实现和分析" class="headerlink" title="JDK1.8的ConcurrentHashMap实现和分析"></a>JDK1.8的ConcurrentHashMap实现和分析</h3><img src="/2020/04/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/java8ConcurrentHashMap.png" srcset="undefined" class="" title="java8ConcurrentHashMap"><h4 id="putVal流程"><a href="#putVal流程" class="headerlink" title="putVal流程"></a>putVal流程</h4><ol><li>判断key value不为空</li><li>计算hash值</li><li>根据对应位置节点的类型，来赋值，或者和老婆Transfer，或者增长链表，或者给红黑树增加节点</li><li>检查满足阈值就“红黑树化”</li><li>返回oldVal</li></ol><h4 id="get流程"><a href="#get流程" class="headerlink" title="get流程"></a>get流程</h4><ul><li>计算hash值</li><li>找到对应的位置，根据情况进行：</li><li>直接取值</li><li>红黑树里找值</li><li>遍历链表取值</li><li>返回找到的结果</li></ul><h3 id="为什么把1-7的结构提升为1-8的结构"><a href="#为什么把1-7的结构提升为1-8的结构" class="headerlink" title="为什么把1.7的结构提升为1.8的结构"></a>为什么把1.7的结构提升为1.8的结构</h3><ul><li>数据结构（并发度提高了）</li><li>Hash碰撞（处理的效率提高了）</li><li>保证并发安全</li><li>查询复杂度</li><li>为什么超过8要转为红黑树？<ul><li>当设置为8时，冲突发生的概率为0.00000006</li></ul></li></ul><h3 id="ConcurrentHashMap的组合操作"><a href="#ConcurrentHashMap的组合操作" class="headerlink" title="ConcurrentHashMap的组合操作"></a>ConcurrentHashMap的组合操作</h3><ul><li>replace</li></ul><pre><code class="java">public class OptionsNotSafe implements Runnable{    private static ConcurrentHashMap&lt;String, Integer&gt; scores = new ConcurrentHashMap&lt;&gt;();    public static void main(String[] args) throws InterruptedException {        scores.put(&quot;小明&quot;, 0);        Thread thread1 = new Thread(new OptionsNotSafe());        Thread thread2 = new Thread(new OptionsNotSafe());        thread1.start();        thread2.start();        thread1.join();        thread2.join();        System.out.println(scores);    }    @Override    public void run() {        for (int i = 0; i &lt; 1000; i++) {            while (true) {                Integer score = scores.get(&quot;小明&quot;);                int newScore = score + 1;//                scores.put(&quot;小明&quot;, newScore);                boolean b = scores.replace(&quot;小明&quot;, score, newScore);                if (b) {                    break;                }            }        }    }}</code></pre><ul><li>putIfAbsent</li></ul><pre><code class="java">if(!map.containsKey(key))  return map.put(key,value);else  return map.get(key);</code></pre><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="诞生的原因"><a href="#诞生的原因" class="headerlink" title="诞生的原因"></a>诞生的原因</h3><ul><li>代替Vector和SynchronizedList，就和ConcurrentHashMap代替SynchronizedMap的原因一样</li><li>Vector和SynchronizedList的锁的粒度太大，并发效率相对比较低，并且迭代时无法编辑</li><li>Copy-On-Write并发容器还包括CopyOnWriteArraySet，用来代替同步Set</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>读操作可以尽可能地快，而写即使慢一些也没有太大关系</li><li>读多写少：黑名单，每日更新；监听器：迭代操作远多于修改操作</li></ul><h3 id="读写规则"><a href="#读写规则" class="headerlink" title="读写规则"></a>读写规则</h3><ul><li>回顾读写锁：读读共享、其他都互斥</li><li>读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>创建新副本、读写分离</li><li>“不可变”原理</li><li>迭代的时候</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的数据，马上能读到，请不要适用CopyOnWrite容器。</li><li>内存占用问题：因为CopyOnWrite的写是复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx安装</title>
    <link href="undefined2020/04/04/%E5%90%8E%E7%AB%AF/nginx/nginx%E5%AE%89%E8%A3%85/"/>
    <url>2020/04/04/%E5%90%8E%E7%AB%AF/nginx/nginx%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>打开虚拟机，使用远程连接工具连接 linux 操作系统</li><li>到 nginx 官网下载软件 <code>http://nginx.org</code><img src="/2020/04/04/%E5%90%8E%E7%AB%AF/nginx/nginx%E5%AE%89%E8%A3%85/nginx%E5%AE%98%E7%BD%91.png" srcset="undefined" class="" title="nginx官网"></li></ol><h2 id="开始进行-nginx-安装"><a href="#开始进行-nginx-安装" class="headerlink" title="开始进行 nginx 安装"></a>开始进行 nginx 安装</h2><ol><li>安装 pcre 依赖<br>第一步 联网下载 pcre 压缩文件依赖<br><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</code><img src="/2020/04/04/%E5%90%8E%E7%AB%AF/nginx/nginx%E5%AE%89%E8%A3%85/pcre.png" srcset="undefined" class="" title="pcre"></li></ol>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx介绍</title>
    <link href="undefined2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/"/>
    <url>2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="nginx基本概念"><a href="#nginx基本概念" class="headerlink" title="nginx基本概念"></a>nginx基本概念</h2><h3 id="nginx是什么，做什么事情"><a href="#nginx是什么，做什么事情" class="headerlink" title="nginx是什么，做什么事情"></a>nginx是什么，做什么事情</h3><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好<br>Nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考研，有报告表明能支持高达50,000个并发连接数。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问</p><img src="/2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" srcset="undefined" class="" title="正向代理.png"><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户其，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><img src="/2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" srcset="undefined" class="" title="反向代理.png"><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求几种到单个服务器上的情况改为将请求分发到多个服务器中，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><img src="/2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" srcset="undefined" class="" title="负载均衡.png"><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p><img src="/2020/04/02/%E5%90%8E%E7%AB%AF/nginx/nginx%E4%BB%8B%E7%BB%8D/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB.png" srcset="undefined" class="" title="动静分离.png">]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final</title>
    <link href="undefined2020/04/02/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/final/"/>
    <url>2020/04/02/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/final/</url>
    
    <content type="html"><![CDATA[<h2 id="final关键字和不变性"><a href="#final关键字和不变性" class="headerlink" title="final关键字和不变性"></a>final关键字和不变性</h2><ol><li>什么是不变性（Immutable）</li><li>final的作用</li><li>3中用法：修饰变量、方法、类</li></ol><h2 id="什么是不变性（Immutable）"><a href="#什么是不变性（Immutable）" class="headerlink" title="什么是不变性（Immutable）"></a>什么是不变性（Immutable）</h2><ul><li>如果对象在被创建后，状态就不能被修改，那么它就是不可变的</li><li>具有不变性的对象一定是线程安全的，我们不需要对其采取任何额外的安全措施，也能保证线程安全。</li></ul><h2 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h2><ul><li>早期<ul><li>锁定</li><li>效率：早期的Java实现版本中，会将final方法转为内嵌调用</li></ul></li><li>现在<ul><li>类防止被继承、方法防止被重写、变量防止被修改</li><li>天生是线程安全的，而不需要额外的同步开销</li></ul></li></ul><h2 id="final的3种用法"><a href="#final的3种用法" class="headerlink" title="final的3种用法"></a>final的3种用法</h2><h3 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h3><ul><li>含义：被final修饰的变量，意味着值不能被修改。如果变量是对象，那么对象的引用不能变，但是对象自身的内容依然可以变化</li></ul><pre><code class="java">final Person person = new Person();person = new Person();// 会报错person.bag = &quot;book&quot;;</code></pre><h4 id="final修饰：3种变量"><a href="#final修饰：3种变量" class="headerlink" title="final修饰：3种变量"></a>final修饰：3种变量</h4><ul><li>final instance variable(类中的final属性)</li><li>final static variable(类中的static final属性)</li><li>final local variable（方法中的final变量）</li></ul><h4 id="final修改变量：赋值时机"><a href="#final修改变量：赋值时机" class="headerlink" title="final修改变量：赋值时机"></a>final修改变量：赋值时机</h4><ul><li><p>属性被声明为final后，该变量则只能被赋值一次。且一旦被赋值，final的变量就不能再被改变，无论如何也不会变。</p></li><li><p>final instance variable(类中的final属性)</p><ul><li>第一种是在声明变量的等号右边直接赋值</li><li>第二种就是构造函数中赋值</li><li>第三种就是在类的初始代码块中赋值（不常用）</li><li>如果不采用第一种赋值方法，那么就必须再第2、3种挑一个来赋值，而不能不赋值，这是final语法所规定的</li></ul></li></ul><pre><code class="java">public class FinalVariableDemo {//    private final int a = 6;    private final int a;//    public FinalVariableDemo(int a) {//        this.a = a;//    }    {        a = 7;    }}</code></pre><ul><li><p>final static variable(类中的static final属性)</p><ul><li>两个赋值时机：除了在声明变量的等号右边直接赋值外，static final变量还可以用static初始代码块赋值，但是不能用普通的初始代码块赋值</li></ul></li><li><p>final local variable（方法中的final变量）</p><ul><li>和前面两种不同，由于这里的变量是在方法里的，所有没有构造函数，也不存在初始代码块</li><li>final local variable不规定赋值时机，只要求在使用前必须赋值，这和方法种的非final变量的要求也是一样的</li></ul></li><li><p>为什么要规定赋值时机？</p><ul><li>我们来思考一下为什么语法要这样？：如果初始化不赋值，后续赋值，就是从null变成你的赋值，这就违反final不变的原则了！</li></ul></li></ul><h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><ul><li>构造方法不允许final修饰</li><li>不可被重写，也就是不能被override</li><li>引申：static方法不能被重写</li></ul><h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><ul><li>不可被继承</li><li>例如典型的String类就是final的，我们从没见过那个类是继承String类的。</li></ul><h2 id="不变性和final的关系"><a href="#不变性和final的关系" class="headerlink" title="不变性和final的关系"></a>不变性和final的关系</h2><ul><li><p>不变性并不意味着，简单地用final修饰就是不可变</p><ul><li>对于基本数据类型，确实被final修饰后就具有不变性</li><li>但是对于对象类型，需要该对象保证自身被创建后，状态永远不会变才可以</li></ul></li><li><p>对象创建后，其状态就不能修改</p></li><li><p>所有属性都是final修饰的</p></li><li><p>对象创建过程种没有发送逸出</p></li></ul><h2 id="把变量写在线程内部——栈封闭技术"><a href="#把变量写在线程内部——栈封闭技术" class="headerlink" title="把变量写在线程内部——栈封闭技术"></a>把变量写在线程内部——栈封闭技术</h2><ul><li>在方法里新建的局部变量，实际上是存储在每个线程私有的占空间，而每个栈的栈空间是不能被其他线程所访问到的，所以不会有线程安全问题。这就是著名的“栈封闭”技术，是“线程封闭”技术的一种情况</li></ul><h2 id="面试题-真假美猴王"><a href="#面试题-真假美猴王" class="headerlink" title="面试题 真假美猴王"></a>面试题 真假美猴王</h2><pre><code class="java">public class FinalStringDemo1 {    public static void main(String[] args) {        String a = &quot;wukong2&quot;;        final String b = &quot;wukong&quot;;        final String f = getDashixion();        String d = &quot;wukong&quot;;        String c = b + 2;        String e = d + 2;        System.out.println(a == c);        System.out.println(a == e);        System.out.println(a == f);    }    private static String getDashixion() {        return &quot;wukong&quot;;    }}truefalsefalse</code></pre><p>final修饰的String编译器会将它作为常量使用，因此c的wukong2是常量池中的悟空2，也就是和a同一个地址的wukong2。<br>而d+2编译器会新生成一个对象，并将wukong2放入其中。<br>但是通过方法调用的wukong，无法将它当成常量，也就是说无法预测方法的返回值是什么，因此也是和e的效果一样会产生一个新的对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="undefined2020/04/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAS/"/>
    <url>2020/04/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAS/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><ul><li>并发</li><li>我认为V的值应该是A，如果是的话那我就把它改成B，如果不是A（说明被别人修改过了），那我就不修改了，避免多人同时修改导致出错</li><li>CAS有三个操作数：内存值V、预期值A、要修改的值B，当且仅当预期值A和内存之V相同时，才将内存值修改为B，否则什么都不做。最后返回现在的V值</li><li>CPU的特殊指令</li><li>CAS的等价代码（语义）</li></ul><pre><code class="java">public class SimulatedCAS {    private volatile int value;    public synchronized int compareAndSwap(int expectedValue, int newValue) {        int oldValue = value;        if (oldValue == expectedValue) {            value = newValue;        }        return oldValue;    }}</code></pre><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>乐观锁</li><li>并发容器</li><li>原子类</li></ul><h2 id="以AtomicInteger为例，分析在Java中是如何利用CAS实现原子操作的"><a href="#以AtomicInteger为例，分析在Java中是如何利用CAS实现原子操作的" class="headerlink" title="以AtomicInteger为例，分析在Java中是如何利用CAS实现原子操作的"></a>以AtomicInteger为例，分析在Java中是如何利用CAS实现原子操作的</h2><ul><li>AtomicInteger加载Unsafe工具，用来直接操作内存数据</li><li>哟个Unsafe类实现底层操作</li><li>用volatile修饰value字段，保证可见性</li><li>getAndAddInt方法分析</li></ul><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><ul><li>Unsafe是CAS的核心类。Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了<strong>硬件级别的原子操作</strong></li><li>valueOffset表示的是变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的，这样我们救恩那个通过Unsafe来实现CAS了</li></ul><h3 id="分析在Java中是如何利用CAS实现原子操作的"><a href="#分析在Java中是如何利用CAS实现原子操作的" class="headerlink" title="分析在Java中是如何利用CAS实现原子操作的"></a>分析在Java中是如何利用CAS实现原子操作的</h3><ul><li>Unsafe类中的compareAndSwapInt方法<ul><li>方法中先想办法拿到变量value在内存中的地址。</li><li>通过Atomic::cmpxchg实现原子性的比较和替换，其中参数x是即将更新的值，参数e是原内存的值。至此，最终完成了CAS的权过程。</li></ul></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>ABA问题</li><li>自旋时间过长</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类</title>
    <link href="undefined2020/03/30/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>2020/03/30/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="什么时原子类，有什么作用"><a href="#什么时原子类，有什么作用" class="headerlink" title="什么时原子类，有什么作用"></a>什么时原子类，有什么作用</h2><ul><li>原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：</li><li>粒度更细：原子变量可以把竞争范围缩小到比变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度</li><li>效率更高：通常，适用原子类的效率会比使用锁的效率更高，除了高度竞争的情况。</li></ul><h2 id="6类原子类纵览"><a href="#6类原子类纵览" class="headerlink" title="6类原子类纵览"></a>6类原子类纵览</h2><img src="/2020/03/30/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8E%9F%E5%AD%90%E7%B1%BB/%E5%8E%9F%E5%AD%90%E7%B1%BB.png" srcset="undefined" class="" title="原子类"><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public final int get() //获取当前的值</li><li>public final int getAndSet(int newValue) //获取当前的值，并设置新的值</li><li>public final int getAndIncrement() // 获取当前的值，并自增</li><li>public final int getAndDecrement() // 获取当前的值，并自减</li><li>public final int getAndAdd(int delta) // 获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int expect,int update) // 如果单曲的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><h2 id="Atomic-Reference引用类型原子类"><a href="#Atomic-Reference引用类型原子类" class="headerlink" title="Atomic*Reference引用类型原子类"></a>Atomic*Reference引用类型原子类</h2><ul><li>AtomicReference:AtomicReference类的作用，和AtomicInteger并没有本质区别，AtomicInnteger可以让一个整数保证原子性，而AtomicReference可以让一个对象保证原子性，当然，AtomicReference的功能明显比AtomicInteger强，因为一个对象里可以包含很多属性。用法和AtomicInteger类似。</li></ul><h2 id="把普通变量升级为具有原子功能"><a href="#把普通变量升级为具有原子功能" class="headerlink" title="把普通变量升级为具有原子功能"></a>把普通变量升级为具有原子功能</h2><ul><li>AtomicIntegerFieldUpdater普通变量进行升级</li><li>使用场景：偶尔需要一个原子get-set操作</li></ul><h2 id="AtomicIntegerFieldUpdater注意点"><a href="#AtomicIntegerFieldUpdater注意点" class="headerlink" title="AtomicIntegerFieldUpdater注意点"></a>AtomicIntegerFieldUpdater注意点</h2><ul><li>可见范围（需要用volatile修饰）</li><li>不支持static</li></ul><h2 id="Adder累加器"><a href="#Adder累加器" class="headerlink" title="Adder累加器"></a>Adder累加器</h2><ul><li>是Java 8引入的，相对是比较新的一个类</li><li>高并发下LongAdder比AtomicLong效率高，不过本质是空间换时间</li><li>竞争激烈的时候，LongAdder把不同线程对应到不同的Cell上进行修改，降低了冲突的概率，是多端锁的理念，提高了并发性。</li></ul><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ul><li>这里演示多线程情况下AtomicLong的性能，有16个线程对同一个AtomicLong累加</li><li>由于竞争很激烈，每一次加法，都要flush和refresh，导致很耗费资源。</li></ul><h3 id="LongAdder带来的改进和原理"><a href="#LongAdder带来的改进和原理" class="headerlink" title="LongAdder带来的改进和原理"></a>LongAdder带来的改进和原理</h3><ul><li>在内部，这个LongAdder额实现原理和刚才的AtomicLong是由不同的，刚才的AtomicLong的实现原理是，每一次加法都需要做同步，所以在高并发的时候会导致冲突比较多，也就降低了效率</li><li>而此时的LongAdder，每个线程会有自己的一个计数器，禁用来在自己线程内计数，这样一来就不会和其他线程的计数器干扰</li><li>如图中所示，第一个线程的计数器数值，也就是ctr‘，为1的时候，可以线程2的计数器ctr”的数值已经是3了，他们之间并不存在竞争关系，所以在加和的过程中，根本不需要同步机制，也不需要刚才的flush和refresh。这里也没有一个公共的counter来给所有线程统一计数</li><li>LongAdder引入了分段累加的概念，内部有一个base变量和一个Cell[]数组共同参与计数：</li><li>base变量：竞争不激烈，直接累加到该变量上</li><li>Cell[]数组：竞争激烈，各个线程分散累加到自己的槽Cell[i]中</li></ul><h3 id="对比AtomicLong和LongAdder"><a href="#对比AtomicLong和LongAdder" class="headerlink" title="对比AtomicLong和LongAdder"></a>对比AtomicLong和LongAdder</h3><ul><li>在低争用下，AtomicLong和LongAdder这两个类具有相似的特征。但是在竞争激烈的情况下，LongAdder的语气吞吐量要高得多，但要消耗更多的空间</li><li>LongAdder适合的场景是统计求和计数的场景，而且LongAdder基本只提供了add方法，而AtomicLong还具有cas方法</li></ul><h2 id="Accumulator累加器"><a href="#Accumulator累加器" class="headerlink" title="Accumulator累加器"></a>Accumulator累加器</h2><ul><li>Accumulator和Adder非常相似，Accumulator就是一个更通用版本的Adder</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要大量计算的适合，可使用多线程快速高效处理，可以进行任何计算，不限于加法</p><pre><code class="java">public static void main(String[] args) {        LongAccumulator longAccumulator = new LongAccumulator(Long::sum, 0);        ExecutorService executorService = Executors.newFixedThreadPool(8);        IntStream.range(1,10).forEach(i-&gt;executorService.submit(()-&gt;longAccumulator.accumulate(i)));        executorService.shutdown();        while (!executorService.isTerminated()) {}        System.out.println(longAccumulator.getThenReset());    }</code></pre><p>在LongAccumulator传入什么表达式，运算的结果就是什么</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="undefined2020/03/27/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/"/>
    <url>2020/03/27/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul><li>这些分类，是从各种不同角度出发去看的</li><li>这些分类并不是互斥的，也就是多个类型可以并存：有可能一个锁，同时属于两种类型</li><li>比如ReentrantLock既是互斥锁，又是可重入锁</li><li>好比一个人可以同时时男人，又是军人</li></ul><img src="/2020/03/27/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB.png" srcset="undefined" class="" title="锁的分类"><h2 id="互斥同步锁"><a href="#互斥同步锁" class="headerlink" title="互斥同步锁"></a>互斥同步锁</h2><h3 id="为什么会诞生非互斥同步锁————互斥同步锁的劣势"><a href="#为什么会诞生非互斥同步锁————互斥同步锁的劣势" class="headerlink" title="为什么会诞生非互斥同步锁————互斥同步锁的劣势"></a>为什么会诞生非互斥同步锁————互斥同步锁的劣势</h3><ul><li>互斥同步锁的劣势<ul><li>阻塞和唤醒带来的性能劣势</li><li>永久阻塞：如果持有锁的线程被永久阻塞，比如遇到了无线循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行。</li><li>优先级反转</li></ul></li></ul><h3 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h3><ul><li>从是否锁住资源的角度分类</li></ul><h4 id="悲观锁（互斥同步锁）"><a href="#悲观锁（互斥同步锁）" class="headerlink" title="悲观锁（互斥同步锁）"></a>悲观锁（互斥同步锁）</h4><ul><li>如果我不锁住这个资源，别人就会来抢，就会造成数据结果错误，所有每次悲观锁为了确保结果的正确性，会在每次获取并修改数据时，把数据锁住，让别人无法访问该数据，这样就可以确保数据内容万无一失。</li><li>Java中的悲观锁的实现就是synchronized和Lock相关类</li></ul><h4 id="乐观锁（非互斥同步锁）"><a href="#乐观锁（非互斥同步锁）" class="headerlink" title="乐观锁（非互斥同步锁）"></a>乐观锁（非互斥同步锁）</h4><ul><li>认为自己在处理操作的时候不会有其他线程来干扰，所以并不会锁住被操作对象</li><li>在更新的时候，去对比在我修改的期间数据有没有被其他人改变过：如果没被改变过，就说明真的是只有我自己在操作，那我就正常去修改数据</li><li>如果数据和我一开始拿到的不一样了，说明其他人在这段时间内改过数据，那我就不能继续刚才的更新数据过程了，我会选择放弃、报错、重试等策略</li><li>乐观锁的实现一半都是利用CAS算法实现的</li></ul><h4 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h4><ul><li>悲观锁：synchronized和lock接口</li><li>乐观锁的典型例子就是原子类、并发容器等</li><li>Git就是乐观锁</li><li>数据库的update也是乐观锁</li></ul><h3 id="开销对比"><a href="#开销对比" class="headerlink" title="开销对比"></a>开销对比</h3><ul><li>悲观锁的原始开销要高于乐观锁，但是特点是一劳永逸，临界区持锁时间就算越来越差，也不会对互斥锁的开销造成影响</li><li>相反，虽然乐观锁一开始的开销比悲观锁校，但是如果自旋时间很长或者不停重试，那么么消耗的资源也会越来越多</li></ul><h3 id="两种锁各自的使用场景：各有千秋"><a href="#两种锁各自的使用场景：各有千秋" class="headerlink" title="两种锁各自的使用场景：各有千秋"></a>两种锁各自的使用场景：各有千秋</h3><ul><li>悲观锁：适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋等消耗，典型情况：<ol><li>临界区有IO操作</li><li>临界区代码复杂或循环量大</li><li>临界区经常非常激烈</li></ol></li><li>乐观锁：适合并发写入少，大部分是读取的场景，不加锁的能让读取性能大幅提高</li></ul><h2 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h2><h3 id="ReentrantLock使用案例"><a href="#ReentrantLock使用案例" class="headerlink" title="ReentrantLock使用案例"></a>ReentrantLock使用案例</h3><ul><li><p>好处</p><ul><li>避免死锁</li><li>提升封装性</li></ul></li><li><p>源码分析</p><img src="/2020/03/27/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.png" srcset="undefined" class="" title="可重入锁"></li></ul><h4 id="其他方法介绍"><a href="#其他方法介绍" class="headerlink" title="其他方法介绍"></a>其他方法介绍</h4><ul><li>isHeldByCurrentThread可以看出锁是否被当前线程持有</li><li>getQueueLength可以返回当前正在等待这把锁的队列有多长，一半这两个方法是开发和调试时候使用，上线后用到的不多</li></ul><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="什么是公平和非公平"><a href="#什么是公平和非公平" class="headerlink" title="什么是公平和非公平"></a>什么是公平和非公平</h3><ul><li>公平指的是按照线程请求的顺序，来分配锁；非公平指的是，不完全按照请求的顺序，在一定情况下，可以插队。</li><li>注意：非公平也同样不提倡“插队”行为，这里的非公平，指的是“在合适的时机”插队，而不是盲目插队。</li><li>什么是合适的时机呢?</li></ul><h3 id="为什么要有非公平锁"><a href="#为什么要有非公平锁" class="headerlink" title="为什么要有非公平锁"></a>为什么要有非公平锁</h3><ul><li>非公平锁是为了提高效率</li><li>避免唤醒带来的空档期</li></ul><h3 id="公平的情况（以ReentrantLock为例"><a href="#公平的情况（以ReentrantLock为例" class="headerlink" title="公平的情况（以ReentrantLock为例)"></a>公平的情况（以ReentrantLock为例)</h3><ul><li>如果在创建ReentrantLock对象时，参数填写未true，那么这就是个公平锁</li><li>假设线程1234时按顺序调用lock()的</li><li>在线程1执行unlock()释放锁之后，由于此时线程2的等待时间最久，所以线程2先得到执行，然后是线程3和线程4</li></ul><h3 id="不公平的情况（以ReentrantLock为例）"><a href="#不公平的情况（以ReentrantLock为例）" class="headerlink" title="不公平的情况（以ReentrantLock为例）"></a>不公平的情况（以ReentrantLock为例）</h3><ul><li>如果在线程1释放锁的时候，线程5恰好去执行lock()</li><li>由于ReentrantLock发现此时并没有线程持有lock这把锁（线程2还没来得及获取到，因为获取需要时间）</li><li>线程5可以插队，直接拿到这把锁，这也是ReentrantLock默认的公平策略，也就是“不公平”</li></ul><h3 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h3><ul><li>针对tryLock()方法，它是很猛的，它不遵守设定的公平的规则</li><li>例如，当有线程执行tryLock()的时候，一旦有线程释放了锁，那么这个正在tryLock的线程就能获取到锁，即使在它之前已经有其他现在在等待队列里了<img src="/2020/03/27/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%94%81/%E5%85%AC%E5%B9%B3%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3.png" srcset="undefined" class="" title="公平和非公平"></li></ul><h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h2><h3 id="什么是共享锁和排他锁"><a href="#什么是共享锁和排他锁" class="headerlink" title="什么是共享锁和排他锁"></a>什么是共享锁和排他锁</h3><ul><li>排他锁，又称为独占锁、独享锁</li><li>共享锁，又称为读锁，获得共享锁之后，可以查看但无法修改和删除数据，其他线程此时也可以获取到共享锁，也可以查看但无法修改和删除数据</li><li>共享锁和排他锁的典型是读写锁ReentrantReadWriteLock，其中读锁是共享锁，写锁是独享锁</li></ul><h3 id="读写锁的作用"><a href="#读写锁的作用" class="headerlink" title="读写锁的作用"></a>读写锁的作用</h3><ul><li>在没有读写锁之前，我们假设使用ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源：多个读操作同时进行，并没有线程安全问题</li><li>在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，提高了程序的执行效率</li></ul><h3 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h3><ul><li>多个线程只申请读锁，都可以申请到</li><li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁</li><li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁</li><li>一句话总结：要么是一个或多个线程同时又读锁，要么是洗个线程又写锁，但是两者不会同时出现（要么多读，要么一写）</li></ul><p>换一种思路更容易理解：读写锁只是一把锁，可以通过两种方式锁定：读锁定和写锁定。读写锁可以同时被一个或多个线程读锁定，也可以被单一线程写锁定。但是永远不能同时对这把锁进行读锁定和写锁定。<br>这里是把“获取写锁”理解为“把读写锁进行写锁定”，相当于换了一种思路，不过原子时不变的，就是要么时一个或多个线程同时又读锁（同时读锁定），要么是一个线程又写锁（进行写锁定），但是两者不会同时出现</p><h3 id="以ReentrantReadWriteLock读写锁为例"><a href="#以ReentrantReadWriteLock读写锁为例" class="headerlink" title="以ReentrantReadWriteLock读写锁为例"></a>以ReentrantReadWriteLock读写锁为例</h3><pre><code class="java">public class CinemaReadWrite {    private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();    private static ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();    private static ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();    private static void read() {        readLock.lock();        try {            System.out.println(Thread.currentThread().getName() + &quot;得到了读锁，正在读取&quot;);            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;);            readLock.unlock();        }    }    private static void write() {        writeLock.lock();        try {            System.out.println(Thread.currentThread().getName() + &quot;得到了写锁，正在写入&quot;);            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;);            writeLock.unlock();        }    }    public static void main(String[] args) {        new Thread(CinemaReadWrite::read,&quot;Thread1&quot;).start();        new Thread(CinemaReadWrite::read,&quot;Thread2&quot;).start();        new Thread(CinemaReadWrite::write,&quot;Thread3&quot;).start();        new Thread(CinemaReadWrite::write,&quot;Thread4&quot;).start();    }}</code></pre><h3 id="读锁和写锁的交互方式"><a href="#读锁和写锁的交互方式" class="headerlink" title="读锁和写锁的交互方式"></a>读锁和写锁的交互方式</h3><ul><li>选择规则</li><li>读线程插队（比喻：男女共用厕所，男生可以插队么？）</li><li>升降级</li></ul><h3 id="读锁插队策略"><a href="#读锁插队策略" class="headerlink" title="读锁插队策略"></a>读锁插队策略</h3><ul><li>非公平：假设线程2和线程4正在同时读取，线程3想要写入，拿不到锁，于是进入等待队列，线程5不在队列里，线程过来想要读</li><li>此时有2中策略<ul><li>策略1：<ul><li>都可以插队，效率高</li><li>容易造成饥饿</li></ul></li><li>策略2：避免饥饿</li></ul></li><li>策略的选择取决于具体锁的实现，ReentrantReadWriteLock的实现是选择了策略2，是很明智的。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code class="java">/** * @Description TODO * 演示非公平和公平的ReentrantReadWriteLock的策略 * @Author Matthew * @Date 2020/3/28 21:03 * @Version 1.0 */public class NonfairBargeDemo {    private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(false);    private static ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();    private static ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();    private static void read(){        System.out.println(Thread.currentThread().getName() + &quot;开始尝试获取读锁&quot;);        readLock.lock();        try{            System.out.println(Thread.currentThread().getName() + &quot;得到读锁，正在读取&quot;);            Thread.sleep(10);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;);            readLock.unlock();        }    }    private static void write(){        System.out.println(Thread.currentThread().getName() + &quot;开始尝试获取写锁&quot;);        writeLock.lock();        try{            System.out.println(Thread.currentThread().getName() + &quot;得到写锁，正在写入&quot;);            Thread.sleep(40);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;);            writeLock.unlock();        }    }    public static void main(String[] args) {        new Thread(NonfairBargeDemo::write,&quot;Thread1&quot;).start();        new Thread(NonfairBargeDemo::read,&quot;Thread2&quot;).start();        new Thread(NonfairBargeDemo::read,&quot;Thread3&quot;).start();        new Thread(NonfairBargeDemo::write,&quot;Thread4&quot;).start();        new Thread(NonfairBargeDemo::read,&quot;Thread5&quot;).start();        new Thread(()-&gt;{            Thread[] threads = new Thread[1000];            for (int i = 0; i &lt; 1000; i++) {                threads[i] = new Thread(NonfairBargeDemo::read, &quot;子线程创建的Thread&quot; + i);            }            for (int i = 0; i &lt; 1000; i++) {                threads[i].start();            }        }).start();    }}</code></pre><h3 id="锁的升降级"><a href="#锁的升降级" class="headerlink" title="锁的升降级"></a>锁的升降级</h3><h4 id="为什么需要升降级"><a href="#为什么需要升降级" class="headerlink" title="为什么需要升降级"></a>为什么需要升降级</h4><p>为了提高效率</p><h4 id="支持锁的降级，不支持升级"><a href="#支持锁的降级，不支持升级" class="headerlink" title="支持锁的降级，不支持升级"></a>支持锁的降级，不支持升级</h4><h5 id="实际锁降级的例子"><a href="#实际锁降级的例子" class="headerlink" title="实际锁降级的例子"></a>实际锁降级的例子</h5><p>在锁降级成功后，也就是持有写锁的时候同时申请并获得了读锁后，此时直接释放写锁，但是不释放读锁，这样就可以提高锁的利用效率，下面这段代码演示了在更新缓存的时候，如何利用锁的降级功能。</p><pre><code class="java">public class CachedData {    Object data;    volatile boolean cacheValid;    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    void processCachedData() {        // 最开始时读取        rwl.readLock().lock();        if(!cacheValid) {            // 发现缓存失效，那么就需要写入了，所以现在选哟获取写锁。由于锁不支持升级，所以在获取写锁之前，必须首先释放读锁。            rwl.readLock().unlock();            // 获取到写锁            rwl.writeLock().lock();            try{                // 这里需要在此判断数据的有效性，因为在我们释放读锁和获取写锁的空隙之内，可能有其他线程修改了数据。                if(!cacheValid) {                    data = new Object();                    cacheValid = true;                }                // 在不释放写锁的情况下，直接获取读锁，这就是写锁的降级。                rwl.readLock().long();            } finally{                //释放了写锁，但是依然持有读锁，这样依赖，就可以多个线程同时读取了，提高了整体效率。                rwl.writeLock().unlock();            }            try{                System.out.println(data);            } finally {                // 最后释放读锁                rwl.readLock().unlock();            }        }    }}</code></pre><p>在这段代码中有一个读写锁，最重要的就是中间的 processCachedData 方法，在这个方法中，会首先获取到读锁，也就是 rwl.readLock().lock()，它去判断当前的缓存是否有效，如果有效那么就直接跳过整个 if 语句，如果已经失效，代表我们需要更新这个缓存了。由于我们需要更新缓存，所以之前获取到的读锁是不够用的，我们需要获取写锁。<br>在获取写锁之前，我们首先释放读锁，然后利用 rwl.writeLock().lock() 来获取到写锁，然后是经典的 try finally 语句，在 try 语句中我们首先判断缓存是否有效，因为在刚才释放读锁和获取写锁的过程中，可能有其他线程抢先修改了数据，所以在此我们需要进行二次判断。<br>如果我们发现缓存是无效的，就用 new Object() 这样的方式来示意，获取到了新的数据内容，并把缓存的标记位设置为 ture，让缓存变得有效。由于我们后续希望打印出 data 的值，所以不能在此处释放掉所有的锁。我们的选择是在不释放写锁的情况下直接获取读锁，也就是 rwl.readLock().lock() 这行语句所做的事情，然后，在持有读锁的情况下释放写锁，最后，在最下面的 try 中把 data 的值打印出来。<br>这就是一个非常典型的利用锁的降级功能的代码<br>你可能会想，我为什么要这么麻烦进行降级呢？我一直持有最高等级的写锁不就可以了吗？这样谁都没办法来影响到我自己的工作，永远是线程安全的。<br>为什么需要锁的降级？<br>如果我们在刚才的方法中，一直使用写锁，最后才释放写锁的话，虽然确实是线程安全的，但是也是没有必要的，因为我们只有一处修改数据的代码：<br><code>data = new Object();</code><br>后面我们对于 data 仅仅是读取。如果还一直使用写锁的话，就不能让多个线程同时来读取了，持有写锁是浪费资源的，降低了整体的效率，所以这个时候利用锁的降级是很好的办法，可以提高整体性能。</p><h4 id="为什么不支持锁的升级？死锁"><a href="#为什么不支持锁的升级？死锁" class="headerlink" title="为什么不支持锁的升级？死锁"></a>为什么不支持锁的升级？死锁</h4><p>如果thread1和thread2同时持有读锁，而同时又想获取写锁，都需要对方放弃读锁，就陷入了死锁</p><h3 id="共享锁和排他锁总结"><a href="#共享锁和排他锁总结" class="headerlink" title="共享锁和排他锁总结"></a>共享锁和排他锁总结</h3><ol><li>ReentrantReadWriteLock实现了ReadWriteLock接口，最主要的又两个方法：readLock()和writeLock()用来获取读锁和写锁</li><li>锁申请和释放策略<ul><li>多个线程之神奇读锁，都可以申请到</li><li>如果又一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</li><li>如果又一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</li><li>要么是一个或多个线程同时有读锁，要么时一个线程有写锁，但是两种不会同时出现。</li></ul> <strong>总结：要么多读，要么一写</strong></li><li>插队策略：为了防止饥饿，读锁不能插队</li><li>升降机策略：只能降级，不能升级</li><li>适用场合：相比于ReentrantLock适用一半场合，ReentrantReadWriteLock适用于都铎写少的情况，合理适用可以进一步提高并发效率。</li></ol><h2 id="自旋锁和阻塞锁"><a href="#自旋锁和阻塞锁" class="headerlink" title="自旋锁和阻塞锁"></a>自旋锁和阻塞锁</h2><ul><li>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间</li><li>如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比永固代码执行的时间还要长</li><li>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程的花费可能会让系统得不偿失</li><li>如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁</li><li>而为了让单曲线程稍等一下，我们需让当前线程进行自旋，如果在自旋完成后签名锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</li><li>阻塞锁和自旋锁相反，阻塞锁如果遇到没拿到的锁的情况，会直接把线程阻塞，直到被唤醒</li></ul><h3 id="自旋锁的缺点"><a href="#自旋锁的缺点" class="headerlink" title="自旋锁的缺点"></a>自旋锁的缺点</h3><ul><li>如果锁被占用的时间很长，那么自旋的线程指挥白浪费处理器资源</li><li>在自旋的过程中，一直消耗cpu，所以虽然自旋锁的起始开销低于悲观锁，但是随着自旋时间的增长，开销也是线性增长的。</li></ul><h3 id="原理和源码分析"><a href="#原理和源码分析" class="headerlink" title="原理和源码分析"></a>原理和源码分析</h3><ul><li>在java1.5版本及以上的并发框架java.util.concurrent的atmoic包下的类基本都是自旋锁的实现</li><li>AtomicInteger的实现：自旋锁的实现原理是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋从左，如果修改过程中遇到其他线程竞争导致没修改成功，就在while里死循环，直至修改成功。</li></ul><h3 id="自旋锁的适用场景"><a href="#自旋锁的适用场景" class="headerlink" title="自旋锁的适用场景"></a>自旋锁的适用场景</h3><ul><li>自旋锁一般用于多核的服务器，在并发度不是特别高的情况下，比阻塞锁的效率高</li><li>另外，自旋锁适用于临界区比较小的情况，否则如果临界区很大（线程一旦拿到锁，很久以后才会释放），那也是不合适的</li></ul><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><ul><li>在Java中，synchronized就不是可中断锁，而Lock是可中断锁，因为tryLock(time)和lockInterruptibly都能响应中断。</li><li>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以中断它，这种就是可中断锁</li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="Java虚拟机对锁的优化"><a href="#Java虚拟机对锁的优化" class="headerlink" title="Java虚拟机对锁的优化"></a>Java虚拟机对锁的优化</h3><ul><li>自旋锁和自适应</li><li>锁消除</li><li>锁粗化</li></ul><h3 id="我们在写代码时如何优化锁和提高并发性能"><a href="#我们在写代码时如何优化锁和提高并发性能" class="headerlink" title="我们在写代码时如何优化锁和提高并发性能"></a>我们在写代码时如何优化锁和提高并发性能</h3><ol><li>缩小同步代码块</li><li>尽量不要锁住方法</li><li>减少请求锁的次数</li><li>避免人为制造“热点”</li><li>锁中尽量不要再包含锁</li><li>选择合适的锁类型或合适的工具类</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lock接口</title>
    <link href="undefined2020/03/20/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>2020/03/20/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Lock简介、地位、作用"><a href="#Lock简介、地位、作用" class="headerlink" title="Lock简介、地位、作用"></a>Lock简介、地位、作用</h2><ul><li>锁是一种工具，用于控制对共享资源的访问。</li><li>Lock和synchronized，这两个是最常见的锁，它们都可以达到线程安全的目的，但是在使用上和功能上又有较大的不同。</li><li>Lock并不是用来代替synchronized的，而是当使用synchronized不合适或不足以满足要求的时候，来提供高级功能的。</li><li>Lock接口最常见的实现类是ReentrantLock</li><li>通常情况下，Lock只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如ReadWriteLock里面的ReadLock。</li></ul><h3 id="为什么需要Lock"><a href="#为什么需要Lock" class="headerlink" title="为什么需要Lock"></a>为什么需要Lock</h3><ul><li>为什么synchronized不够用</li></ul><ol><li>效率低：锁的释放情况少、试图获得锁时不能设定超时、不饿能中断一个正在试图获得锁的线程。</li><li>不够灵活（读写锁更灵活）：加锁和释放的实际单一，每个锁仅有单一的条件（某个对象），可能时不够的。</li><li>无法知道是否成功获得到锁</li></ol><h2 id="Lock主要方法介绍"><a href="#Lock主要方法介绍" class="headerlink" title="Lock主要方法介绍"></a>Lock主要方法介绍</h2><ul><li>在Lock中声明了四个方法来获取锁</li><li>lock()、tryLock()、tryLock(long time,TimeUnit unit)和lockInterryptibly</li></ul><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><ul><li>lock()就是最普通的获取锁。如果锁已被其他线程获取，则进行等待。</li><li>Lock不会像synchronized一样在异常时自动释放锁</li><li>因此最佳实践是，在finally中释放锁，以保证发生异常时锁一定被释放</li><li>lock()方法不能被中断，这回带来很大的隐患：一旦陷入死锁，lock()就会陷入永久等待</li></ul><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><ul><li>tryLock()用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，则返回true，否则返回false，代表获取锁失败</li><li>相比于lock，这样的方法显然功能更加强大了，我们可以根据是否能获取到锁来决定后续程序的行为。</li><li>该方法会立即返回，即便在拿不到锁时不会一直在那等</li></ul><h4 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h4><ul><li>tryLock(long time,TimeUnit unit):超时就放弃</li><li>lockInterruptibly():相当于tryLock(long time,TimeUnit unit)把超时时间设置为无线。在等待锁的过程中，线程可以被中断</li><li>unlock():解锁</li></ul><h2 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h2><ul><li>可见性</li><li>happens-before</li><li>Lock的加解锁和synchronized有同样的内存语义，也就是说，下一个线程加锁后可以看到所以前一个线程解锁前发生的所有操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="undefined2020/03/16/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/"/>
    <url>2020/03/16/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h2 id="两大使用场景————ThreadLocal的用途"><a href="#两大使用场景————ThreadLocal的用途" class="headerlink" title="两大使用场景————ThreadLocal的用途"></a>两大使用场景————ThreadLocal的用途</h2><ul><li>典型场景1：每个线程需要一个独享的对象（通常时工具类，典型需要使用的类又SimpleDateFormat和Random）</li><li>典型场景2：每个线程内需要保存全局变量（例如再拦截器种获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦</li></ul><h3 id="典型场景1——SimpleDateFormat的进化之路"><a href="#典型场景1——SimpleDateFormat的进化之路" class="headerlink" title="典型场景1——SimpleDateFormat的进化之路"></a>典型场景1——SimpleDateFormat的进化之路</h3><ol><li>2个线程分别用自己的SimpleDateFormat，这没问题。</li><li>后来延伸出10个，那就又10个线程和10个SimpleDateFormat，这随人写法不优雅（应该复用对象），但勉强可以接受。</li><li>但是当需求变成了1000个，那么必然要用线程池（否则消耗内存太多）。</li><li>所有的线程都公用同一个simpleDateFormat对象。</li><li>这是线程不安全的，出现了并发安全问题。</li><li>我们可以选择加锁，加锁后结果正常，但是效率低。</li><li>在这里更好的解决方案是使用ThreadLocal，每个线程有独享的对象，在这里有10个对象对应10个线程。</li></ol><h2 id="ThreadLocal的两个作用"><a href="#ThreadLocal的两个作用" class="headerlink" title="ThreadLocal的两个作用"></a>ThreadLocal的两个作用</h2><ol><li>让某个需要用到的对象在线程间隔离（每个线程都有自己的独立的对象）</li><li>在任何方法种都可以轻松获取到对象</li></ol><p>根据共享对象的生成时机不同，选择initialValue或set来保存对象</p><h3 id="场景一：initialValue"><a href="#场景一：initialValue" class="headerlink" title="场景一：initialValue"></a>场景一：initialValue</h3><ul><li>在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制</li></ul><h3 id="场景二：set"><a href="#场景二：set" class="headerlink" title="场景二：set"></a>场景二：set</h3><ul><li>如果需要保存到ThreadLocal里的对象的生产时机不由我们随意控制，例如拦截器生成的用户信息，用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用。</li></ul><h2 id="使用ThreadLocal带来的好处"><a href="#使用ThreadLocal带来的好处" class="headerlink" title="使用ThreadLocal带来的好处"></a>使用ThreadLocal带来的好处</h2><ol><li>达到线程安全</li><li>不需要加锁，提高执行效率</li><li>更高效地利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销</li><li>免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码耦合度更低，更优雅。</li></ol><h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><img src="/2020/03/16/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/ThreadLocal.png" srcset="undefined" class="" title="ThreadLocal"><h2 id="主要方法解析"><a href="#主要方法解析" class="headerlink" title="主要方法解析"></a>主要方法解析</h2><h3 id="T-initialValue-初始化"><a href="#T-initialValue-初始化" class="headerlink" title="T initialValue():初始化"></a>T initialValue():初始化</h3><ol><li>该方法会返回当前线程对应的初始值，这是一个延迟加载的方法，只有在调用get的时候，才会触发</li><li>当线程第一次使用get方法访问变量时，将调用此方法，除非线程先前调用了set方法，在这种情况下，不会为线程调用本initialValue方法</li><li>通常，每个线程最多调用一次此方法，但如果已经调用了remove()后，再调用get(),则可以在此调用此方法</li><li>如果不重新本方法，这个方法会返回null。一半使用匿名内部类的方法来重写initialValue()方法，以便在后续使用中可以初始化副本对象</li></ol><ul><li>这正对应了ThreadLocal的两种典型用法</li><li>initicalValue方法：是没有默认实现的，如果我们要用initialValue方法，需要自己实现，通常是匿名内部类的方式</li></ul><h3 id="void-set-T-t-为这个线程设置一个新值"><a href="#void-set-T-t-为这个线程设置一个新值" class="headerlink" title="void set(T t) :为这个线程设置一个新值"></a>void set(T t) :为这个线程设置一个新值</h3><h3 id="T-get-得到这个线程对应的value。如果是首次调用get-则会调用initialize来得到这个值"><a href="#T-get-得到这个线程对应的value。如果是首次调用get-则会调用initialize来得到这个值" class="headerlink" title="T get():得到这个线程对应的value。如果是首次调用get(),则会调用initialize来得到这个值"></a>T get():得到这个线程对应的value。如果是首次调用get(),则会调用initialize来得到这个值</h3><ul><li>get方法是先取出当前线程的ThreadLocalMap，然后调用map.getEntry方法，把本ThreadLocal的引用作为参数传入，取出map中属于本ThreadLocal的value</li><li>注意，这个map以及map中的key和value都是保存在线程中的，而不是保存在ThreadLocal中</li></ul><h3 id="void-remove-删除对应这个线程的值"><a href="#void-remove-删除对应这个线程的值" class="headerlink" title="void remove():删除对应这个线程的值"></a>void remove():删除对应这个线程的值</h3><h2 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h2><ul><li>ThreadLocalMap类，也就是Thread.thrreadLocals</li><li>ThreadLocalMap类是每个线程Thread类里面的变量，里面最重要的是一个键值对数组Entry[] table，可以认为是一个map，键值对：<br>  键：这个THreadLocal<br>  值：实际需要的成员变量，比如user或者simpleDateFormat对象</li></ul><h2 id="ThreadLocal注意点"><a href="#ThreadLocal注意点" class="headerlink" title="ThreadLocal注意点"></a>ThreadLocal注意点</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul><li>什么是内存泄漏：某个对象不再有用，但是占用的内存却不能被回收。</li><li>弱引用的特点是，如果这个对象制备弱引用关联（没有任何强引用关联），那么这个对象就可以被回收。</li><li>所以弱引用不会阻止GC，因此这个弱引用的机制</li></ul><h3 id="Value的泄漏"><a href="#Value的泄漏" class="headerlink" title="Value的泄漏"></a>Value的泄漏</h3><ul><li>ThreadLocalMap的每个Entry都是一个对key的弱引用，同时，每个Entry都包含了一个对value的强引用</li><li>正常情况下，当线程终止，保存在ThreadLocal里的value会被垃圾回收，因为没有任何强引用了。</li><li>但是，如果线程不重质（比如线程需要保持很久），那么key对应的value就不能被回收，因为有以下的调用链<br>  <code>Thread————&gt;ThreadLocalMap————&gt;Entry(key为null)————&gt;Value</code></li><li>因为value和Thread之间还存在这个强引用链路，所以导致value无法回收，就可能会出现OOM</li><li>JDK已经考虑到了这个问题，所以在set，remove，rehash方法中会扫描key为null的Entry，并把对应的Value设置为null，这样value对象就可以被回收。</li><li>但是如果一个ThreadLocal不被使用，那么实际上set，remove，rehash方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了value的内存泄漏</li></ul><h3 id="如何避免内存泄漏（阿里规约）"><a href="#如何避免内存泄漏（阿里规约）" class="headerlink" title="如何避免内存泄漏（阿里规约）"></a>如何避免内存泄漏（阿里规约）</h3><ul><li>调用remove方法，就会删除对应的Entry对象，可以避免内存泄漏，所以使用完ThreadLocal之后，应该调用remove方法</li></ul><h3 id="THreadLocal注意点"><a href="#THreadLocal注意点" class="headerlink" title="THreadLocal注意点"></a>THreadLocal注意点</h3><ul><li>空指针异常<ul><li>在进行get之前，必须先set，否则可能会报空指针异常？<br>报错的原因是装箱拆箱导致的，不是set、get的问题</li></ul></li><li>共享对象<ul><li>如果在每个线程中ThreadLocal.set()进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。</li></ul></li><li>如果可以不适用ThreadLocal就解决问题，那么不要强行使用<ul><li>例如在任务数很少的时候，在局部变量中额可以新建对象就可以解决问题，那么就不需要使用到ThreadLcoal</li></ul></li><li>优先使用框架的支持，而不是自己创造<ul><li>例如在Spring中，如果可以使用RequestContextHolder，那么就不需要自己维护ThreadLocal，因为自己可能会忘记戴奥用remove()方法等，造成内存泄露</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="undefined2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="线程池的自我介绍"><a href="#线程池的自我介绍" class="headerlink" title="线程池的自我介绍"></a>线程池的自我介绍</h2><ul><li>如果不使用线程池，每个任务都新开一个线程处理<ul><li>一个线程</li><li>for循环创建线程</li><li>当任务数量上升到1000</li></ul></li><li>这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建闭关销毁线程锁带来的开销问题。</li></ul><h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><ul><li><p>问题一：反复创建线程开销大</p></li><li><p>问题二：过多的线程会占用太多内存</p></li><li><p>解决以上两个问题的思路</p><ul><li>用少量的线程————避免内存占用过多</li><li>让这部分线程都保持工作且可用反复执行任务————避免生命周期的损耗</li></ul></li></ul><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ul><li>加快响应速度</li><li>合理利用CPU和内存</li><li>统一管理</li></ul><h3 id="线程池使用应用的场合"><a href="#线程池使用应用的场合" class="headerlink" title="线程池使用应用的场合"></a>线程池使用应用的场合</h3><ul><li>服务器接收到大量请求时，使用线程池技术时非常合适的，他可以大大减少线程的创建和销毁次数，提高服务器的工作效率</li><li>实际上，在开发中，如果需要创建5个以上的线程，那么就可用使用线程池来管理</li></ul><h2 id="创建和停止线程池"><a href="#创建和停止线程池" class="headerlink" title="创建和停止线程池"></a>创建和停止线程池</h2><h3 id="线程池构造函数的参数"><a href="#线程池构造函数的参数" class="headerlink" title="线程池构造函数的参数"></a>线程池构造函数的参数</h3><img src="/2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.png" srcset="undefined" class="" title="线程池构造函数参数"><h4 id="参数中的corePoolSize和maxPoolSize"><a href="#参数中的corePoolSize和maxPoolSize" class="headerlink" title="参数中的corePoolSize和maxPoolSize"></a>参数中的corePoolSize和maxPoolSize</h4><ul><li>corePoolSize指的是核心线程数:线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待会任务到来时。再创建新线程区执行任务</li><li>线程池会可能胡izai核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上线，这就是最大量maxPoolSize</li><li>maximumPoolSize的说明<br>  maximumPoolSize和maxPoolSize的含义相同，不做额外区分。实际上，在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize是相同的就可以了。</li></ul><img src="/2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/maxPoolSize.png" srcset="undefined" class="" title="maxPoolSize"><h5 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h5><ol><li>如果线程小于corePoolSize，即使其他工作线程处于空闲状态，也很会创建一个线程来运行新任务。</li><li>如果线程数等于（或大于）corePoolSize但少于maximumPoolSize，则将任务放入队列。</li><li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务。</li><li>如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。</li></ol><img src="/2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E6%B7%BB%E5%8A%A0%E8%A7%84%E5%88%99.png" srcset="undefined" class="" title="添加规则"><ul><li>是否需要增加线程的判断顺序是：<ul><li>corePoolSize</li><li>workQueue</li><li>maxPoolSize</li></ul></li></ul><h5 id="增减线程的特点"><a href="#增减线程的特点" class="headerlink" title="增减线程的特点"></a>增减线程的特点</h5><ol><li>通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池。</li><li>线程池希望保持较少的线程数，并且只有再负载变得很大时才增加它。</li><li>通过maximumPoolSize为很高的值，例如Interger.MAXVALUE,可用允许线程池容纳任意数量的并发任务。</li><li>是只有再队列填满时才创建多余corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。</li></ol><h4 id="keepAliceTime"><a href="#keepAliceTime" class="headerlink" title="keepAliceTime"></a>keepAliceTime</h4><ul><li>如果线程池当前的线程数多余corePoolSize，那么如果多余的线程共享啊hi见超过keepAliveTime，它们就会被终止。</li></ul><h4 id="ThreadFactory-用来创建线程"><a href="#ThreadFactory-用来创建线程" class="headerlink" title="ThreadFactory 用来创建线程"></a>ThreadFactory 用来创建线程</h4><ul><li>新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory(),创建出来的线程都在同一个线程组，拥有同样的NORM——PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li><li>通常我们用默认的ThreadFactory就可以了</li></ul><h4 id="workQueue工作队列"><a href="#workQueue工作队列" class="headerlink" title="workQueue工作队列"></a>workQueue工作队列</h4><ul><li>有3中最常见的队列类型:<ol><li>直接交接：SynchronousQueue</li><li>无界队列：LinkedBlockingQueue</li><li>有界队列：ArrayBlockingQueue</li></ol></li></ul><h3 id="线程池应该手动创建还是自动创建"><a href="#线程池应该手动创建还是自动创建" class="headerlink" title="线程池应该手动创建还是自动创建"></a>线程池应该手动创建还是自动创建</h3><ul><li>手动创建更好，因为这样可用让我们更加明确线程池的运行规则，避免资源耗尽的风险。</li><li>让我们来看看自动创建线程池（也就是直接调用JDK封装号的构造函数）可能带来哪些问题</li><li>newFixedThreadPool<ul><li>由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法即使处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded at ...</code></li></ul></li><li>newSingleThreadExecutor<ul><li>可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同意的问题，也就是当请求堆积的时候，可能会占用大量的内存。</li></ul></li><li>newCachedThreadPool<ul><li>可缓存线程池</li><li>特点：无界线程池，具有自动回收多余线程的功能<img src="/2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/CachedThreadPool.png" srcset="undefined" class="" title="CachedThreadPool"></li><li>这里的弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE,这可能会创建数量非常多的线程，甚至导致OOM。</li></ul></li><li>newScheduledThreadPool<ul><li>支持定时及周期性任务执行的线程池</li></ul></li></ul><pre><code class="java">new ThreadPoolExecutor(4, 10,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;())</code></pre><h4 id="正确的创建线程池的方法"><a href="#正确的创建线程池的方法" class="headerlink" title="正确的创建线程池的方法"></a>正确的创建线程池的方法</h4><ul><li>根据不同的业务场景，自己设置线程池参数，分析阿里规约的图的第二个例子，比如我们的内存有多大，我们能不能接收任务被拒绝等等。</li></ul><h4 id="线程池里的线程数量设定为多少比较合适"><a href="#线程池里的线程数量设定为多少比较合适" class="headerlink" title="线程池里的线程数量设定为多少比较合适"></a>线程池里的线程数量设定为多少比较合适</h4><ul><li>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右</li><li>耗时IO型（读写数据库、文件、网络读写等）最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的计算方法：</li><li>线程数 = CPU核心数 * （1 + 平均等待时间/平均工作时间）</li></ul><h2 id="常见线程池的特点"><a href="#常见线程池的特点" class="headerlink" title="常见线程池的特点"></a>常见线程池的特点</h2><ul><li>FixedThreaddPool（固定线程）</li><li>CachedThreadPool（可缓存线程池）</li><li>ScheduledThreadPool（周期或定时执行任务）</li><li>SingleThreadExecutor（单线程的线程池）{% asset_img 常见线程池.png 常见线程池%}</li></ul><h2 id="阻塞队列分析"><a href="#阻塞队列分析" class="headerlink" title="阻塞队列分析"></a>阻塞队列分析</h2><ul><li>FixedThreadPool和SingleThreadExecutor的Queue是LinkedBlockingQueue？</li><li>CachedThreadPool使用的Queue是SynchronousQueue？</li><li>Scheduled Thread Pool来说，它使用的是延迟队列DelayedWoekQueue</li><li>workStealingPool是JDK1.8加入的<ul><li>这个线程池和之前的都有很大不同</li><li>子任务（递归）</li><li>窃取</li></ul></li></ul><h2 id="停止线程池的正确方法"><a href="#停止线程池的正确方法" class="headerlink" title="停止线程池的正确方法"></a>停止线程池的正确方法</h2><ol><li>shutdown 作用：当前线程池任务全部结束后关闭线程池，如果shutdown后又有线程池开启线程会抛出异常</li><li>isShutdown 作用：判断是否处于关闭状态（线程正在运行也有可能哦！）</li><li>isTerminated 作用：判断是否彻底处于关闭状态（当前没有正在运行的线程，且线程池处于关闭状态）</li><li>awaitTermination 作用：判断多长时间以内是否关闭了线程池</li><li>shutdownNow 作用：立刻强制关闭线程池，结束当前运行的线程，并抛出异常</li></ol><h3 id="任务太多，怎么拒绝"><a href="#任务太多，怎么拒绝" class="headerlink" title="任务太多，怎么拒绝"></a>任务太多，怎么拒绝</h3><ul><li>拒绝时机<ol><li>当Executor关闭时，提交新任务会被拒绝</li><li>以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时</li></ol></li></ul><h3 id="4种拒绝策略"><a href="#4种拒绝策略" class="headerlink" title="4种拒绝策略"></a>4种拒绝策略</h3><ul><li>AbortPolicy 直接抛出异常</li><li>DiscardPolicy 默默的丢弃</li><li>DiscardOldestPolicy 丢弃最老的任务</li><li>CallerRunsPolicy 谁提交任务，谁执行<br>优点：避免了业务损失；提交的速度降低，主线程一直提交任务，线程池等队列都满以后，主线程开始执行提交的线程；执行期间，线程池会执行完毕，给线程池一个缓冲的时间。</li></ul><h3 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h3><ul><li>每个任务执行前后</li><li>日志、统计</li></ul><pre><code class="java">package MultithReading.threadpool;import java.util.concurrent.*;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * @Description 演示每个任务执行前后放钩子函数 * @Author Matthew * @Date 2020/3/16 15:04 * @Version 1.0 */public class PauseableThreadPool extends ThreadPoolExecutor {    private boolean isPaused;    private final ReentrantLock lock = new ReentrantLock();    private Condition unPaused = lock.newCondition();    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);    }    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);    }    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);    }    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);    }    @Override    protected void beforeExecute(Thread t, Runnable r) {        super.beforeExecute(t, r);        lock.lock();        try {            while (isPaused) {                unPaused.await();            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    private void pause() {        lock.lock();        try {            isPaused = true;        } catch (Exception e) {        } finally {            lock.unlock();        }    }    public void resume() {        lock.lock();        try {            isPaused = false;            unPaused.signalAll();        }finally {            lock.unlock();        }    }    public static void main(String[] args) throws InterruptedException {        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;());        Runnable runnable = new Runnable() {            @Override            public void run() {                System.out.println(&quot;我被执行&quot;);                try {                    Thread.sleep(10);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        };        for (int i = 0; i &lt; 10000; i++) {            pauseableThreadPool.execute(runnable);        }        Thread.sleep(1500);        pauseableThreadPool.pause();        System.out.println(&quot;线程池被暂停了&quot;);        Thread.sleep(1500);        pauseableThreadPool.resume();        System.out.println(&quot;线程池被恢复了&quot;);    }}</code></pre><h2 id="线程池组成部分"><a href="#线程池组成部分" class="headerlink" title="线程池组成部分"></a>线程池组成部分</h2><ul><li>线程池组成部分<ul><li>线程池管理器</li><li>工作线程</li><li>任务列队</li><li>任务接口（Task）</li></ul></li></ul><p>线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，大家都是什么关系？</p><img src="/2020/03/15/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" srcset="undefined" class="" title="线程池"><p>虽然声明线程池的时候是new ThreadPoolExecutor但是返回的时候是ExecutorService，所以一般我们把ExecutorService当作线程池。</p><h3 id="线程池实现任务复用的原理"><a href="#线程池实现任务复用的原理" class="headerlink" title="线程池实现任务复用的原理"></a>线程池实现任务复用的原理</h3><ul><li>相同线程执行不同任务</li></ul><pre><code class="java">if (workerCountOf(c) &lt; corePoolSize)    if (addWorker(command, true))        return;进入addWorkerw = new Worker(firstTask);进入Worker找runWorker我们发现相同的线程执行的Runnable的run方法不一样Runnable task = w.firstTask;task.run();</code></pre><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><ul><li>RUNNING：接受新任务并处理排队任务</li><li>SHUTDOWN：不接受新任务，但处理排队任务</li><li>STOP：不接受新任务，也不处理排队任务，并中断正在进行的任务</li><li>TIDYING，中文是整洁，理解了中文就容易理解这个状态了：所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate（）钩子方法。</li><li>TERMINATED：terminate（）运行完成</li></ul><h3 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h3><ul><li>避免任务堆积</li><li>避免线程数过度增加</li><li>排查线程泄漏</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>死锁</title>
    <link href="undefined2020/03/12/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/"/>
    <url>2020/03/12/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><ul><li>发生在并发中</li><li>互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁<img src="/2020/03/12/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/%E6%AD%BB%E9%94%81.png" srcset="undefined" class="" title="死锁"><img src="/2020/03/12/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/%E6%AD%BB%E9%94%811.png" srcset="undefined" class="" title="死锁1"></li></ul><h2 id="死锁的影响"><a href="#死锁的影响" class="headerlink" title="死锁的影响"></a>死锁的影响</h2><p>死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力</p><ul><li>数据库中：检测并放弃事务</li><li>JVM中：：无法自动处理</li></ul><h3 id="几率不高但危害大"><a href="#几率不高但危害大" class="headerlink" title="几率不高但危害大"></a>几率不高但危害大</h3><ul><li>不一定发生，但是遵守“墨菲定律”</li><li>一旦发生，多是高并发常见，影响用户多</li><li>整个系统崩溃、子系统崩溃、性能降低</li><li>压力测试无法找出所有潜在的死锁</li></ul><h3 id="实际生产中的里斯：转账"><a href="#实际生产中的里斯：转账" class="headerlink" title="实际生产中的里斯：转账"></a>实际生产中的里斯：转账</h3><ul><li>需要两把锁</li><li>获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作</li></ul><h2 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h2><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>循环等待</li></ol><p>缺一不可，这个分析之前的例子</p><h2 id="如何定位死锁"><a href="#如何定位死锁" class="headerlink" title="如何定位死锁"></a>如何定位死锁</h2><ul><li>jstack</li><li>ThreadMXBean代码演示</li></ul><h2 id="修复死锁的策略"><a href="#修复死锁的策略" class="headerlink" title="修复死锁的策略"></a>修复死锁的策略</h2><ul><li>线上问题都需要防患于未然，不造成损失地扑灭几乎已经是不可能</li><li>保存案发现场然后立刻重启服务器</li><li>暂时保证线上服务的安全，然后在利用刚才保存的信息，排查死锁，修改代码，重新发版</li></ul><h3 id="常见修复策略"><a href="#常见修复策略" class="headerlink" title="常见修复策略"></a>常见修复策略</h3><ul><li>避免策略：哲学家就餐的换手方案、转账换序方案</li></ul><h4 id="死锁避免策略"><a href="#死锁避免策略" class="headerlink" title="死锁避免策略"></a>死锁避免策略</h4><ul><li>思路：避免相反的获取锁的顺序</li><li>转账时避免死锁<ul><li>实际上不在乎获取锁的顺序</li><li>通过hashcode来获取决定获取锁的顺序、冲突时需要“加时赛”</li><li>有主键就更方便</li></ul></li></ul><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><img src="/2020/03/12/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90.png" srcset="undefined" class="" title="哲学家就餐"><h4 id="有死锁和资源耗尽的风险"><a href="#有死锁和资源耗尽的风险" class="headerlink" title="有死锁和资源耗尽的风险"></a>有死锁和资源耗尽的风险</h4><ul><li>死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）</li></ul><pre><code class="java">public class DiningPhilosophers {    public static class Philosopher implements Runnable {        private Object lestChopstick;        private Object rightChopstic;        public Philosopher(Object lestChopstick, Object rightChopstic) {            this.lestChopstick = lestChopstick;            this.rightChopstic = rightChopstic;        }        @Override        public void run() {            while (true) {                doAction(&quot;Thinking&quot;);                synchronized (lestChopstick) {                    doAction(&quot;Picked up left chopstick&quot;);                    synchronized (rightChopstic) {                        doAction(&quot;Pick up right chopstick - eating&quot;);                        doAction(&quot;Put down right chopstick&quot;);                    }                    doAction(&quot;Put down left chopstick&quot;);                }            }        }        private void doAction(String action) {            System.out.println(Thread.currentThread().getName() + &quot; &quot; + action);            try {                Thread.sleep((long) (Math.random() * 10));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        Philosopher[] philosophers = new Philosopher[5];        Object[] chopsticks = new Object[philosophers.length];        for (int i = 0; i &lt; chopsticks.length; i++) {            chopsticks[i] = new Object();        }        for (int i = 0; i &lt; philosophers.length; i++) {            Object leftChopstick = chopsticks[i];            Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];            philosophers[i] = new Philosopher(leftChopstick, rightChopstick);            new Thread(philosophers[i], &quot;哲学家&quot; + (i + 1) + &quot;号&quot;).start();        }    }}</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>服务员检查（避免策略）</li><li>改变一个哲学家拿叉子的顺序（避免策略）</li><li>餐票（避免策略）</li><li>领导调节（检测与恢复策略）</li></ul><h3 id="检测与恢复策略"><a href="#检测与恢复策略" class="headerlink" title="检测与恢复策略"></a>检测与恢复策略</h3><ul><li><p>允许发生死锁</p></li><li><p>每次调用锁都记录</p></li><li><p>定期检查“锁的调用链路图”中是否存在环路</p></li><li><p>一旦发生死锁，就用死锁恢复机制进行恢复</p></li><li><p>检测算法：锁的调用链路图</p></li><li><p>恢复方法1：进程终止</p><ul><li>逐个终止线程，直到自锁消除。</li><li>终止顺序：<ol><li>优先级（是前台交互还是后台处理）</li><li>已占用资源，还需要的资源</li><li>已经运行时间</li></ol></li></ul></li><li><p>恢复方法2：资源抢占</p><ul><li>把已经分发出去的锁给收回来</li><li>让线程回退几步，这样就不用结束整个线程，成本比较低</li><li>缺点：可能同一线程一直被抢占，那就造成饥饿</li></ul></li></ul><h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来他就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概览极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复。</p><h2 id="实际工程中如何避免死锁"><a href="#实际工程中如何避免死锁" class="headerlink" title="实际工程中如何避免死锁"></a>实际工程中如何避免死锁</h2><ol><li>设置超时时间<ul><li>Lock的tryLock(long timeout, TimeUnit unit)</li><li>synchronized不具备尝试锁的能力</li><li>造成超时的可能性多：发生了死锁、线程陷入死循环、线程执行很慢</li><li>获取锁失败：打日志、发报警邮件、重启等</li><li>代码演示：退一步海阔天空</li></ul></li><li>多使用并发类而不是自己设计锁<ul><li>ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等</li><li>实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高</li></ul></li><li>尽量降低锁的使用粒度：用不同的锁而不是一个锁</li><li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li><li>给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</li><li>避免锁的嵌套：MustDeadLock类</li><li>分配资源前先看看能不能收回来：银行家算法</li><li>尽量不要几个功能用同一把锁：专锁专用</li></ol><h2 id="其他活性故障"><a href="#其他活性故障" class="headerlink" title="其他活性故障"></a>其他活性故障</h2><ul><li>死锁是最常见的活跃性问题瞒不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题</li><li>活锁</li><li>饥饿</li></ul><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><ul><li>有死锁和资源耗尽的风险<ul><li>死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）</li><li>活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，在等五分钟，又同时拿起这些餐叉</li><li>在实际的计算机问题中，缺乏餐叉可用类比位缺乏共享资源</li></ul></li></ul><h4 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h4><ul><li>虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但程序却得不到进展，为奴为线程始终重复做同样的事</li><li>如果这里死锁，那么就事这里两个人都始终一动不动，直到对方先抬头，它们之间不再说话，只是等待</li><li>如果发生活锁，那么这里的情况就是，双方都不停地对对方说“你先起来吧，你先起来吧”，双方都一直在说话，在运行</li><li>死锁和活锁的结果事一样的，就是谁都不能先抬头</li></ul><h4 id="如何解决活锁问题"><a href="#如何解决活锁问题" class="headerlink" title="如何解决活锁问题"></a>如何解决活锁问题</h4><ul><li>原因：重试机制不变，消息队列始终重试，吃饭始终谦让</li><li>以太网的指数退避算法</li><li>加入随机因素</li></ul><h4 id="工程中的活锁实例：消息队列"><a href="#工程中的活锁实例：消息队列" class="headerlink" title="工程中的活锁实例：消息队列"></a>工程中的活锁实例：消息队列</h4><ul><li>策略：消息如果处理失败，就放在队列开头重试</li><li>由于依赖服务出了问题，处理该消息一直失败</li><li>没阻塞，但程序无法继续</li><li>解决：放在队列尾部、重试限制</li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><ul><li>当线程需要某些资源（例如CPU），但是却始终得不到</li><li>线程的优先级设置过于低，或者又某些线程持有锁同时又无线循环从而不释放锁，或者某程序始终占用某文件的写锁</li><li>饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台相应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程吧CPU资源都占用了，那么前台线程将无法得到很好地执行，这回导致用户的体验很差。</li></ul><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><ol><li><p>写一个必然死锁的例子</p></li><li><p>发生死锁必须满足哪些条件</p><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>循环等待条件</li></ol></li><li><p>如何定位死锁</p><ol><li>jstack</li><li>ThreadMXBean</li></ol></li><li><p>有哪些解决死锁问题的策略</p><ol><li>避免策略：哲学家就餐的换手方案，转账换序方案</li><li>检测与恢复策略:一段实践检测是否又死锁，如果又就剥夺某一个资源，来打开死锁</li><li>鸵鸟策略：鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来他就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概览极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复。</li></ol></li><li><p>讲讲经典的哲学家就餐问题</p><ul><li>服务员检查（避免策略）</li><li>改变一个哲学家拿叉子的顺序（避免策略）</li><li>餐票（避免策略）</li><li>领导调节（检测与恢复策略）</li></ul></li><li><p>实际工程中如何避免死锁</p><ol><li>设置超时时间<ul><li>Lock的tryLock(long timeout, TimeUnit unit)</li><li>synchronized不具备尝试锁的能力</li><li>造成超时的可能性多：发生了死锁、线程陷入死循环、线程执行很慢</li><li>获取锁失败：打日志、发报警邮件、重启等</li><li>代码演示：退一步海阔天空</li></ul></li><li>多使用并发类而不是自己设计锁<ul><li>ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等</li><li>实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高</li></ul></li><li>尽量降低锁的使用粒度：用不同的锁而不是一个锁</li><li>如果能使用同步代码块，就不使用同步方法：自己指定锁对象</li><li>给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践</li><li>避免锁的嵌套：MustDeadLock类</li><li>分配资源前先看看能不能收回来：银行家算法</li><li>尽量不要几个功能用同一把锁：专锁专用</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="undefined2020/03/09/%E5%90%8E%E7%AB%AF/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>2020/03/09/%E5%90%8E%E7%AB%AF/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="饿汉式（静态常量）【可用】"><a href="#饿汉式（静态常量）【可用】" class="headerlink" title="饿汉式（静态常量）【可用】"></a>饿汉式（静态常量）【可用】</h3><pre><code class="java">public class Singleton1 {    private final static Singleton1 INSTANCE = new Singleton1();    private Singleton1(){    }    public static Singleton1 getInstance() {        return INSTANCE;    }}</code></pre><h3 id="饿汉式（静态代码块）（可用）"><a href="#饿汉式（静态代码块）（可用）" class="headerlink" title="饿汉式（静态代码块）（可用）"></a>饿汉式（静态代码块）（可用）</h3><pre><code class="java">public class Singleton2 {    private final static Singleton2 INSTANCE;    static {        INSTANCE = new Singleton2();    }    private Singleton2(){    }    public static Singleton2 getInstance() {        return INSTANCE;    }}</code></pre><h3 id="懒汉式（线程不安全）【不可用】"><a href="#懒汉式（线程不安全）【不可用】" class="headerlink" title="懒汉式（线程不安全）【不可用】"></a>懒汉式（线程不安全）【不可用】</h3><pre><code class="java">public class Singleton3 {    private static Singleton3 INSTANCE;    private Singleton3() {    }    public static Singleton3 getInstance() {        if (INSTANCE == null) {            INSTANCE = new Singleton3();        }        return INSTANCE;    }}</code></pre><h3 id="懒汉式（线程安全）-不推荐"><a href="#懒汉式（线程安全）-不推荐" class="headerlink" title="懒汉式（线程安全）[不推荐]"></a>懒汉式（线程安全）[不推荐]</h3><pre><code class="java">public class Singleton4 {    private static Singleton4 INSTANCE;    private Singleton4() {    }    public synchronized static Singleton4 getInstance() {        if (INSTANCE == null) {            INSTANCE = new Singleton4();        }        return INSTANCE;    }}</code></pre><h3 id="懒汉式（线程不安全）-不推荐"><a href="#懒汉式（线程不安全）-不推荐" class="headerlink" title="懒汉式（线程不安全）[不推荐]"></a>懒汉式（线程不安全）[不推荐]</h3><pre><code class="java">public class Singleton5 {    private static Singleton5 INSTANCE;    private Singleton5() {    }    public static Singleton5 getInstance() {        if (INSTANCE == null) {            synchronized (Singleton5.class) {                INSTANCE = new Singleton5();            }        }        return INSTANCE;    }}</code></pre><h3 id="双重检查（推荐面试用）"><a href="#双重检查（推荐面试用）" class="headerlink" title="双重检查（推荐面试用）"></a>双重检查（推荐面试用）</h3><blockquote><p>优点：线程安全；延迟加载；效率较高；</p></blockquote><ul><li>为什么要double-check<ol><li>线程安全</li><li>单check行不行？</li><li>性能问题</li></ol></li><li>为什么要用volatile<ol><li>新建对象实际上有3个步骤</li><li>重排序会带来NPE（空指针）</li><li>防止重排序</li></ol></li></ul><pre><code class="java">public class Singleton6 {    private static Singleton6 INSTANCE;    private Singleton6() {    }    public static Singleton6 getInstance() {        if (INSTANCE == null) {            synchronized (Singleton6.class) {                if (INSTANCE == null) {                    INSTANCE = new Singleton6();                }            }        }        return INSTANCE;    }}</code></pre><p>在这里的双重检查想要防止的，是这种特殊情况：<br>“在第一个线程退出synchronized之前，里面的操作执行了一部分，比如执行了new却还没执行构造函数，然后第一个线程被切换走了，这个时候第二个线程刚刚到第一重检查，所以看到的对象就是非空，就跳过了整个synchronized代码块，获取到了这个单例对象，但是使用其中的属性的时候却不是想要的值。”</p><img src="/2020/03/09/%E5%90%8E%E7%AB%AF/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" srcset="undefined" class="" title="单例模式.png"><h3 id="静态内部类-推荐用"><a href="#静态内部类-推荐用" class="headerlink" title="静态内部类[推荐用]"></a>静态内部类[推荐用]</h3><pre><code class="java">public class Singleton7 {    private Singleton7() {    }    private static class SingletonInstance {        private static volatile Singleton7 INSTANCE = new Singleton7();    }    public static Singleton7 getInstance() {        return SingletonInstance.INSTANCE;    }}</code></pre><h3 id="枚举【推荐用】"><a href="#枚举【推荐用】" class="headerlink" title="枚举【推荐用】"></a>枚举【推荐用】</h3><pre><code class="java">public enum  Singleton8 {    INSTANCE;    public void whatever() {    }}</code></pre><h2 id="不同写法对比"><a href="#不同写法对比" class="headerlink" title="不同写法对比"></a>不同写法对比</h2><ol><li>饿汉：简单，但是没有lazy loading</li><li>懒汉：有线程安全问题</li><li>静态内部类：可用</li><li>双重检查：面试用</li><li>枚举 最好</li></ol><h3 id="用哪种单例的实现方案最好"><a href="#用哪种单例的实现方案最好" class="headerlink" title="用哪种单例的实现方案最好"></a>用哪种单例的实现方案最好</h3><ul><li>Joshua Bloch大神在《Effective Java》中明确表达过的观点：“适用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经称为实现Singleton的最佳方法。”</li><li>写法简单</li><li>线程安全有保障</li><li>避免反序列化破坏单例</li></ul><h3 id="各种写法的适用场合"><a href="#各种写法的适用场合" class="headerlink" title="各种写法的适用场合"></a>各种写法的适用场合</h3><ol><li>最好的方法时利用枚举，因为还可以防止反序列化虫棍创建新的对象；</li><li>非线程同步的方法不能使用；</li><li>如果程序一开始要加载的资源太多，那么就应该使用懒加载；</li><li>饿汉式如果是对象的创建需要配置文件就不适用。</li><li>懒加载虽然好，但是静态内部类这种方式会引入编程复杂性。</li></ol><h3 id="单例模式面试常见问题"><a href="#单例模式面试常见问题" class="headerlink" title="单例模式面试常见问题"></a>单例模式面试常见问题</h3><ul><li>饿汉式的缺点？</li><li>懒汉式的缺点？</li><li>为什么要用double-check？不用就不安全么？</li><li>为什么双重检查模式要用volatile？</li><li>应该如何选择，用哪种单例的实现方案最好？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型</title>
    <link href="undefined2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><ul><li>重要性：Java面试的必考知识点，只有学会了这个，才能说呢真正懂了并发。</li></ul><p>从Java代码到CPU指令的变化过程</p><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/java%E7%BC%96%E8%AF%91.png" srcset="undefined" class="" title="java编译"><p>我们在Java代码中，使用的控制并发的手段例如synchronized关键字，最终也是要转化为CPU指令来生效的，我们来回顾一下从Java代码到最终执行的CPU指令的流程：</p><ol><li>最开始，我们编写的Java代码，是*.java文件</li><li>在编译（javac命令）后，从刚才的<em>.java文件会变出一个新的Java字节码文件（</em>.class）</li><li>JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令</li><li>机器指令可以直接在CPU上运行，也就是最终的程序执行</li></ol><p>而不同的JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别；所以我们在java代码层写的各种Lock，其实最后依赖的是JVM的具体实现（不同版本会有不同实现）和CPU的指令，才能帮我们达到线程安全的效果。<br>由于最终效果依赖处理器，不同处理器结果不一样，这样无法保证并发安全，所以需要一个标准，让多线程运行的结果可预期，这个标准就是JMM。</p><h2 id="三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模型"><a href="#三兄弟：JVM内存结构-VS-Java内存模型-VS-Java对象模型" class="headerlink" title="三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型"></a>三兄弟：JVM内存结构 VS Java内存模型 VS Java对象模型</h2><h3 id="整体方向"><a href="#整体方向" class="headerlink" title="整体方向"></a>整体方向</h3><ul><li>JVM内存结构,和Java虚拟机的<strong>运行时区域</strong>有关。</li><li>Java内存模型，和Java的而<strong>并发</strong>编程有关。</li><li>Java对象模型，和Java对象在<strong>虚拟机中的表现形式</strong>有关。</li></ul><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="undefined" class="" title="JVM内存结构"><ul><li>堆（heap）</li><li>虚拟机栈（VM stack）</li><li>方法区（method）</li><li>本地方法栈</li><li>程序计数器</li></ul><h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" srcset="undefined" class="" title="Java对象模型"><ul><li>Java对象自身的存储模型</li><li>JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。</li><li>当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了<strong>对象头</strong>以及<strong>实例数据</strong>。</li></ul><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p>JMM（Java Memory Model）是规范</p><p>为什么需要JMM？</p><ul><li><p><strong>C</strong>语言不存在内存模型的概念</p></li><li><p>依赖处理器，不同处理器结果不一样</p></li><li><p><strong>无法保证</strong>并发安全</p></li><li><p>需要一个标准，让多线程运行的结果可预期</p></li><li><p>JMM是一组规范，需要各个JVM的实现来遵循JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。</p></li><li><p>如果没有这样的一个JMM内u才能模型来规范，那么很可能经过了不同JVM的不同规准的重排序之后，呆滞不同的虚拟机上运行的结果不一样，那是很大的问题。</p></li></ul><h3 id="JMM是工具类和关键字的原理"><a href="#JMM是工具类和关键字的原理" class="headerlink" title="JMM是工具类和关键字的原理"></a>JMM是工具类和关键字的原理</h3><ul><li>volatile、synchronized、Lock等的原理都是JMM</li><li>如果没有JMM，那就需要我们自己指定什么时候用内存栅栏等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序。</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><ul><li>什么是重排序<br>  在线程1内部的两行代码的实际执行顺序和代码在Java文件种的顺序不一致，代码指令并不是严格按照代码语句顺序执行的，它们的顺序被改变了，这就是重排序，这里被颠倒的是y=a和b=1这两行语句。</li><li>重排序的好处：提高处理速度  <img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%8C%87%E4%BB%A4.png" srcset="undefined" class="" title="重排序指令">  编译器优化：包括JVM，JIT编译器等<br>  CPU指令重排：就算编译器不发生重排，CPU也可能堆指令进行重排<br>  内存的“重排序”：线程A的修改线程B却看不到，引出可见性问题</li><li>重排序的3种情况：编译器优化、CPU指令重排、内存的“重排序”<ul><li>编译器优化<br>编译器（包括JVM，JIT编译器等）出于优化的目的（例如当前有了数据a，那么如果把对a的操作放到一起效率会更高，避免了读取b后又返回来重新读取a的时间开销），在编译的过程中会进行一定程度的重排，导致生成的机器指令和之前的字节码的顺序不一致。<br>在刚才的例子中，编译器将y=a和b=1这两行语句换了顺序（也可能是线程2的两行换了顺序，同理），因为它们之间没有数据依赖关系，那就不难得到 x =0，y = 0 这种结果了。</li><li>指令重排序<br>CPU 的优化行为，和编译器优化很类似，是通过乱序执行的技术，来提高执行效率。所以就算编译器不发生重排，CPU 也可能对指令进行重排，所以我们开发中，一定要考虑到重排序带来的后果。</li><li>内存的“重排序”<br>在刚才的例子中，假设没编译器重排和指令重排，但是如果发生了内存缓存不一致，也可能导致同样的情况：线程1 修改了 a 的值，但是修改后并没有写回主存，所以线程2是看不到刚才线程1对a的修改的，所以线程2看到a还是等于0。同理，线程2对b的赋值操作也可能由于没及时写回主存，导致线程1看不到刚才线程2的修改。</li></ul></li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="为什么会有可见性问题"><a href="#为什么会有可见性问题" class="headerlink" title="为什么会有可见性问题"></a>为什么会有可见性问题</h3><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png" srcset="undefined" class="" title="可见性问题"><ul><li>CPU有<strong>多级缓存</strong>，导致读的数据过期<ul><li>高速缓存的<strong>容量</strong>比主内存小，但是<strong>速度</strong>劲卒於寄存器，所以在CPU和主内存之间就多了Cache层</li><li>线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。</li><li>如果所有个核心都只用一个缓存，那么也就不存在内存可见性问题了。</li><li>每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。</li></ul></li></ul><h3 id="JMM的抽象：主内存和本地内存"><a href="#JMM的抽象：主内存和本地内存" class="headerlink" title="JMM的抽象：主内存和本地内存"></a>JMM的抽象：主内存和本地内存</h3><ul><li>Java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念。</li><li>这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。</li></ul><h4 id="什么是主内存和本地内存"><a href="#什么是主内存和本地内存" class="headerlink" title="什么是主内存和本地内存"></a>什么是主内存和本地内存</h4><ul><li>Java作为高级语言，屏蔽了这些底层细节，用JMM定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM抽象了主内存和本地内存的概念。</li><li>这里说的本地内存并不是真的是一块给每个线程分配的内存，而是JMM的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。</li></ul><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98.png" srcset="undefined" class="" title="主内存和本地内存"><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E4%B8%BB%E5%86%85%E5%AD%98.png" srcset="undefined" class="" title="主内存和本地内存"><ul><li>JMM有以下规定：<ol><li>所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝。</li><li>线程布恩那直接读写主内存中的变量，而是只能操作自己工作内存中的变量，然后再同步到主内存中。</li><li>主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成。<br>所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。</li></ol></li></ul><h3 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h3><ul><li>happens-before规则是用来解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before。</li><li>两个操作可以用happens-before来确定它们的执行顺序：如果一个操作happens-before于另一个操作，那么我们说第一个操作对于第二个操作时可见的。</li></ul><h4 id="什么不是happens-begore"><a href="#什么不是happens-begore" class="headerlink" title="什么不是happens-begore"></a>什么不是happens-begore</h4><ul><li>两个线程没有相互配合的机制，所以代码X和Y的执行结果并不能保证总被对方看到的，这就不具备happens-before。</li><li>两个操作可以用happens-before来确定它们的执行顺序：如果一个操作happens-before于另一个操作，那么我们说第一个操作对于第二个操作时可见的。</li></ul><h4 id="Happens-Before规则有哪些"><a href="#Happens-Before规则有哪些" class="headerlink" title="Happens-Before规则有哪些"></a>Happens-Before规则有哪些</h4><ol><li>单线程规则<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png" srcset="undefined" class="" title="单线程规则"></li><li>锁操作（synchronized和Lock）<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E9%94%81%E6%93%8D%E4%BD%9C.png" srcset="undefined" class="" title="锁操作"><img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E9%94%81%E6%93%8D%E4%BD%9C2.png" srcset="undefined" class="" title="锁操作"></li><li>volatile变量<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/volatile%E5%8F%98%E9%87%8F.png" srcset="undefined" class="" title="volatile变量"></li><li>线程启动<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8.png" srcset="undefined" class="" title="线程启动"></li><li>线程join<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/JVM/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E7%A8%8Bjoin.png" srcset="undefined" class="" title="线程join"></li><li>传递性：如果hb(A,B)而且hb(B,C),那么可以推出hb(A,C)</li><li>中断：一个线程被其他线程interrupt时，那么检查中断（isInterrupted）或者抛出InterruptedException一定能看到。</li><li>构造方法：对象构造方法的最后一行指令happens-before于finalize()方法的第一行指令</li><li>工具类的Happens-Before原则<ol><li>线程安全的容器get一定能看到在此之前的put等存入操作</li><li>CountDownLatch</li><li>Senaohore</li><li>Future</li><li>线程池</li><li>CyclicBarrier</li></ol></li></ol><h4 id="happens-before演示"><a href="#happens-before演示" class="headerlink" title="happens-before演示"></a>happens-before演示</h4><pre><code class="java">public class FieldVisibility {    int a = 1;    volatile int b = 2;    private void change() {        a = 3;        b = a;    }    private void print() {        System.out.println(&quot;b = &quot; + b + &quot;; a = &quot; + a);    }    public static void main(String[] args) {        while (true) {            FieldVisibility test = new FieldVisibility();            new Thread(()-&gt;{                try {                    Thread.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                test.change();            }).start();            new Thread(()-&gt;{                try {                    Thread.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                test.print();            }).start();        }    }}</code></pre><ul><li>happens-before有一个原则是：如果A是对volatile变量的写操作，B是对同一个百年来的操作，那么hb(A,B)</li><li>分析这四种情况：<br>a=3,b=2<br>a=1,b=2<br>a=3,b=3</li><li>第四种情况（概览低）：没给b加volatile，那么有可能出现a=1，b=3.因为a虽然被修改了，但是其他线程不可见，而b恰好其他线程可见，这就造成了b=3，a=1.</li><li>近朱者赤：给x加了volatile，不仅x被影响，也可以实现轻量级同步</li><li>b之前的写入（对应代码b = a）对读取b后的代码（print b）都可见，所以子啊writerThread里对a的赋值，一定会对readerThread里的读取可见，所以这里的a即使不加volatile，只要b读到是3，就可以由happens-before原则保证了读取到的都是3而不可能读取到1.</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><h4 id="volatile是什么"><a href="#volatile是什么" class="headerlink" title="volatile是什么"></a>volatile是什么</h4><ul><li>volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为适用volatile并不会发生上下文切换等开销很大的行为。</li><li>如果一个变量被修饰成volatile，那么JVM就知道了这个变量可能会被并发修改。</li><li>但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile尽在很有限的场景下才能发挥作用。</li></ul><h4 id="volatile的适用场合"><a href="#volatile的适用场合" class="headerlink" title="volatile的适用场合"></a>volatile的适用场合</h4><ul><li>不适用：a++</li><li>适用场合1：boolean flag，如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来 代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全。</li><li>适用场合2：作为刷新之前变量的触发器。</li></ul><pre><code class="java">public class FieldVisibility {    int abc = 1;    int abcd = 1;    int a = 1;    volatile int b = 2;    private void change() {        abc = 30;        abcd = 42;        a = 3;        b = a;    }    private void print() {        System.out.println(&quot;b = &quot; + b + &quot;; a = &quot; + a + &quot;; abc = &quot; + abc + &quot;; abcd = &quot; + abcd);    }    public static void main(String[] args) {        while (true) {            FieldVisibility test = new FieldVisibility();            new Thread(()-&gt;{                try {                    Thread.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                test.change();            }).start();            new Thread(()-&gt;{                try {                    Thread.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                test.print();            }).start();        }    }}</code></pre><h4 id="volatile的作用：可见性、禁止重排序"><a href="#volatile的作用：可见性、禁止重排序" class="headerlink" title="volatile的作用：可见性、禁止重排序"></a>volatile的作用：可见性、禁止重排序</h4><ol><li>可见性：读一个volatile变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个volatile属性会立即刷入到主内存。</li><li>禁止指令重排序优化：解决单例双重锁乱序问题。</li></ol><h4 id="volatile和synchronized的关系"><a href="#volatile和synchronized的关系" class="headerlink" title="volatile和synchronized的关系"></a>volatile和synchronized的关系</h4><ul><li>volatile在这方面可以看做是轻量版的synchronized：如果一个共享变量自始至终制备各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是由原子性的，而volatile由保证了可见性，所以就足以保证线程安全。</li></ul><h4 id="学以致用用volatile修正重排序问题"><a href="#学以致用用volatile修正重排序问题" class="headerlink" title="学以致用用volatile修正重排序问题"></a>学以致用用volatile修正重排序问题</h4><ul><li>OutOfOrderExecution类加了volatile后，用于不会出现（0，0）的情况了</li></ul><pre><code class="java">package MultithReading.threadcoreknowledge.jmm;import java.util.concurrent.CountDownLatch;/** * @Description TODO * 演示重排序的现象 * “直到某个条件才停止”，测试小概率事件 * 这4行代码的执行顺序决定了最终x和y的结果，一共有3种情况： * 1. a=1;x=b(0);b=1;y=a(1),最终的结果是x=0，y=1 * 2. b=1;y=a(0);a=1;x=b(1),最终的结果是x=1,y=0 * 3. b=1;a=1;x=b(1);y=a(1),最终的及格过是x=1，y=1 * 会出现x=0，y=0？那是因为重排序发生了，4行代码的执行顺序的其中一种可能： * y=a； * a=1； * x=b； * b=1； * 第701446次（0,0) * @Author Matthew * @Date 2020/3/8 10:41 * @Version 1.0 */public class OutOfOrderExecution {    private volatile static int x = 0, y = 0;    private volatile static int a = 0, b = 0;    public static void main(String[] args) throws InterruptedException {        int i = 0;        for (; ; ) {            i++;            x = 0;            y = 0;            a = 0;            b = 0;            CountDownLatch latch = new CountDownLatch(1);            Thread one = new Thread(() -&gt; {                try {                    latch.await();                } catch (InterruptedException e) {                    e.printStackTrace();                }                a = 1;                x = b;            });            Thread two = new Thread(() -&gt; {                try {                    latch.await();                } catch (InterruptedException e) {                    e.printStackTrace();                }                b = 1;                y = a;            });            one.start();            two.start();            latch.countDown();            one.join();            two.join();            String result = &quot;第&quot; + i + &quot;次（&quot; + x + &quot;,&quot; + y + &quot;)&quot;;            System.out.println(result);            if (x == 0 &amp;&amp; y == 0) {                break;            }        }    }}</code></pre><h4 id="volatile小结"><a href="#volatile小结" class="headerlink" title="volatile小结"></a>volatile小结</h4><ol><li><p>voaltile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag；或者作为触发器，实现轻量级同步。</p></li><li><p>volatile属性的读写操作都是无锁的，它不饿能替代synchronized，因为他没有提供原子性和互斥性。因为无锁不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</p></li><li><p>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</p></li><li><p>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile属性不会被线程缓存，始终从主存中读取。</p></li><li><p>volatile提供了happends-before保证，对volatile变量的v的写入happends-before所有其他线程后续对v的读操作。</p></li><li><p>volatile可以使得long和double的赋值时原子的。</p></li></ol><h3 id="能保证可见性的措施"><a href="#能保证可见性的措施" class="headerlink" title="能保证可见性的措施"></a>能保证可见性的措施</h3><ul><li>除了volatile可以让变量保证可见性外，synchronized、Lock、并发集合、Thread.join()和Thread.start()等都可以保证的的可见性</li></ul><h3 id="升华：对synchronized可见性的正确理解"><a href="#升华：对synchronized可见性的正确理解" class="headerlink" title="升华：对synchronized可见性的正确理解"></a>升华：对synchronized可见性的正确理解</h3><ul><li>synchronized不仅保证了原子性，还保证了可见性</li><li>synchronized不仅让保护的代码安全，还近朱者赤（保证synchronized之前的代码都被看到）</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h3><ul><li>一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半的情况，是不可分割的。</li><li>ATM里取钱</li><li>i++不是原子性的</li></ul><h3 id="Java中的原子操作有哪些"><a href="#Java中的原子操作有哪些" class="headerlink" title="Java中的原子操作有哪些"></a>Java中的原子操作有哪些</h3><ul><li>除了long和double之外的基本类型（int,byte,boolean,shot,char,float)的赋值操作</li><li>所有引用reference的赋值操作，不管是32位的机器还是64位的机器</li><li>java.concurrent.Atomic.*包中所有类的原子操作</li></ul><h3 id="long和double的原子性"><a href="#long和double的原子性" class="headerlink" title="long和double的原子性"></a>long和double的原子性</h3><ul><li>问题描述：官方文档、对于64位的值的写入，可以分为两个32位的操作进行写入、读取错误、适用volatile解决</li><li>结论:在32位上的JVM上，long和double的操作不是原子的，但是在64位的JVM上是原子的。</li><li>实际开发中：商用Java虚拟机中不会出现</li></ul><h3 id="原子操作-原子操作-！-原子操作"><a href="#原子操作-原子操作-！-原子操作" class="headerlink" title="原子操作 + 原子操作 ！= 原子操作"></a>原子操作 + 原子操作 ！= 原子操作</h3><ul><li>简单地把原子操作组合在一起，并不能保证整体依旧具有原子性</li><li>比如我去ATM机两次取钱时两次独立的原子操作，但是期间有可能银行卡被借给女朋友，也就是被其他线程打断并被修改。</li><li>全同步的HashMap也不完全安全</li></ul><h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><h3 id="JMM应用实例：单例模式8中写法、单例和并发的关系（真实面试超高频考点）"><a href="#JMM应用实例：单例模式8中写法、单例和并发的关系（真实面试超高频考点）" class="headerlink" title="JMM应用实例：单例模式8中写法、单例和并发的关系（真实面试超高频考点）"></a>JMM应用实例：单例模式8中写法、单例和并发的关系（真实面试超高频考点）</h3><ul><li><p>单例模式的作用</p><ol><li>为什么需要单例？<br>节省内存和计算<br>保证结果正确</li></ol></li><li><p>单例模式适用场景</p><ol><li>无状态的工具类：比如日志工具类，不管是在哪里适用，我们需要的知识它帮我们记录日志信息，除此之外，并不需要在它的实例对象上存储任何状态，这时候我们就只需要一个实例对象即可。</li><li>全局信息类：比如沃恩在一个类上记录网站的访问次数，我们不希望有的访问被记录在对象A上，有的却记录在对象B上，这时候我们就让这个类成为单例。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程八大核心面试问题总结</title>
    <link href="undefined2020/03/07/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>2020/03/07/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="常见面试问题总结"><a href="#常见面试问题总结" class="headerlink" title="常见面试问题总结"></a>常见面试问题总结</h2><h3 id="有多少种实现线程的方法"><a href="#有多少种实现线程的方法" class="headerlink" title="有多少种实现线程的方法"></a>有多少种实现线程的方法</h3><p>思路有5点</p><ol><li><p>从不同的角度看，会有不同的答案。</p></li><li><p>典型答案时两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；</p></li><li><p>但是我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，run方法的代码如下：</p><pre><code class="java"> @Override public void run() {     if (target != null){         target.run();     } }</code></pre><p> 方法一和方法二，也就是“继承Thread类然后重写run()和实现Runnable接口并传入Thread类在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：</p><pre><code> 方法一：最终调用target.run() 方法二：run()整个都被重写</code></pre></li><li><p>然后具体展开说其他方式；<br> 还有其他的实现线程的方法，例如线程池等，他们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。</p><ol><li>“<strong>线程池</strong>拆功能键线程也算是一种新建线程的方式”<br> 原理：用的new Thread</li><li>“通过Callable和FutureTask创建线程，也算是一种新建线程的方式”<br> 本质是Runnable接口</li><li>“无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”</li><li>定时器</li><li>匿名内部类</li><li>Lambda表达式</li></ol></li><li><p>结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnabel实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程但是他们的本质都逃不出刚才所说的范围。</p></li></ol><h3 id="实现Runnable接口和继承Thread类哪种方式更好"><a href="#实现Runnable接口和继承Thread类哪种方式更好" class="headerlink" title="实现Runnable接口和继承Thread类哪种方式更好"></a>实现Runnable接口和继承Thread类哪种方式更好</h3><ol><li><p>两种方法的本质对比<br> 方法一：最终调用target.run()<br> 方法二：run()整个都被重写</p></li><li><p>方法1（实现Runnable接口）更好<br> 方法2（继承Thread类）的缺点：从代码的架构去考虑run方法应该和Thread类应该时解耦的；</p><pre><code> 如果想新建一个任务只能够新建一个线程，而新建线程的损耗是比较大的，所以方法1好在资源的节约上； Java无法双继承，限制了它的可扩展性。</code></pre></li></ol><h3 id="一共线程两次调用start（）方法会出现什么情况？为什么"><a href="#一共线程两次调用start（）方法会出现什么情况？为什么" class="headerlink" title="一共线程两次调用start（）方法会出现什么情况？为什么"></a>一共线程两次调用start（）方法会出现什么情况？为什么</h3><p>start的启动流程</p><ol><li>检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行种或者已结束的线程，都不能再次启动，详见CantStartTwice10类）</li><li>被加入线程组</li><li>调用start0()方法启动线程<br>注意点：<br>start方法是被synchronized修饰的方法，可以保证线程安全；由JVM创建的main方法线程和system组线程，并不会通过start来启动。</li></ol><p>但是如果两次调用start（）方法会抛出异常IllegalThreadStateException</p><h3 id="既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢"><a href="#既然start-方法会调用run-方法，为什么我们选择调用start-方法，而不是直接调用run-方法呢" class="headerlink" title="既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢"></a>既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢</h3><p>调用start方法是启动一个新线程，会进行以下三个步骤：</p><ul><li>启动新线程检查线程状态</li><li>加入线程组</li><li>调用start0()</li></ul><p>而直接调用run方法并不会声明一个新的线程而是和普通类调用方法那样执行，还是只有main线程。</p><h3 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h3><ol><li>原理：用interrupt来请求、好处</li><li>想停止线程，要求方、被停止方、子方法被调用方相互配合</li><li>最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况</li></ol><p>原理：用interrupt来请求线程停止而不是强制，好处是安全<br>想停止线程，要求方、被停止方、子方法被调用方相互配合才行：<br>a）作为被停止方：每次循环中或者适时检查中断信号，并且在可能抛出InterruptedException的地方处理该中断信号；<br>b）请求方：发出中断信号；<br>c）子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态；<br>最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况。</p><h3 id="如何处理不可中断的阻塞"><a href="#如何处理不可中断的阻塞" class="headerlink" title="如何处理不可中断的阻塞"></a>如何处理不可中断的阻塞</h3><p>根据不同的类调用不同的方法<br>如果线程阻塞时由于调用了wait(),sleep()或join()方法，你可用中断线程，通过抛出InterruptedException异常来唤醒该线程。<br>但是对于不能响应InterruptedException的阻塞，很遗憾并没有一共同一的解决方案。<br>但是我们可用利用特定的其他的可用响应的中断方法，比如ReentranLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。<br>答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。<br>总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药。</p><h3 id="线程有哪几种状态，生命周期是什么"><a href="#线程有哪几种状态，生命周期是什么" class="headerlink" title="线程有哪几种状态，生命周期是什么"></a>线程有哪几种状态，生命周期是什么</h3><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>Time Waiting</li><li>Terminated<img src="/2020/03/07/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%AB%E5%A4%A7%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="undefined" class="" title="线程的生命周期"></li></ul><h3 id="用程序实现两个线程交替打印0-100的奇偶数"><a href="#用程序实现两个线程交替打印0-100的奇偶数" class="headerlink" title="用程序实现两个线程交替打印0~100的奇偶数"></a>用程序实现两个线程交替打印0~100的奇偶数</h3><pre><code class="java">package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;/** * @Description TODO * 两个线程交替打印0~100的奇偶数，用wait和notify * @Author Matthew * @Date 2020/3/4 12:19 * @Version 1.0 */public class WaitNotifyPrintOddEvenWait {    private static int count = 0;    private static final Object lock = new Object();    // 1. 拿到锁，我们就打印    // 2. 打印完，唤醒其他线程，自己就休眠    public static void main(String[] args) throws InterruptedException {        new Thread(new TurningRunner(),&quot;偶数&quot;).start();        Thread.sleep(10);        new Thread(new TurningRunner(),&quot;奇数&quot;).start();    }    static class TurningRunner implements Runnable {        @Override        public void run() {            while (count &lt;= 100) {                synchronized (lock) {                    //拿到锁就打印                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + count++);                    lock.notify();                    if (count &lt;= 100) {                        try {                            // 如果任务还没结束，就让出lock锁，让本线程休眠                            lock.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                }            }        }    }}</code></pre><pre><code class="java">package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;/** * @Description TODO * 两个线程交替打印0~100的奇偶数，用synchronized关键字实现 * @Author Matthew * @Date 2020/3/4 12:08 * @Version 1.0 */public class WaitNotifyPrintOddEvenSyn {    // 新建两个线程    // 1个只处理偶数，第二个处理奇数（用位运算）    // 用synchronized来通信    private static int count;    private static final Object lock = new Object();    public static void main(String[] args) {        new Thread(()-&gt;{            while (count &lt; 100) {                synchronized (lock) {                    if ((count &amp; 1) == 0) {                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + count++);                    }                }            }        }, &quot;偶数&quot;).start();        new Thread(()-&gt;{            while (count &lt; 100) {                synchronized (lock) {                    if ((count &amp; 1) == 1) {                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + count++);                    }                }            }        }, &quot;奇数&quot;).start();    }}</code></pre><h3 id="手写生产者消费者设计模式"><a href="#手写生产者消费者设计模式" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h3><pre><code class="java">package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;import java.util.Date;import java.util.LinkedList;/** * @Description TODO * 用wait/notify来实现 * @Author Matthew * @Date 2020/3/4 9:40 * @Version 1.0 */public class ProducerConsumerModel {    public static void main(String[] args) {        EventStorage eventStorage = new EventStorage();        Producer producer = new Producer(eventStorage);        Consumer consumer = new Consumer(eventStorage);        new Thread(producer).start();        new Thread(consumer).start();    }}class Producer implements Runnable {    private EventStorage storage;    public Producer(EventStorage storage) {        this.storage = storage;    }    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            storage.put();        }    }}class Consumer implements Runnable {    private EventStorage storage;    public Consumer(EventStorage storage) {        this.storage = storage;    }    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            storage.take();        }    }}class EventStorage{    private int maxSize;    private LinkedList&lt;Date&gt; storage;    public EventStorage() {        maxSize = 10;        storage = new LinkedList&lt;&gt;();    }    public synchronized void put(){        while (storage.size() == maxSize) {            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        storage.add(new Date());        System.out.println(&quot;仓库里有了&quot; + storage.size() + &quot;个产品。&quot;);        notify();    }    public synchronized void take(){        while (storage.size() == 0) {            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        System.out.println(&quot;拿到了&quot; + storage.poll() + &quot;,现在仓库还剩下&quot; + storage.size());        notify();    }}</code></pre><h3 id="为什么wait-需要在同步代码块内使用，而sleep不需要"><a href="#为什么wait-需要在同步代码块内使用，而sleep不需要" class="headerlink" title="为什么wait()需要在同步代码块内使用，而sleep不需要"></a>为什么wait()需要在同步代码块内使用，而sleep不需要</h3><p>为了让通信变得可靠，防止死锁，或者永久等待的发生<br>如果不把wait()、notify()放在代码块中，很有可能执行wait()前，线程突然切过去，这样另一个线程的执行完notify()后切换回来执行wait(),<br>会导致线程执行wait()之后，永远没有线程唤醒，导致了永久等待或者死锁的发生<br>Java设计者考虑到这样的问题，将线程间需要配合的方式放到同步代码块中<br>sleep()是针对单独线程的，和其他线程关系不大，所以不需要放到同步代码块中。</p><h3 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里-而sleep定义在Thread类里"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里-而sleep定义在Thread类里" class="headerlink" title="为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里?而sleep定义在Thread类里"></a>为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里?而sleep定义在Thread类里</h3><p>wait()、notify()、notifyAll()是锁级别的操作，而锁是属于某一个对象的（锁绑定在某一个对象中，而不是线程中）<br>假设将wait()、notify()、notifyAll()定义在线程中，就会造成很大的局限性，这样，每个线程都可以休眠。但是经常会碰到这种情况，某一个线程持有多个锁，并且锁之间是相互配合的。如果将wait()这样的方法定义在Thread类中，就没有办法实现线程之间的配合</p><h3 id="wait方法是属于Object对象的，那调用Thread-wait会怎么样"><a href="#wait方法是属于Object对象的，那调用Thread-wait会怎么样" class="headerlink" title="wait方法是属于Object对象的，那调用Thread.wait会怎么样"></a>wait方法是属于Object对象的，那调用Thread.wait会怎么样</h3><p>Thread类在线程退出的时，会自动执行notify()，使我们的流程受到干扰。</p><pre><code class="java">package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;/** * @Description TODO * 通过讲解join原理，分析出join的代替写法 * @Author Matthew * @Date 2020/3/4 20:36 * @Version 1.0 */public class JoinPrinciple {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(() -&gt; {            try {                Thread.sleep(10000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);        });        thread1.start();        System.out.println(&quot;开始等待子线程运行完毕&quot;);//        thread1.join();        synchronized (thread1) {            thread1.wait();        }        System.out.println(&quot;所以子线程执行完毕&quot;);    }}</code></pre><h3 id="如何选择用notify还是notifyAll"><a href="#如何选择用notify还是notifyAll" class="headerlink" title="如何选择用notify还是notifyAll"></a>如何选择用notify还是notifyAll</h3><p>notify是唤醒1个线程，notifyAll是唤醒所有线程</p><h3 id="notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办"><a href="#notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办" class="headerlink" title="notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办"></a>notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办</h3><p> 竞争锁失败之后，陷入等待状态，等待持有锁的线程释放锁，再去竞争锁。</p><h3 id="用suspend-和resume-来阻塞线程可以吗？为什么"><a href="#用suspend-和resume-来阻塞线程可以吗？为什么" class="headerlink" title="用suspend()和resume()来阻塞线程可以吗？为什么"></a>用suspend()和resume()来阻塞线程可以吗？为什么</h3><p>不可以，因为调用它之后线程使带着锁挂起的，容易产生死锁。</p><h3 id="wait-notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）"><a href="#wait-notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）" class="headerlink" title="wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）"></a>wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）</h3><ul><li>相同<ul><li>阻塞</li><li>响应中断</li></ul></li><li>不同<ul><li>同步方法中</li><li>释放锁</li><li>指定时间线</li><li>所属类</li></ul></li></ul><h3 id="在join期间，线程处于哪种线程状态"><a href="#在join期间，线程处于哪种线程状态" class="headerlink" title="在join期间，线程处于哪种线程状态"></a>在join期间，线程处于哪种线程状态</h3><p>如果没加时间限制，线程处于waiting状态，否则是Time-waiting</p><h3 id="守护线程和普通线程的区别"><a href="#守护线程和普通线程的区别" class="headerlink" title="守护线程和普通线程的区别"></a>守护线程和普通线程的区别</h3><ul><li>守护线程和普通线程的区别<ul><li>整体无区别</li><li>唯一区别在于JVM的离开</li></ul></li></ul><h3 id="我们是否需要给线程设置未守护线程"><a href="#我们是否需要给线程设置未守护线程" class="headerlink" title="我们是否需要给线程设置未守护线程"></a>我们是否需要给线程设置未守护线程</h3><p>不需要</p><h3 id="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样"><a href="#run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样" class="headerlink" title="run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样"></a>run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样</h3><p>不可以抛出异常，如果抛出异常会离开终止执行</p><pre><code class="java">/** * @Description TODO * 自己的MyUncaughtExceptionHanlder * @Author Matthew * @Date 2020/3/5 15:57 * @Version 1.0 */public class MyUncaughtExceptionHanlder implements Thread.UncaughtExceptionHandler {    private String name;    public MyUncaughtExceptionHanlder(String name) {        this.name = name;    }    @Override    public void uncaughtException(Thread t, Throwable e) {        Logger logger = Logger.getAnonymousLogger();        logger.log(Level.WARNING, &quot;线程异常，终止了&quot; + t.getName(), e);        System.out.println(name + &quot;捕获了异常&quot; + t.getName() + &quot;异常&quot; + e);    }}</code></pre><pre><code class="java">public class UseOwnUncaughtExceptionHandler implements Runnable{    public static void main(String[] args) throws InterruptedException {        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHanlder(&quot;捕获器1&quot;));            new Thread(new UseOwnUncaughtExceptionHandler(), &quot;MyThread-1&quot;).start();            Thread.sleep(300);            new Thread(new UseOwnUncaughtExceptionHandler(), &quot;MyThread-2&quot;).start();            Thread.sleep(300);            new Thread(new UseOwnUncaughtExceptionHandler(), &quot;MyThread-3&quot;).start();            Thread.sleep(300);            new Thread(new UseOwnUncaughtExceptionHandler(), &quot;MyThread-4&quot;).start();    }    @Override    public void run() {            throw new RuntimeException();    }}三月 07, 2020 7:07:30 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException警告: 线程异常，终止了MyThread-1java.lang.RuntimeException捕获器1捕获了异常MyThread-1异常java.lang.RuntimeException    at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)    at java.lang.Thread.run(Thread.java:748)三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException捕获器1捕获了异常MyThread-2异常java.lang.RuntimeException警告: 线程异常，终止了MyThread-2java.lang.RuntimeException    at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)    at java.lang.Thread.run(Thread.java:748)捕获器1捕获了异常MyThread-3异常java.lang.RuntimeException三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException警告: 线程异常，终止了MyThread-3java.lang.RuntimeException    at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)    at java.lang.Thread.run(Thread.java:748)捕获器1捕获了异常MyThread-4异常java.lang.RuntimeException三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException警告: 线程异常，终止了MyThread-4java.lang.RuntimeException    at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)    at java.lang.Thread.run(Thread.java:748)</code></pre><h3 id="线程中如何处理某某个未处理异常"><a href="#线程中如何处理某某个未处理异常" class="headerlink" title="线程中如何处理某某个未处理异常"></a>线程中如何处理某某个未处理异常</h3><p>使用全局处理器，对异常进行处理</p><h3 id="什么是多线程的上下文切换"><a href="#什么是多线程的上下文切换" class="headerlink" title="什么是多线程的上下文切换"></a>什么是多线程的上下文切换</h3><p>上下文切换可以认为是内核（操作系统的核心）在CPU上对于进程（包括线程）进行以下的活动：<br>（1）挂起一共进程，将这个进程在CPU中的状态（上下文）存储与内存中的某处，<br>（2）在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复，<br>（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程会导致的问题</title>
    <link href="undefined2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>什么是线程安全？</p><p>《Java Concurrency In Practice》的左子Brian Gortz对“线程安全”有一共比较恰当的定义：“当多个线程访问一个对象是，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p><p>自己的理解：不管业务中遇到怎样的多个线程访问某对象或某方法的情况，而在编程这个业务逻辑的时候，都不需要额外做任何额外的处理（也就是可以想单线程编程一样）程序也可以正常运行（不会因为多线程而出错），就可以称为线程安全。</p><ul><li>线程不安全：get同时set、额外同步</li><li>全都线程安全？：运行速度、设计成本、trade off</li><li>完全不用于多线程：不过度设计</li></ul><h3 id="什么情况下会出现线程安全问题，怎么避免"><a href="#什么情况下会出现线程安全问题，怎么避免" class="headerlink" title="什么情况下会出现线程安全问题，怎么避免"></a>什么情况下会出现线程安全问题，怎么避免</h3><ul><li>运行结果错误：a++多线程下出现消失的请求现象</li><li>活跃性问题：死锁、活锁、饥饿</li><li>对象发布和初始化的时候的安全问题</li></ul><h4 id="什么是逸出"><a href="#什么是逸出" class="headerlink" title="什么是逸出"></a>什么是逸出</h4><ol><li>方法返回一个private对象（private的本意是不让外部访问）</li><li>还未完成初始化（构造函数没完全执行完毕）就把对象提供给外界，比如：<br>在构造函数中未初始化完毕就this赋值<br>隐式逸出————注册监听事件<br>构造函数中运行线程</li></ol><h4 id="如何解决逸出"><a href="#如何解决逸出" class="headerlink" title="如何解决逸出"></a>如何解决逸出</h4><ol><li>返回副本</li><li>利用工厂模式</li></ol><h4 id="各种需要考虑线程安全的情况"><a href="#各种需要考虑线程安全的情况" class="headerlink" title="各种需要考虑线程安全的情况"></a>各种需要考虑线程安全的情况</h4><ul><li>访问<strong>共享</strong>的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等。</li><li>所有依赖<strong>时序</strong>的操作，即使每一步操作都是线程安全的，还是存在并发问题：read-modify-write、check-then-act。</li><li>不同的数据之间存在<strong>捆绑</strong>关系的时候。IP和端口号</li><li>我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题。</li></ul><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><h3 id="为什么多线程会带来性能问题"><a href="#为什么多线程会带来性能问题" class="headerlink" title="为什么多线程会带来性能问题"></a>为什么多线程会带来性能问题</h3><ul><li>调度：上下文切换<ul><li>什么是上下文？保存现场<br>上下文切换可以认为是内核（操作系统的核心）在CPU上对于进程（包括线程）进行以下的活动：<br>（1）挂起一个进程，将这个进程在CPU中的状态（上下文）存储与内存中的某处，<br>（2）在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复，<br>（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。</li><li>缓存开销：缓存失效，CPU重新缓存</li><li>何时会导致密集的上下文切换：抢锁、IO</li></ul></li><li>协作：内存同步<br>  Java内存模型，为了数据的正确性，同步手段往往会使用进制编译器优化、使CPU内的缓存失效</li></ul><h3 id="性能问题有哪些体现、什么是性能问题"><a href="#性能问题有哪些体现、什么是性能问题" class="headerlink" title="性能问题有哪些体现、什么是性能问题"></a>性能问题有哪些体现、什么是性能问题</h3><p>服务器响应慢、吞吐量低、资源消耗（例如内存）过高等<br>虽然不是结果错误，但依然危害巨大<br>引入多线程不能本末倒置</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程异常</title>
    <link href="undefined2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8/"/>
    <url>2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><ul><li><p>线程的未捕获异常UncaughtException应该如何处理？</p></li><li><p>为什么需要UncaughtException?</p><ul><li>主线程可用轻松发现异常，子线程却不行</li><li>子线程异常无法用传统方法捕获</li><li>不能直接捕获的后果、提高健壮性</li></ul></li></ul><h3 id="两个解决方案"><a href="#两个解决方案" class="headerlink" title="两个解决方案"></a>两个解决方案</h3><ul><li>方案一（不推荐）：手动在每个run方法里面进行trycatch</li><li>方案二（推荐）：利用UncaughtExceptionHandler<ul><li>UncaughtExceptionHandler接口</li><li>void uncaughtException(Thread t, Throwable e);</li><li>异常处理器的调用策略</li><li>自己实现<ul><li>给程序统一设置</li><li>给每个线程单独设置</li><li>给线程池设置</li></ul></li></ul></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>Java异常体系</li><li>如何全局处理异常？ 为什么要全局处理？ 不处理行不行？<br>  设置一个自己的全局uncaughtException，不能不处理</li><li>run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？<br>  不可以，如果抛出异常会离开终止执行</li><li>线程中如何处理某个未处理异常？<br>  使用全局处理器，对异常进行处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程各个属性</title>
    <link href="undefined2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E5%B1%9E%E6%80%A7/"/>
    <url>2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="线程各属性"><a href="#线程各属性" class="headerlink" title="线程各属性"></a>线程各属性</h2><img src="/2020/03/05/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E5%B1%9E%E6%80%A7/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7.png" srcset="undefined" class="" title="线程属性"><h3 id="线程Id"><a href="#线程Id" class="headerlink" title="线程Id"></a>线程Id</h3><p>ID从1开始，JVM运行起来后，我们自己创建的线程的ID早已不是2.</p><h3 id="线程名字"><a href="#线程名字" class="headerlink" title="线程名字"></a>线程名字</h3><ul><li>默认线程名字源码分析</li><li>修改线程的名字（setName）</li></ul><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul><li><p>作用：给用户线程提供服务</p></li><li><p>特性：</p><ul><li>线程类型默认继承自父线程</li><li>被谁启动,(由JVM自动启动)</li><li>不影响JVM退出</li></ul></li><li><p>守护线程和普通线程的区别</p><ul><li>整体无区别</li><li>唯一区别在于JVM的离开</li></ul></li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul><li>10个级别，默认5</li><li>程序设计不应依赖于优先级<ul><li>不同操作系统不一样</li><li>优先级会被操作系统改变</li></ul></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>什么时候我们需要设置守护线程？<br> 通常情况下我们不需要设置</li><li>我们如何应用线程优先级来帮助程序运行？有哪些禁忌？<br> 我们不应该用优先级，来作为程序设计的逻辑，因为不同的操作系统有不同的优先级映射</li><li>不同的操作系统如何处理优先级问题？<br> 不用优先级作为程序的设计逻辑</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的7个重要方法</title>
    <link href="undefined2020/03/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%847%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/"/>
    <url>2020/03/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%847%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Thread和Object类中的重要方法详解"><a href="#Thread和Object类中的重要方法详解" class="headerlink" title="Thread和Object类中的重要方法详解"></a>Thread和Object类中的重要方法详解</h2><h3 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览</h3><img src="/2020/03/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%847%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E6%A6%82%E8%A7%88.png" srcset="undefined" class="" title="方法概览"><h3 id="wait-notify-notifyAll方法详解"><a href="#wait-notify-notifyAll方法详解" class="headerlink" title="wait,notify,notifyAll方法详解"></a>wait,notify,notifyAll方法详解</h3><ul><li>用必须先拥有monitor</li><li>notify只能唤醒其中一个</li><li>属于Object类</li><li>类似功能的Condition</li><li>同时持有多个锁的情况，让一个线程wait必须让他释放所有的锁，否则会进入死锁<strong>因为如果程序不运行完，而单一的线程运行完并不会释放这个线程当前持有的锁</strong></li></ul><p>notify唤醒的对象必须是调用wait的对象要不无法唤醒。</p><pre><code class="java">public class WaitNotifyReleaseOwnMonitor {    private static volatile Object resourceA = new Object();    private static volatile Object resourceB = new Object();    public static void main(String[] args) {        Thread thread1 = new Thread(() -&gt; {            synchronized (resourceA) {                System.out.println(&quot;ThreadA got resourceA lock.&quot;);                synchronized (resourceB) {                    System.out.println(&quot;ThreadA got resourceB lock.&quot;);                    try {                        resourceA.wait();                        System.out.println(&quot;ThreadA releases resourceA lock.&quot;);                        resourceA.notify();//将resourceA替换位resourceB无法唤醒Thread1                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread thread2 = new Thread(() -&gt; {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            synchronized (resourceA) {                System.out.println(&quot;ThreadB got resourceA lock.&quot;);                System.out.println(&quot;ThreadB tries to resourceB lock.&quot;);                resourceA.notify();                try {                    resourceA.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;--------&quot;);                synchronized (resourceB) {                    System.out.println(&quot;ThreadB got resourceB lock.&quot;);                }            }        });        thread1.start();        thread2.start();    }}</code></pre><h4 id="wait的作用和用法"><a href="#wait的作用和用法" class="headerlink" title="wait的作用和用法"></a>wait的作用和用法</h4><p>当调用wait方法之后，直到线程中情况值以发生时，才会被唤醒</p><ul><li>另一个线程调用这个对象的notify()方法且刚好被唤醒的时本线程；</li><li>另一个线程调用这个对象的notifyAll()方法；</li><li>过了wait（long timeout）规定的超时时间，如果传入就是永久等待；</li><li>线程自身调用了interrupt()</li></ul><pre><code class="java">public class JoinPrinciple {    public static void main(String[] args) throws InterruptedException {        Thread thread1 = new Thread(() -&gt; {            try {                Thread.sleep(10000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;执行完毕&quot;);        });        thread1.start();        System.out.println(&quot;开始等待子线程运行完毕&quot;);//        thread1.join();        synchronized (thread1) {            thread1.wait();        }        System.out.println(&quot;所以子线程执行完毕&quot;);    }}</code></pre><p>自我理解：虽然下列代码是thread1调用wait方法，但是当前线程是main线程，所以是main函数进入waiting而不是thread1</p><h3 id="sleep方法详解"><a href="#sleep方法详解" class="headerlink" title="sleep方法详解"></a>sleep方法详解</h3><p>作用:我只想让线程再预期的时间执行，其他时候不要占用CPU资源</p><p>sleep方法不释放锁</p><p>sleep方法响应中断<br>    1. 抛出InterruptedException<br>    2. 清楚中断状态</p><p>sleep方法可用让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，知道规定时间后再执行，休眠期间如果被中断，会抛出异常并清楚中断状态。</p><h3 id="join方法作用、用法"><a href="#join方法作用、用法" class="headerlink" title="join方法作用、用法"></a>join方法作用、用法</h3><p>作用：因为新的线程加入了我们，所以我们要等他执行完再出发<br>用法：main等待thread1执行完毕，注意谁等谁</p><ul><li>CountDownLatch或CyclicBarrier类</li></ul><h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>作用：释放我的CPU时间片<br>定位：JVM不保证遵循<br>yield和sleep区别：是否随时可能再次被调度</p><h2 id="手写生产者消费者设计模式"><a href="#手写生产者消费者设计模式" class="headerlink" title="手写生产者消费者设计模式"></a>手写生产者消费者设计模式</h2><p>什么是生产者和消费者模式</p><img src="/2020/03/04/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%847%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.png" srcset="undefined" class="" title="生产者消费者模式"><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread里？<br> wait()、notify()、notifyAll()是锁级别的操作，而锁是属于某一个对象的（锁绑定在某一个对象中，而不是线程中）<br> 假设将wait()、notify()、notifyAll()定义在线程中，就会造成很大的局限性，这样，每个线程都可以休眠。但是经常会碰到这种情况，某一个线程持有多个锁，并且锁之间是相互配合的。如果将wait()这样的方法定义在Thread类中，就没有办法实现线程之间的配合</li><li>用3种方式实现生产者模式</li><li>为什么wait()需要再同步代码块内使用，而sleep()不需要？<br> 为了让通信变得可靠，防止死锁，或者永久等待的发生<br> 如果不把wait()、notify()放在代码块中，很有可能执行wait()前，线程突然切过去，这样另一个线程的执行完notify()后切换回来执行wait(),<br> 会导致线程执行wait()之后，永远没有线程唤醒，导致了永久等待或者死锁的发生<br> Java设计者考虑到这样的问题，将线程间需要配合的方式放到同步代码块中<br> sleep()是针对单独线程的，和其他线程关系不大，所以不需要放到同步代码块中</li><li>wait方法时属于Object对象的，那调用Thread.wait会怎么样？<br> Thread类在线程退出的时，会自动执行notify()，使我们的流程受到干扰。</li><li>notifyAll()之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？<br> 竞争锁失败之后，陷入等待状态，等待持有锁的线程释放锁，再去竞争锁。</li><li>可以用suspend()和resume()来阻塞线程吗，为什么？<br> 由于安全问题被弃用，不推荐使用。推荐使用wait()和notify()</li><li>wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）<ul><li>相同<ul><li>阻塞</li><li>响应中断</li></ul></li><li>不同<ul><li>同步方法中</li><li>释放锁</li><li>指定时间线</li><li>所属类</li></ul></li></ul></li><li>在join期间，线程处于哪种线程状态？<br> 线程处于waiting状态。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命周期</title>
    <link href="undefined2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul><li>New</li><li>Runnable</li><li>Blocked</li><li>Waiting</li><li>Time Waiting</li><li>Terminated</li></ul><img src="/2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="undefined" class="" title="线程的生命周期"><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>一般习惯而言，把Blocked（被阻塞）、Waiting（等待）、Timed_waiting（计时等待）都称为阻塞状态<br>不仅仅是Blocked。</p><h3 id="状态转化的特殊情况"><a href="#状态转化的特殊情况" class="headerlink" title="状态转化的特殊情况"></a>状态转化的特殊情况</h3><ul><li>从Object.wait()状态刚被唤醒时，通常不能立刻抢到monitor锁，那就会从Waiting先进入Blocked状态，抢到锁后再转换到Runnable状态</li><li>如果发生异常，可用直接跳到终止Terminated状态，不必再遵守路径，比如可用从Waiting直接到Terminated</li></ul><h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><ol><li>线程有哪几种状态？生命周期是什么？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何分析native方法</title>
    <link href="undefined2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90native%E6%96%B9%E6%B3%95/"/>
    <url>2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90native%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="分析navative方法"><a href="#分析navative方法" class="headerlink" title="分析navative方法"></a>分析navative方法</h2><ol><li>进入github（也可以进openJDK网站）</li><li>点“搜索文件”，搜索对应的c代码类Thread.c</li><li>找到native方法对应的方法名</li><li>去src/htspot/share/prims/jvm.cpp里看cpp代码</li></ol><img src="/2020/03/03/%E5%90%8E%E7%AB%AF/Java/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90native%E6%96%B9%E6%B3%95/native%E6%BA%90%E7%A0%81.png" srcset="undefined" class="" title="native源码">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java异常体系</title>
    <link href="undefined2020/03/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <url>2020/03/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<img src="/2020/03/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" srcset="undefined" class="" title="Java异常体系"><p>Error和RuntimeException共同构成了非检查异常；<br>IOException受检查异常，应该对其提前进行处理，提供程序的健壮性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程8大核心基础知识</title>
    <link href="undefined2020/03/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>2020/03/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="多线程全部脉络"><a href="#多线程全部脉络" class="headerlink" title="多线程全部脉络"></a>多线程全部脉络</h2><img src="/2020/03/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/0%E5%85%A8%E8%AF%BE%E8%84%89%E7%BB%9C.png" srcset="undefined" class="" title="0全课脉络"><h2 id="多线程8大基础"><a href="#多线程8大基础" class="headerlink" title="多线程8大基础"></a>多线程8大基础</h2><img src="/2020/03/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80.png" srcset="undefined" class="" title="1线程8大核心基础"><h3 id="实现多线程的方法时1种2种还是4种"><a href="#实现多线程的方法时1种2种还是4种" class="headerlink" title="实现多线程的方法时1种2种还是4种"></a>实现多线程的方法时1种2种还是4种</h3><blockquote><p>实现多线程的官方正确方法：2种</p></blockquote><p>Oracle官网文档：<br>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started. The other way to create a thread is to declare a class that implements the Runnable interface.<br>创建一个新的执行线程有两种方法：一个是将一个类声明为Thread的子类，这个子类应该重写run类的方法Thread，然后可以分配并启动子类的实例。另一种方法来创建一个线程是声明实现类Runnable接口。</p><h4 id="两种方法对比"><a href="#两种方法对比" class="headerlink" title="两种方法对比"></a>两种方法对比</h4><ol><li><p>方法1（实现Runnable接口）更好<br> 方法2（继承Thread类）的缺点：从代码的架构去考虑run方法应该和Thread类应该时解耦的；</p><pre><code> 如果想新建一个任务只能够新建一个线程，而新建线程的损耗是比较大的，所以方法1好在资源的节约上； Java无法双继承，限制了它的可扩展性。</code></pre></li><li><p>两种方法的本质对比<br> 方法一：最终调用target.run()<br> 方法二：run()整个都被重写</p></li></ol><h4 id="有多少实现线程的方法"><a href="#有多少实现线程的方法" class="headerlink" title="有多少实现线程的方法"></a>有多少实现线程的方法</h4><ol><li><p>从不同的角度看，会有不同的答案。</p></li><li><p>典型答案时两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；</p></li><li><p>但是我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，run方法的代码如下：</p><pre><code class="java"> @Override public void run() {     if (target != null){         target.run();     } }</code></pre><p> 方法一和方法二，也就是“继承Thread类然后重写run()和实现Runnable接口并传入Thread类在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：</p><pre><code> 方法一：最终调用target.run() 方法二：run()整个都被重写</code></pre></li><li><p>然后具体展开说其他方式；<br> 还有其他的实现线程的方法，例如线程池等，他们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。</p></li><li><p>结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnabel实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程但是他们的本质都逃不出刚才所说的范围。</p></li></ol><h3 id="典型错误观点分析"><a href="#典型错误观点分析" class="headerlink" title="典型错误观点分析"></a>典型错误观点分析</h3><ol><li>“<strong>线程池</strong>拆功能键线程也算是一种新建线程的方式”<br> 原理：用的new Thread</li><li>“通过Callable和FutureTask创建线程，也算是一种新建线程的方式”<br> 本质是Runnable接口</li><li>“无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”</li><li>定时器</li><li>匿名内部类</li><li>Lambda表达式</li></ol><blockquote><p>多线程的实现方式，在代码种写法千变万化，但其本质万变不离其宗。</p></blockquote><h2 id="正确的启动线程"><a href="#正确的启动线程" class="headerlink" title="正确的启动线程"></a>正确的启动线程</h2><h3 id="start-和run-的比较"><a href="#start-和run-的比较" class="headerlink" title="start()和run()的比较"></a>start()和run()的比较</h3><pre><code class="java">Runnable runnable = () -&gt; System.out.println(Thread.currentThread().getName());runnable.run();new Thread(runnable).start();</code></pre><p>运行结果为<br>main<br>Thread-0</p><h4 id="start-方法含义"><a href="#start-方法含义" class="headerlink" title="start()方法含义"></a>start()方法含义</h4><ul><li>启动新线程：向JVM申请启动新线程</li><li>准备工作</li><li>不能重复的执行start()</li></ul><h4 id="start-源码解析"><a href="#start-源码解析" class="headerlink" title="start()源码解析"></a>start()源码解析</h4><ul><li>启动新线程检查线程状态</li><li>加入线程组</li><li>调用start0()</li></ul><p>start方法的执行流程是什么？</p><ol><li>检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行种或者已结束的线程，都不能再次启动，详见CantStartTwice10类）</li><li>被加入线程组</li><li>调用start0()方法启动线程<br>注意点：<br>start方法是被synchronized修饰的方法，可以保证线程安全；由JVM创建的main方法线程和system组线程，并不会通过start来启动。</li></ol><h4 id="run-方法原理解读"><a href="#run-方法原理解读" class="headerlink" title="run()方法原理解读"></a>run()方法原理解读</h4><pre><code class="java">@Overridepublic void run() {    if (target != null) {        target.run();    }}</code></pre><p>通过Thread重写run方法，或者给target赋值为Runnable，调用Runnable的run方法</p><h2 id="正确的停止线程"><a href="#正确的停止线程" class="headerlink" title="正确的停止线程"></a>正确的停止线程</h2><ol><li>原理介绍：使用interrupt来通知，而不是强制</li></ol><p>Java中停止线程的原则是什么？</p><p>在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止点额线程自身拥有决定权（决定是否、以及何时停止）这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。<br>任务和线程的启动很容易。在大多时候，我们都会让它们运行知道结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或者线程，或许是因为用户取消了操作，或者服务需要被快速关闭，或者是运行超时或出错了。<br>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。<strong>Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制</strong>，能够使一个线程终止另一个线程的当前工作。<br>这种协作式的方法使必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：<strong>当需要停止时，它们首先会清楚当前正在执行的工作，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清楚工作。</strong><br>生命周期结束（End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。一个行为良好的软件与勉强运的软件之间的最主要区别就是，行为良好的软件能很完善地处理失败、关闭和取消等过程。</p><h3 id="正确的停止方法：interrupt"><a href="#正确的停止方法：interrupt" class="headerlink" title="正确的停止方法：interrupt"></a>正确的停止方法：interrupt</h3><ul><li><p>通常线程会在什么情况下停止普通情况</p></li><li><p>线程可能被阻塞(例如Thread.sleep)</p></li><li><p>如果线程在每次迭代后都阻塞</p></li><li><p>while内try/catch的问题</p></li><li><p>实际开发中的两种最佳实践</p></li><li><p>响应中断的方法总结列表</p></li></ul><h3 id="实际开发中的两种最佳实践"><a href="#实际开发中的两种最佳实践" class="headerlink" title="实际开发中的两种最佳实践"></a>实际开发中的两种最佳实践</h3><ul><li>优先选择：传递中断</li><li>不想或无法传递：恢复中断</li><li>不应屏蔽中断</li></ul><p>处理中断的最好方法是什么？</p><p>优先选择在方法上抛出异常<br>用throws InterruptedException 标记你的方法，不采用try语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，例如：</p><pre><code class="java">void subTask() throws InterruptedException {    sleep(delay);}</code></pre><p>由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免漏掉或者被吞掉的情况，增强了代码的健壮性。</p><p>如果不能抛出中断，要怎么做？</p><p>如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch子句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。</p><h3 id="错误的停止方法"><a href="#错误的停止方法" class="headerlink" title="错误的停止方法"></a>错误的停止方法</h3><ul><li><p>被弃用的<strong>stop,suspend和resume</strong>方法。<br>  为什么stop被弃用？</p><pre><code>  因为它本质上是不安全的，停止线程会导致它解锁已锁定的所有监视器（monitor）；但是它会使单元数据操作不完整。</code></pre><p>  为什么suspend和resume被弃用？</p><pre><code>  因为调用它之后线程使带着锁挂起的，容易产生死锁。</code></pre></li><li><p>用<strong>volatile</strong>设置<strong>boolean</strong>标记位。<br>  这种做法是错误的，或者说是不够全面的，在某些情况下虽然可用，但是某些情况下有严重问题。<br>  这种方法在《Java并发编程实战》中被明确指出了缺陷，我们一起来看看缺陷在哪里：<br>  此方法错误的原因在于，如果我们遇到了线程长时间阻塞（这是一种很常见的情况，例如生产者消费者模式中就存在这样的情况），就没办法即使唤醒它，<br>  或者永远都无法唤醒该线程，而interrupt设计之初就是把wait等长期阻塞作为一种特殊情况考虑在内了，我们应该用interrupt思维来停止线程。</p></li></ul><img src="/2020/03/01/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B8%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/native%E6%BA%90%E7%A0%81.png" srcset="undefined" class="" title="native源码"><h3 id="判断是否已被中断相关方法"><a href="#判断是否已被中断相关方法" class="headerlink" title="判断是否已被中断相关方法"></a>判断是否已被中断相关方法</h3><ul><li>static boolean interrupted()</li><li>boolean isInterrupted()</li><li>Thread.interrupted()的目的对象</li></ul><h2 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h2><ol><li><p>如何停止线程</p><ol><li><p>原理：用interrupt来请求、好处</p></li><li><p>想停止线程，要求方、被停止方、子方法被调用方相互配合</p></li><li><p>最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况</p><p>原理：用interrupt来请求线程停止而不是强制，好处是安全<br>想停止线程，要求方、被停止方、子方法被调用方相互配合才行：<br>a）作为被停止方：每次循环中或者适时检查中断信号，并且在可能抛出InterruptedException的地方处理该中断信号；<br>b）请求方：发出中断信号；<br>c）子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态；<br>最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况。</p></li></ol></li><li><p>如何处理不可中断的阻塞</p></li></ol><p>根据不同的类调用不同的方法<br>如果线程阻塞时由于调用了wait(),sleep()或join()方法，你可用中断线程，通过抛出InterruptedException异常来唤醒该线程。<br>但是对于不能响应InterruptedException的阻塞，很遗憾并没有一共同一的解决方案。<br>但是我们可用利用特定的其他的可用响应的中断方法，比如ReentranLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。<br>答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。<br>总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全</title>
    <link href="undefined2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <url>2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>数据存储安全<br>应用程序安全<br>操作系统安全<br>网络安全<br>物理安全<br>用户安全教育</p><p>计算机网络上的通信面来以下的四种威胁：<br>（1） 截获–从网络上窃听他人的通信内容。<br>（2） 中断–有意中断他人在网络上的通信<br>（3） 篡改–故意篡改网络上传送的报文<br>（4） 伪造–伪造信息在网络上传送<br>截获信息的攻击称为被动攻击，而更改信息和拒绝用户使用资源的攻击称为主动攻击。</p><h3 id="恶意程序（rogue-program）"><a href="#恶意程序（rogue-program）" class="headerlink" title="恶意程序（rogue program）"></a>恶意程序（rogue program）</h3><ol><li>计算机病毒————会传染其他程序的程序，传染是通过修改其他程序来吧自身或其变种赋值进去完成的。</li><li>计算机蠕虫————通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序。</li><li>特洛伊木马————一种程序，它执行的功能超出所声称的功能</li><li>逻辑炸弹————一种当运行环境满足某种特定条件时执行其他特殊功能的程序。</li></ol><h3 id="木马程序"><a href="#木马程序" class="headerlink" title="木马程序"></a>木马程序</h3><ol><li>查看会话 netstat -n 是否有可以的会话</li><li>运行msconfig 服务 隐藏微软服务</li><li>安装杀毒软件</li></ol><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h3><p>对称加密 优点：效率高<br>        缺点：密钥不适合在网上传输 密钥维护麻烦</p><p>非对称加密 加密密钥和解密密钥是不同 密钥对 公钥和私钥<br>            公钥加密私钥解密<br>            私钥加密公钥解密</p><h4 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h4><p>数据加密标准DES属于常规密钥密码体制，是一种分组密码。<br>在加密前，先对整个明文进行分组。每一个组长位64位。<br>然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。<br>最后将各组密文串接起来，即得出整个的密文。<br>使用的密钥为64位（实际密钥长度为56位，有8位用于奇偶校验）。</p><h4 id="DES的保密性"><a href="#DES的保密性" class="headerlink" title="DES的保密性"></a>DES的保密性</h4><p>DES的保密性仅取决于对密钥的保密，而算法是公开的。尽管人们在破译DES方面取得了许多进展，但至今仍未能找到比穷举搜索密钥更有效的方法。<br>DES是世界上第一个公认的实用密码算法标准，它曾对密码学的发展做出了重大贡献。<br>目前较为严重的问题是DES的密钥的长度。<br>现在已经设计出来搜索DES密钥的专用芯片。</p><p>DES算法公开取决于密钥长度<br>56位密钥破解需要3.5或21分组<br>128位密钥破解需要5.4*10^18年</p><p>数字签名 防止抵赖 能够检查签名之后内容是否被更改</p><p>证书颁发机构作用<br>        为企业和用户颁发数字证书 确认这些企业和个人的身份<br>        发布证书吊销列表<br>        企业和个人新人证书颁发机构</p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><img src="/2020/02/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/SSL.png" srcset="undefined" class="" title="SSL"><p>在Internet上使用的两个安全协议<br>        imaps tcp-993<br>        pops tcp-995<br>        smitps tcp-465<br>        https tcp-443</p><h4 id="SSL提供的三个功能"><a href="#SSL提供的三个功能" class="headerlink" title="SSL提供的三个功能"></a>SSL提供的三个功能</h4><ol><li>SSL服务器鉴别 允许用户证实服务器的身份。具有SSL功能的浏览器维持一个表，上面有一些可信赖的认证中心CS（Certificate Authority）和他们的公钥。</li><li>加密的SSL会话 客户和服务器交互的所有数据都在发送方加密，在接收方解密。</li><li>SSL客户鉴别 允许服务器证实客户的身份。</li></ol><p>网络层安全–IPSec</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="undefined2020/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>2020/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>DNS服务作用：负责解析域名，将域名解析成IP<br>222.222.222.222是电信公司的服务器<br>8.8.8.8是谷歌公司的服务器</p><p>域名：<br>    根<br>    顶级域名    com    edu net cn org gov<br>    二级域名    baidu<br>    三级域名</p><p>域名节序测试<br>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>nslookup <a href="http://www.souhu.com" target="_blank" rel="noopener">www.souhu.com</a></p><img src="/2020/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/ping%E5%9F%9F%E5%90%8D.png" srcset="undefined" class="" title="ping域名"><p>域名注册：百度然后花钱买<br>域名解析过程<br>安装自己的DNS服务器</p><ol><li>解析内网自己的域名</li><li>节省到Internet的域名解析流量</li><li>域环境</li></ol><h2 id="DHCP动态主机配置"><a href="#DHCP动态主机配置" class="headerlink" title="DHCP动态主机配置"></a>DHCP动态主机配置</h2><p>静态IP地址<br>动态IP地址</p><p>DHCP客户端请求IP地址的过程<br>DHCP服务器必须静态地址<br>释放租约<br>    ipconfig /release<br>跨网段地址分配</p><h2 id="文件传输协议FTP（File-Transfer-Protocol）"><a href="#文件传输协议FTP（File-Transfer-Protocol）" class="headerlink" title="文件传输协议FTP（File Transfer Protocol）"></a>文件传输协议FTP（File Transfer Protocol）</h2><p>FTP协议<br>    主动模式 ftp客户端高速FTP服务器使用什么端口侦听<br>            FTP服务器和FTP客户端的这个端口建立连接 源端口20<br>    被动模式 服务端在指定范围额你的某个端口被动等待客户端发起连接</p><p>如果由防火墙许哟啊在防火墙打开21和20端口，使用主动模式进行数据连接</p><h2 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h2><p>telnet使用TCP的23端口</p><h2 id="远程桌面协议RDP（Remote-Desktop-Protocol）"><a href="#远程桌面协议RDP（Remote-Desktop-Protocol）" class="headerlink" title="远程桌面协议RDP（Remote Desktop Protocol）"></a>远程桌面协议RDP（Remote Desktop Protocol）</h2><p>net user administrator a1! 更改用户密码<br>net user han a1! /add 添加用户<br>将用户添加到远程桌面组 Remote Desktop User组</p><p>Server多用户操作系统 启动远程桌面可以多用户同时使用服务器<br>XP和Windows7单用户操作系统 不支持多用户同时登录</p><p>远程连接可以将本地硬盘映射到远程</p><h2 id="超文本传输协议HTTP（Hyper-Text-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Text-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Text Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Text Transfer Protocol）</h2><p>万维网提供分布式服务</p><p>URL的一般形式<br>由以冒号隔开的两大部分组成，并且在URL中的字符对大写或小写没有要求。<br>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>安装Web服务创建Web站点<br>网站的标识 不同端口 不同的IP地址 使用主机头（域名）区分<br>使用Web代理服务器访问网站</p><ol><li>节省内网访问Internet的带宽</li><li>通过Web代理绕过防火墙</li></ol><h2 id="电子邮件（SMTP，POP3，IMAP）"><a href="#电子邮件（SMTP，POP3，IMAP）" class="headerlink" title="电子邮件（SMTP，POP3，IMAP）"></a>电子邮件（SMTP，POP3，IMAP）</h2><ol><li>安装POP3和SMTP服务以及DNS服务</li><li>在DNS服务器上创建91xueit.com和51cto.com<br>创建主机记录mail 192.168.80.100<br>创建邮件交换记录 MX记录</li><li>在POP3服务上创建域名 创建邮箱</li><li>配置SMTP服务器 创建远程域名 *.com 允许发送到远程</li><li>配置outlookExpress 指明收邮件的服务器和发邮件的服务器使用POP3收邮件</li><li>搭建能够在Internet上使用的邮件服务器<ol><li>在Internet上注册了域名 MX记录</li><li>邮件服务器有公网IP地址或端口映射到邮件服务器SMTP TCP 25</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="undefined2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层的功能<br>传输层协议UDP和TCP<br>网络安全<br>TCP可靠传输的实现<br>TCP的流量控制<br>TCP的拥塞控制<br>TCP的运输连接管理</p><h2 id="OSI和DoD模型"><a href="#OSI和DoD模型" class="headerlink" title="OSI和DoD模型"></a>OSI和DoD模型</h2><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/OSI%E5%92%8CDoD%E6%A8%A1%E5%9E%8B.png" srcset="undefined" class="" title="OSI和DoD模型"><p><strong>需要记住！！！！</strong></p><p>数据包65535 -&gt; 分段46-1500<br>TCP 需要将传输的文件分段 传输建立会话 可靠传输 流量控制<br>    文件传输 邮件传输 ftp下载文件<br>UDP 一个数据包就能够完成数据通信 不分段 不需要建立会话 不需要流量控制 不可靠传输<br>    qq聊天 屏幕广播 多播 广播</p><p>查看会话 netstat -n<br>查看简历会话的进程 netstat -nb</p><h2 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h2><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png" srcset="undefined" class="" title="应用层协议"><p>常见的应用层协议使用的端口<br>http = TCP + 80<br>https = TCP + 443<br>RDP = TCP + 3389<br>ftp = TCP + 21<br>共享文件夹 = TCP + 445<br>SMTP = TCP + 25<br>POP3 = TCP + 110<br>telnet = TCP + 23<br>SQL = TCP + 1433<br>DNS = UDP + 53</p><h2 id="传输层–服务和端口"><a href="#传输层–服务和端口" class="headerlink" title="传输层–服务和端口"></a>传输层–服务和端口</h2><ol><li><p>服务和应用层协议之间关系<br> 服务使用 TCP或UDP的端口侦听客户端请求<br> 客户端使用IP地址定位服务器 使用目标端口 定位服务<br> 可以在都武器网卡上设置只开放必要的端口 实现服务器网络安全</p></li><li><p>如何在Windows上安装服务<br> DNS服务<br> Web服务<br> SMTP服务<br> POP3服务</p></li><li><p>如何查看服务侦听的端口<br> mstsc 远程连接<br> netstat -an<br> netstat -n 查看建立的会话<br> netstat -nb 查看简历会话的进程<br> telnet 192.168.80.100 3389 测试到远程计算机某个端口是否打开</p></li><li><p>如何更改服务使用默认端口<br> 迷惑入侵者使系统更加安全</p></li><li><p>如何设置Windows网络安全<br> 设置本地连接 TCP/IP筛选</p></li></ol><h2 id="传输层功能和端口范围"><a href="#传输层功能和端口范围" class="headerlink" title="传输层功能和端口范围"></a>传输层功能和端口范围</h2><p>传输层的功能 为象互通信的应用进程提供了逻辑通信</p><p>传输层的端口<br>TCP的协议号6<br>UDP的协议号17<br>IGMP的协议号1</p><h3 id="TCP的端口"><a href="#TCP的端口" class="headerlink" title="TCP的端口"></a>TCP的端口</h3><p>端口用一个16位端口号进行标志。<br>端口号只具有<strong>本地</strong>意义，即端口号只是为了标志本 计算机应用层中的各进程。在因特网中不同计算机的相同端口号使没有联系的。</p><p>端口范围0-65535，熟知端口 0-1023，登记端口 RDP 3389 ，客户端端口 49152-65535<br>netstat -n : find “ESTABLISHED”</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP的首部"><a href="#UDP的首部" class="headerlink" title="UDP的首部"></a>UDP的首部</h3><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP.png" srcset="undefined" class="" title="UDP"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" srcset="undefined" class="" title="UDP首部格式"><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP使面向连接的传输层协议。</li><li>每一条TCP连接只能由两个端点（endpoint），每一条TCP连接只能使点对点的（一对一）</li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>面向字节流</li></ul><h3 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h3><p>TCP把连接作为最基本的对象，每一条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。<br>TCP连接的端点叫做<strong>套接字</strong>（socket）</p><p>端口号+IP地址=套接字</p><h3 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93.png" srcset="undefined" class="" title="可靠传输"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E7%A1%AE%E8%AE%A4%E8%BF%9F%E5%88%B0.png" srcset="undefined" class="" title="确认丢失和确认迟到"><p>使用上述的确认和重传机制，我们就可以<strong>在不可靠的传输网络上实现可靠的通信。</strong><br>这种可靠传输协议常称为<strong>自动重传请求ARQ</strong>（Automatic Repeat reQuest)<br>ARQ表明重传的请求使<strong>自动</strong>进行的。接收方不需要请求发送方重传某个出错的分组。</p><p>使用滑动窗口技术来进行可靠的流水线传输，同时可以通过累积确认来提高效率。</p><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" srcset="undefined" class="" title="TCP报文段的首部格式"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E9%80%9A%E4%BF%A1.png" srcset="undefined" class="" title="TCP通信"><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>通过TCP的缓存和TCP的确认机制，每过一段时间就从接收方返回可接受的流量大小，来进行流量控制</p><h3 id="TCP避免拥塞"><a href="#TCP避免拥塞" class="headerlink" title="TCP避免拥塞"></a>TCP避免拥塞</h3><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" srcset="undefined" class="" title="拥塞控制"><p>慢开始并拥塞控制，如果没有拥塞就把拥塞窗口扩大，如果拥塞就减小。</p><h3 id="TCP的传输连接管理"><a href="#TCP的传输连接管理" class="headerlink" title="TCP的传输连接管理"></a>TCP的传输连接管理</h3><p>传输连接由三个阶段，即：<strong>连接建立、数据传送和连接释放。</strong></p><p>TCP连接的建立都是采用<strong>客户服务器方式</strong>。<br>主动发起连接建立的应用进程叫做<strong>客户</strong>（client）。<br>被动等待连接建立的应用进程叫做<strong>服务器</strong>（server）。</p><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B.png" srcset="undefined" class="" title="TCP连接建立"><p>SYN=1，代表同步数据包</p><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE.png" srcset="undefined" class="" title="TCP连接释放"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE.png" srcset="undefined" class="" title="连接释放"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE2.png" srcset="undefined" class="" title="连接释放2"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE3.png" srcset="undefined" class="" title="连接释放3"><img src="/2020/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81.png" srcset="undefined" class="" title="断开连接状态">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="undefined2020/02/22/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>2020/02/22/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><img src="/2020/02/22/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" srcset="undefined" class="" title="动态规划"><p>遇到动态规划问题，首先思考将大问题拆解成一个个小问题，<br>写出解题方程，然后写出状态方程<br>先用递归的思路解决问题，<br>然后用记忆法进行优化，然后使用动态规划。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0…n-1，其中每一件物品的重量为w(i),<br>价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大</p><p> 暴力解法：每一件物品都可以放进背包，也可以不放进背包。<br> 时间复杂度    O((2^n)*n)</p><p> F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大<br> F(i,c) = F(i-1,c)<br>        = v(i) + F(i-1,c - w(i))<br> F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i))</p><img src="/2020/02/22/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.png" srcset="undefined" class="" title="01背包问题"><pre><code class="java">/** * @Description TODO 0-1背包问题 * 有一个背包，它的容量为C（Capacity），现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i), * 价值为v(i).问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大 * * 暴力解法：每一件物品都可以放进背包，也可以不放进背包。 * 时间复杂度    O((2^n)*n) * * F(n,C)考虑将n个物品放进容量为C的背包，使得价值最大 * F(i,c) = F(i-1,c) *        = v(i) + F(i-1,c - w(i)) * F(i,c) = max(F(i-1,c), v(i) + F(i-1,c-w(i)) * @Author Matthew * @Date 2020/2/20 20:26 * @Version 1.0 */public class Knapsack01 {    // 由于背包有2个因素限制，所以记忆空间需要二维数组    int[][] memo;    public int knapsack01(int[] w, int[] v, int C) {        int n = w.length;        memo = new int[n][C + 1];        Tool.Array2Fill(memo, -1);        return bestValue(w, v, n - 1, C);    }    /**    * @Description ：用[0...index]的物品，填充溶剂为c的背包的最大价值    * @Date   2020/2/20 20:43    * @Param  w[]:每一件物品的重量  v[]：每一件物品的价值     *          index：第index件物品 c：容量    * @Return 当前物品能存放物品的最大价值    */    private int bestValue(int[] w, int[] v, int index, int c) {        if (index &lt; 0 || c &lt;= 0) {            return 0;        }        if (memo[index][c] == -1) {            int res = bestValue(w, v, index - 1, c);            if (c &gt;= w[index]) {                res = Math.max(res, v[index] + bestValue(w, v, index - 1, c - w[index]));            }            memo[index][c] = res;        }        return memo[index][c];    }    public int knapsack01_2(int[] w, int[] v, int C) {        assert (w.length == v.length);        int n = w.length;        if (n == 0) {            return 0;        }//        将记忆空间按照每一行增加一个物品，每一列增加一个容量        // 优化空间复杂度，只用2行        int[][] memo = new int[2][C + 1];        Tool.Array2Fill(memo, -1);//        先计算第一行的最大价值        for (int i = 0; i &lt;= C; i++) {            memo[0][i] = i &gt;= w[0] ? v[0] : 0;        }//        之后的每一行的每一列按照以下逻辑计算        for (int i = 1; i &lt; n; i++) {            for (int j = 0; j &lt;= C; j++) {//                每一列的下一行大于等于上一行                memo[i % 2][j] = memo[(i - 1) % 2][j];//                如果容量大于这一行的物品的重量，就进行以下计算                if (j &gt;= w[i]) {                    //  Math.max(这一列上一行的价值（没有这个物品的价值），这个物品的价值+剩余容量的价值）                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i - 1) % 2][j - w[i]]);                }            }        }        return memo[(n - 1) % 2][C];    }    public int knapsack01_3(int[] w, int[] v, int C) {        assert (w.length == v.length);        int n = w.length;        if (n == 0) {            return 0;        }        // 再次优化只用1行        int[] memo = new int[C + 1];        for (int i = 0; i &lt;= C; i++) {            memo[i] = i &gt;= w[0] ? v[0] : 0;        }        for (int i = 1; i &lt; n; i++) {            for (int j = C; j &gt;= C - w[i]; j--) {                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);            }        }        return memo[C];    }}public class Tool {    public static void Array2Fill(int[][] n, int val) {        for (int i = 0; i &lt; n.length; i++) {            for (int j = 0; j &lt; n[0].length; j++) {                n[i][j] = val;            }        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this和对象</title>
    <link href="undefined2020/02/15/%E5%89%8D%E7%AB%AF/JS/this%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>2020/02/15/%E5%89%8D%E7%AB%AF/JS/this%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li>解析器在调用函数每次都会向函数内部传递进一共隐含的参数，<ul><li>这个隐含的额参数就是this，this指向的是一个对象，</li><li>这个对象我们成为函数执行的上下文对象，</li><li>根据函数的<strong>调用方式</strong>的不同，this会指向不同的对象。<ol><li>以函数的形式调用时，this永远都是window</li><li>以方法的形式调用时，this就是调用方法的那个对象</li></ol></li></ul></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建一共构造函数，专门用来创建Person对象的<br>    构造函数就是一共普通函数，创建方式和普通函数没有区别，不同的时构造函数习惯上首字母大写<br>构造函数和普通函数的区别就是调用方式的不同<br>    普通函数时直接调用，而构造函数需要使用new关键字来调用</p><pre><code class="js">function Person(name,age,gender) {    this.name = name    this.age= age    this.gender = gender    this.sayName = function(){        console.dir(obj)    }}var per = new Person() // [object Object]//  var per = Person()    undefinedconsole.log(per)</code></pre><h3 id="构造函数的执行流程"><a href="#构造函数的执行流程" class="headerlink" title="构造函数的执行流程"></a>构造函数的执行流程</h3><ol><li>立即创建一共新的对象</li><li>将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象</li><li>逐行执行函数中的代码</li><li>将新建的对象作为返回值返回</li></ol><p>使用同一个构造函数创建的对象，我们成为一类对象，也将一共构造函数称为一共类。<br>    我们将通过一个构造函数创建的对象，称为时该类的实例</p><p>this的情况：<br>    1. 当以函数的形式调用时，this是window<br>    2. 当以方法的形式调用时，谁调用方法this就是谁<br>    3. 当以构造函数的形式调用时，this就是新创建的那个对象</p><p>使用instanceof可以检查一共对象是否是一共类的实例<br>  语法：<br>    对象 instanceof 构造函数<br>如果时，则返回true，否则返回false<br>所有对象都是Object的后代，所以任何对象和Object作instanceof检查时都会返回true</p><p>创建一共Person构造函数<br>在Person构造函数中，为每一个对象都添加了一共sayName方法，<br>    目前我们的方法是在构造函数内部创建的，<br>        也就是构造函数每执行一次就会创建一共新的sayName方法<br>    也是所有实例的sayName都是唯一的<br>    这样就导致了构造函数执行一次就会创建一共新的方法，<br>        执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的<br>        这是完全没有必要的，完全可以使所有的对象共享同一个方法</p><h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><p>我们所创建的每一个函数，解析器都会向函数中添加一共属性prototype<br>    这个属性对应着一个对象，这个对象就是我们所谓的原型对象<br>如果函数作为普通函数调用prototype没有任何作用<br>当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过<strong>proto</strong>来访问该属性</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局作用域</title>
    <link href="undefined2020/02/14/%E5%89%8D%E7%AB%AF/JS/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>2020/02/14/%E5%89%8D%E7%AB%AF/JS/%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域指一个变量的作用的范围<br>在js中一共有两种作用域</p><ol><li>全局作用域<ul><li>直接编写在script标签中的JS代码，都在全局作用域中</li><li>全局作用域在页面打开时创建，在页面关闭时销毁</li><li>在全局作用域中有一个全局对象window，它代表的时一共浏览器的窗口，它由浏览器创建我们可以直接使用</li><li>在全局作用域中：创建的变量都会作为window对象的属性保存,创建的函数都会作为window对象的方法保存</li><li>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</li></ul></li><li>函数作用域<ul><li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁</li><li>每调用一次函数就会创建一共新的函数作用域，他们之间时互相独立的</li><li>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量</li><li>当在函数作用域操作一共变量时，它会先在自身作用域中寻找，如果有就直接使用<br>  如果没有则向上一级作用域中寻找，知道找到全局作用域，<br>  如果全局作用域中仍然没有找到，则会报错ReferenceError</li></ul></li></ol><h2 id="变量的声明提前"><a href="#变量的声明提前" class="headerlink" title="变量的声明提前"></a>变量的声明提前</h2><p>变量的声明提前<br>使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值)<br>但是如果声明变量时不使用var关键字，则变量不会被声明提前</p><p>函数的声明提前<br>使用函数声明形式创建的函数function函数（）{}，它会在所有的代码执行之前就被创建</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>script位置问题</title>
    <link href="undefined2020/02/11/%E5%89%8D%E7%AB%AF/JS/script%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <url>2020/02/11/%E5%89%8D%E7%AB%AF/JS/script%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>页面自上而下加载如果你的script标签放在开头，将会无法加载body中的元素，但是你放在结尾就不会有问题，<br>但是如果你非要放在开头可以按照下方的样子做</p><pre><code class="js">window.onload = function () {    ...}</code></pre><p>或者从外部引用js文件</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="undefined2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>网络层提供的服务<br>网络层协议<br>网络层如何转发数据包<br>网络设备<br>IP协议<br>    RIP<br>    OSPF<br>ARP协议<br>网际控制报文 ICMP<br>Internet组播管理协议 IGMP<br>IP数据包格式</p><a id="more"></a><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>负责在不同网络之间转发数据包<br>基于数据包的IP地址转发<br>不负责丢失重传，不负责顺序</p><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%81.png" srcset="undefined" class="" title="数据包在互联网中的传送"><h2 id="网络设备和OSI模型"><a href="#网络设备和OSI模型" class="headerlink" title="网络设备和OSI模型"></a>网络设备和OSI模型</h2><p>计算机通信的过程 本网段通信跨网段通信的过程</p><p>发送端</p><ol><li>应用此程序准备要传输的文件</li><li>传输层 将文件分段 并编号</li><li>网络层 添加目标IP地址源IP地址</li><li>数据链路层 两种情况 使用自己的子网掩码 判断自己在哪个网段<pre><code>               使用自己的子网掩码 判断目标地址在哪个网段               如果是同一个网段 arp协议广播解析目标IP地址的MAC地址               如果不是一个网段</code></pre><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" srcset="undefined" class="" title="发送数据的过程"></li></ol><h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="TCP-IP协议之间层次"><a href="#TCP-IP协议之间层次" class="headerlink" title="TCP/IP协议之间层次"></a>TCP/IP协议之间层次</h3><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/TCPIP%E5%8D%8F%E8%AE%AE.png" srcset="undefined" class="" title="TCPIP协议"><p>ARP 将IP地址通过广播 目标MAC地址是FF-FF-FF-FF-FF-FF解析目标IP地址的MAC地址</p><p>ARP欺骗是数据链路层故障，通过发送错误的MAC地址来控制其他计算机的通信。<br>网络执法官<br>arp -s 192.168.80.1 00-0C-29-53-48-C3<br>arp -a<br>本地连接 恢复</p><h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><h4 id="ping命令诊断网络故障"><a href="#ping命令诊断网络故障" class="headerlink" title="ping命令诊断网络故障"></a>ping命令诊断网络故障</h4><ol><li>PING（Packet Internet Grope），因特网包探索器，用于测试网络连接量的程序。Ping发送一个ICMP回声请求消息给目的地并报告是否收到所希望的ICMP回声应答。</li><li>ping指的是端对端连通，通常用来作为可用性的检查，但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。</li><li>如果你打开IE浏览器访问网站失败，你可以通过ping命令测试到Internet的网络连通，可以为你排除网络故障提供线索，下面展示ping命令返回的信息以及分析其原因。</li></ol><h4 id="使用ICMP协议的命令"><a href="#使用ICMP协议的命令" class="headerlink" title="使用ICMP协议的命令"></a>使用ICMP协议的命令</h4><p>ping time 查看延迟<br>    Linux 64<br>    Windows 128<br>    Unix 255</p><p>当TTL耗尽时这个数据包将会被丢失，防止一个包在路由器中循环传递<br>ping 10.9.0.1 -t<br>ping -l 200 10.9.0.1<br>ping 10.9.0.1 -l 200<br>ping 8.8.8.8 -i 2 更改数据包TTL事件 能够跟踪数据包途径的路由器<br>pathping 根据数据包路径 计算丢包情况<br>Windows上跟踪数据包路径的命令<br>tracert 10.9.0.1<br>在路由器上跟踪数据包路径的命令<br>traceroute 10.9.0.1</p><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>点到点<br>广播<br>组播 = 多播</p><h3 id="IP数据包结构"><a href="#IP数据包结构" class="headerlink" title="IP数据包结构"></a>IP数据包结构</h3><p>IP数据包由首部+数据组成</p><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E9%A6%96%E9%83%A8.png" srcset="undefined" class="" title="首部"><p>版本 用来表示TCP/IP协议的版本 v4 v6<br>区分服务 Windows 2008上 gpedit.msc<br>标识 通过标识确定哪些不同的片是一个包<br>标志 是否是完整的数据包</p><p>网络层 数据包 65535字节<br>数据链路层 如果不分片 数据包数据最大不超过1500字节 最大传输单元MTU</p><h4 id="首部协议号"><a href="#首部协议号" class="headerlink" title="首部协议号"></a>首部协议号</h4><p>指明数据包哪个部分交给哪个协议处理</p><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E9%A6%96%E9%83%A8.png" srcset="undefined" class="" title="IP数据包首部"><p>协议号  1<br>IGMP协议    2<br>TCP 6<br>UDP 17<br>IPv6    41<br>OSPF    89</p><h4 id="首部校验和"><a href="#首部校验和" class="headerlink" title="首部校验和"></a>首部校验和</h4><img src="/2020/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%A0%A1%E9%AA%8C%E8%BF%87%E7%A8%8B.png" srcset="undefined" class="" title="校验过程"><h2 id="网络层的一些应用"><a href="#网络层的一些应用" class="headerlink" title="网络层的一些应用"></a>网络层的一些应用</h2><ol><li><p>使用抓包工具排除网络故障</p></li><li><p>网络畅通的条件 数据包有去有回（计算机必须配网关，计算机到服务器沿途的路由器必须畅通）</p></li><li><p>静态路由，<br> 静态路由需要管理员高速路由器所有没有直连的网络下一跳给谁<br> 静态路由的缺点 适合于小规模网络 不能够自动调整路由</p><p>动态路由，<br> RIP 周期性广播路由表 条数 30秒更新一下路由信息 最大跳数：15跳</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="undefined2020/02/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/"/>
    <url>2020/02/02/%E5%89%8D%E7%AB%AF/JS/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h2><blockquote><p>函数就是一个方法或者一个功能体，函数就是把实现某个功能的代码放到一起进行分装，以后想要操作实现这个功能，只需要把函数执行极客=&gt;”封装”减少页面中的冗余代码，提高代码重复使用率（高内聚低耦合）</p></blockquote><p>洗衣机就是一个函数，生成洗衣机就是封装一个函数（把实现某些功能的代码封装进来），生产的时候，不知道用户洗衣服的时候放什么水、衣服、洗衣液，我们需要提供出入口（提供的入口在函数中叫形参，执行的时候放的具体东西函数中叫做实参）洗完衣服选哟能拿出来，洗衣机提供一个出口（在函数中叫做返回值：把函数处理后的结果能够返回给外面用）</p><ul><li>创建函数<ul><li>形参</li><li>返回值</li></ul></li><li>执行函数<ul><li>实参</li></ul></li><li>arguments</li><li>函数底层运行机制</li><li>…</li></ul><h2 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h2><pre><code class="js">//=&gt; ES5老方式function[函数名]([形参变量],...){    // 函数体：基于JS完成需要实现的功能    return [处理后的结果]}[函数名]([实参1],...);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>元素对象</title>
    <link href="undefined2020/02/02/%E5%89%8D%E7%AB%AF/JS/%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1/"/>
    <url>2020/02/02/%E5%89%8D%E7%AB%AF/JS/%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h2><ol><li>通过元素方法获取的元素使对象数据类型的值<br> <code>let box = document.getElementById(&#39;box&#39;)</code><br> <code>console.dir(box)</code>基于.dir可以看到一个对象的详细信息</li><li>对象中的属性<br> id：操作元素的ID值<br> className：操作元素的CLASS样式类的值<br> innerHTML：操作的元素的内容（可以识别标签）<br> innerText：和innerHTML的区别使不能识别标签<br> tagName：获取元素的标签名（一般大写）<br> …<br> style：操作元素的行内样式 属性值使一个新的对象（CSSStyleDeclaration）</li></ol><p>因此下面这种情况不可行</p><pre><code class="js">let box = document.getElementId(&#39;box&#39;)let aa = box.style.backgroundColoraa = &#39;red&#39;</code></pre><p>因为backgroundColor是属性名，所以aa获得的是backgroundColor的值<br>而box和style都是对象传递的是引用更改的是堆内存中的值（只要堆内存中值被修改，浏览器会基于DOM映射机制把页面中的元素进行重新渲染）</p><img src="/2020/02/02/%E5%89%8D%E7%AB%AF/JS/%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1/%E5%85%83%E7%B4%A0%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8.png" srcset="undefined" class="" title="元素对象引用">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS样例</title>
    <link href="undefined2020/01/06/%E5%89%8D%E7%AB%AF/CSS/CSS%E6%A0%B7%E4%BE%8B/"/>
    <url>2020/01/06/%E5%89%8D%E7%AB%AF/CSS/CSS%E6%A0%B7%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="鼠标滑过显示详情"><a href="#鼠标滑过显示详情" class="headerlink" title="鼠标滑过显示详情"></a>鼠标滑过显示详情</h2><p><a href="https://javamatthew.github.io/2020/01/06/%E5%89%8D%E7%AB%AF/CSS/CSS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85.html" target="_blank" rel="noopener">鼠标滑过显示详情</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
      <tag>样例</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS样例</title>
    <link href="undefined2020/01/06/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/"/>
    <url>2020/01/06/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="鼠标滑过显示详情"><a href="#鼠标滑过显示详情" class="headerlink" title="鼠标滑过显示详情"></a>鼠标滑过显示详情</h2><p><a href="https://javamatthew.github.io/2020/01/06/%E5%89%8D%E7%AB%AF/JS/JS%E6%A0%B7%E4%BE%8B/%E9%BC%A0%E6%A0%87%E6%BB%91%E8%BF%87%E6%98%BE%E7%A4%BA%E8%AF%A6%E6%83%85/" target="_blank" rel="noopener">鼠标滑过显示详情</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>样例</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的逻辑语句</title>
    <link href="undefined2020/01/06/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/"/>
    <url>2020/01/06/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="JS中的操作语句：判断、循环"><a href="#JS中的操作语句：判断、循环" class="headerlink" title="JS中的操作语句：判断、循环"></a>JS中的操作语句：判断、循环</h2><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><blockquote><p>条件成立做什么? 不成立做什么?</p></blockquote><ul><li>if/else if/ else</li><li>三元运算符</li><li>switch case</li></ul><ol><li><p>if/else</p><pre><code class="js"> if(条件){     条件成立执行 }else if(条件2){     条件2成立执行 } ... else{     以上条件都不成立 }</code></pre></li><li><p>== VS ===</p><p> == ：相等（如果左右两百年数据值类型不同，是默认向转换为相同的类型，然后比较）<br> <code>&#39;5&#39; == 5  =&gt;TRUE</code><br> === : 绝对相等（如果类型不一样，肯定不相等）<br> <code>&#39;5&#39; == 5  =&gt;FALSE</code><br> 项目中为了保证业务的严谨，推荐使用===</p></li></ol><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><blockquote><p>重复做某些事情就是循环</p></blockquote><ul><li>for循环</li><li>for in循环</li><li>for of循环（ES6新增）</li><li>while循环</li><li>do while循环</li></ul><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>for(var 变量(key) in 对象)<br>对象中有多少组键值对，循环就执行几次（除非break结束）</p><pre><code class="js">var obj = {    name: &#39;春亮&#39;,    age: 52,    friends: &#39;王鹏，志刚&#39;,    1: 223    2: 33    4: 231}for ( var key in obj){    // 每一次循环key变量存储的值: 当前对象的属性名    // 获取属性值：obj[属性名] =&gt; obj[key] obj.key/obj[&#39;key&#39;]    console.log(&#39;&#39; + key + &#39;&#39; + obj[key])}</code></pre><p>for in 在遍历的时候，优先循环数字属性名（从小到大）</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆栈练习题</title>
    <link href="undefined2020/01/06/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>2020/01/06/%E5%89%8D%E7%AB%AF/JS/%E5%A0%86%E6%A0%88%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里面试题"><a href="#阿里面试题" class="headerlink" title="阿里面试题"></a>阿里面试题</h2><p>&lt;% asset_img 阿里面试题.png 阿里面试题%&gt;<br>根据js引擎语法解析，会先去从左到右寻找有没有未声明的变量，如果有就把该变量提升至作用域顶部并声明该变量。那么恭喜js引擎他找到a.x这个属性没有声明，那么他会在{n: 1}这个内存区声明一个x属性等待赋值！<br>所以最终的执行顺序是<br>先声明a.x，<br>然后a的值变为{n:2}，<br>最后a.x = a,注意这里的a.x已经不是现在的a.x，而是b.x<br>因此，现在的a中只有{n:2}而没有x属性，所以a.x是undefined</p><h2 id="JS中的数据类型检测"><a href="#JS中的数据类型检测" class="headerlink" title="JS中的数据类型检测"></a>JS中的数据类型检测</h2><ul><li><p>typeof[val] : 用来检测数据类型的运算符<br>  基于typeof检测出来的结果</p><ol><li><p>首先是一个字符串</p></li><li><p>字符串中包含对应的类型<br>&lt;% asset_img typeof1.png typeof1%&gt;<br>&lt;% asset_img typeof2.png typeof2%&gt;</p><p>局限性</p></li><li><p>typeof null =&gt; “object” 但是null并不是对象</p></li><li><p>基于typeof无法细分出当前值是普通对象还是数组对象等，应为只要是对象数据类型，返回的结果都是”object”</p></li></ol></li><li><p>instanceof : 用来检测当前实例是否属于某个类</p></li><li><p>constructor : 基于构造函数检测数据类型（也是基于类的方式）</p></li><li><p>Object.prototype.toString.call() : 检测数据类型最好的办法</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忘记密码</title>
    <link href="undefined2020/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/"/>
    <url>2020/01/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="如何强制更改Docker容器中的Mysql密码（忘记密码）"><a href="#如何强制更改Docker容器中的Mysql密码（忘记密码）" class="headerlink" title="如何强制更改Docker容器中的Mysql密码（忘记密码）"></a>如何强制更改Docker容器中的Mysql密码（忘记密码）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用docker容器时，通过镜像安装了Mysql5.7版本，但忘记了root密码，需要重新设置root密码</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ol><li><p>增加“忘记密码启动”模式</p></li><li><p>重新设置root密码</p></li><li><p>删掉“忘记密码启动”模式</p></li><li><p>重启容器镜像即可</p></li></ol><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ol><li><p>通过docker exec命令进入容器内<br> <code>docker exec -it mysql5.7.28 /bin/sh</code><br> 注：mysql5.7.8是我安装mysql数据库的容器名</p></li><li><p>编辑mysql配置文件，增加“忘记密码启动”模式：skip-grant-tables<br> <code>vi /etc/mysql/conf.d/docker.cnf</code><br> 注：编辑的配置文件不是/etc/mysql/my.cnf，也不是/etc/mysql/mysql.cnf或/etc/mysql/conf.d/mysql.cnf<br> 最终配置文件docker.cnf内容如下：</p><pre><code class="shell"> [mysqld] skip-host-cache skip-name-resolve skip-grant-tables</code></pre></li><li><p>退出容器，重启容器实例</p><pre><code class="shell"> vi /etc/mysql/conf.d/docker.cnf exit docker restart mysql5.7.8</code></pre></li><li><p>通过步骤1再次进入容器，输入myql命令，免密码直接登录mysql</p><pre><code class="shell"> docker exec -it mysql5.7.8 /bin/sh mysql</code></pre></li><li><p>设置root用户新密码：root。刷新权限，退出mysql</p><pre><code class="mysql"> #切换实例，user表位于mysql实例下 mysql&gt; use mysql; #更改root密码 5.7以后版本更新密码用这个 update user set authentication_string=password(&quot;新密码&quot;) where user=&quot;root&quot;; 5。7以前更新密码用这个 mysql&gt; UPDATE user SET Password = password ( &#39;a123456&#39; ) WHERE User = &#39;root&#39;; # 刷新权限 mysql&gt; flush privileges; # 退出 mysql&gt; quit</code></pre></li><li><p>重新编辑mysql配置文件docker.cnf，删掉“忘记密码启动”模式<br> <code>vi /etc/mysql/conf.d/docker.cnf</code></p></li><li><p>退出容器，重启容器即可<br> <code>docker restart mysql5.7.8</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="undefined2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>封装成帧<br>透明封装<br>无差错接收<br>点到点线路的数据链路层 PPP<br>国博信道的数据链路层能 CSMA/CD<br>以太网 集线器 网桥 交换机<br>100M 1000M 10000M以太网</p><a id="more"></a><h2 id="数据链路层的信道类型"><a href="#数据链路层的信道类型" class="headerlink" title="数据链路层的信道类型"></a>数据链路层的信道类型</h2><p>点对点信道。这种信道使用一对一的点对点通信方式。<br>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</p><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ol><li><p><code>链路(link)</code>是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。<strong>一条链路只是一条通路的一个组成部分.</strong></p></li><li><p><code>数据链路(data link)</code>除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<br> <strong>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</strong><br> <strong>一般的适配器都包括了数据链路层和物理层这两层的功能。</strong></p></li><li><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B8%A7.png" srcset="undefined" class="" title="帧"><p> 常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。<br> 早期的数据通信协议曾叫作通信规程(procedure)。因此在数据链路层，规程和协议是同义语。<br> 帧 帧头 帧尾 物理层地址 校验值</p></li></ol><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><ul><li>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。<img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" srcset="undefined" class="" title="封装成帧"></li></ul><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png" srcset="undefined" class="" title="透明传输"><h3 id="字节填充透明传输"><a href="#字节填充透明传输" class="headerlink" title="字节填充透明传输"></a>字节填充透明传输</h3><p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。<br><code>字节填充(byte stuffing)</code>或<code>字符填充(character stuffing)</code>——接收端的数据链路层在将数据送往网络层之前删除插入的<code>转义字符</code>。<br>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png" srcset="undefined" class="" title="字节填充透明传输"><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><ul><li>在传输过程中可能会产生<code>比特差错</code>：1 可能会变成 0 而 0 也可能变成 1。</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为<code>误码率</code> BER (Bit Error Rate)。</li><li>误码率与信噪比有很大的关系。</li><li>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</li></ul><h3 id="循环冗余检验的原理"><a href="#循环冗余检验的原理" class="headerlink" title="循环冗余检验的原理"></a>循环冗余检验的原理</h3><p>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。<br>在发送端，先把数据划分为组。假定每组 k 个比特。<br>假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。</p><h3 id="冗余码的计算"><a href="#冗余码的计算" class="headerlink" title="冗余码的计算"></a>冗余码的计算</h3><p>用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。<br>得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。</p><h3 id="冗余码的计算举例"><a href="#冗余码的计算举例" class="headerlink" title="冗余码的计算举例"></a>冗余码的计算举例</h3><p>现在 k = 6, M = 101001。<br>设 n = 3, 除数 P = 1101，<br>被除数是 2nM = 101001000。<br>模 2 运算的结果是：商 Q = 110101，<br>           余数 R = 001。<br>把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R<br>   即：101001001，共 (k + n) 位。</p><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8CCRC.png" srcset="undefined" class="" title="循环冗余检验CRC"><h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><ul><li>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</li><li>循环冗余检验 CRC 和帧检验序列 FCS并不等同。<ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。</li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。  </li></ul></li></ul><h3 id="接收端对收到的每一帧进行-CRC-检验"><a href="#接收端对收到的每一帧进行-CRC-检验" class="headerlink" title="接收端对收到的每一帧进行 CRC 检验"></a>接收端对收到的每一帧进行 CRC 检验</h3><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。<br>(2) 若余数 R  0，则判定这个帧有差错，就丢弃。<br>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。<br>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。</p><h3 id="应当注意"><a href="#应当注意" class="headerlink" title="应当注意"></a>应当注意</h3><p>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。<br>“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。<br>也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。<br>要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。</p><h2 id="点到点通信数据链路层协议PPP"><a href="#点到点通信数据链路层协议PPP" class="headerlink" title="点到点通信数据链路层协议PPP"></a>点到点通信数据链路层协议PPP</h2><h3 id="PPP协议使用场合"><a href="#PPP协议使用场合" class="headerlink" title="PPP协议使用场合"></a>PPP协议使用场合</h3><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/ppp%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E5%90%88.png" srcset="undefined" class="" title="ppp协议使用场合"><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>现在在全世界使用得最多得数据链路层协议是点对点协议PPP（Point-to-Point Protocol）<br>用户使用拨号电话线接入因特网时，一般都是使用PPP协议</p><h3 id="PPP协议的组成"><a href="#PPP协议的组成" class="headerlink" title="PPP协议的组成"></a>PPP协议的组成</h3><ul><li>PPP协议有三个组成部分<ul><li>数据链路层协议可以用于异步串行或同步串行介质</li><li>它使用LCP（链路控制协议）建立并维护数据链路连接</li><li>网络控制协议（NCP）允许在点到点连接上使用多种网络层协议，如图所示<img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%84%E6%88%90.png" srcset="undefined" class="" title="ppp协议的组成"></li></ul></li></ul><h3 id="PPP协议帧格式"><a href="#PPP协议帧格式" class="headerlink" title="PPP协议帧格式"></a>PPP协议帧格式</h3><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/PPP%E5%8D%8F%E8%AE%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" srcset="undefined" class="" title="PPP协议帧格式"><p>标志字段F = 0x7E（符号“0x”表示后面的额字符时用十六进制表示。十六进制的7E的二进制表示时0111110）<br>地址字段A只置为0xFF。地址字段实际上并不起作用。<br>控制字段C通常置为0x03。<br>PPP时面向字节的，所有的PPP帧的长度都是整数字节。</p><h3 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h3><p>问题：信息字段中出现了标志字段的值，可能会被误认为时“标志”，怎么办？</p><ol><li>将信息字段中出现的每个0x7E字节转变成为2字节序列（0x7D，0x5E）</li><li>若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列（0x7D，0x5D）</li><li>若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。</li></ol><h3 id="零比特填充方法"><a href="#零比特填充方法" class="headerlink" title="零比特填充方法"></a>零比特填充方法</h3><p>PPP协议用在SONET/SDH链路时，是使用同步传输（一连串的比特连续传送）。这时PPP协议采用<strong>零比特填充方法</strong>来实现透明传送。<br>在发送端，只要发现有5个连续1，则立即填入一个0.接收端对帧中的比特流进行扫描。每当发现5个连续1时，就把这个连续1后的一个0删除。</p><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" srcset="undefined" class="" title="零比特填充法"><h3 id="不适用序号和确认机制"><a href="#不适用序号和确认机制" class="headerlink" title="不适用序号和确认机制"></a>不适用序号和确认机制</h3><p>PPP协议之所以不适用序号和确认机制时出于以下的考虑：</p><ul><li>在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。</li><li>在因特网环境下，PPP的信息字段放入的数据时IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列FCS字段可保证无差错接受。</li></ul><h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><p>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。<br>PC机向路由器发送一系列的LCP分组（封装成多个PPP帧）。<br>这些分组及其响应选择一些PPP参数，和进行网络层配置NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。<br>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的使物理层的连接。</p><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="共享通信媒体"><a href="#共享通信媒体" class="headerlink" title="共享通信媒体"></a>共享通信媒体</h3><p>静态划分信道（太麻烦，现在很少使用）</p><ol><li>频分复用</li><li>时分复用</li><li>波分复用</li><li>码分复用</li></ol><p>动态媒体接入控制（多点接入）</p><ul><li><strong>随机接入（主要被以太网采用）</strong></li><li>受控接入，如多点线路探寻，或轮询（目前已不被采用）</li></ul><h3 id="认是以太网"><a href="#认是以太网" class="headerlink" title="认是以太网"></a>认是以太网</h3><p>最初的以太网使将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单有可靠，因为总线上没有有源器件</p><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A5%E5%A4%AA%E7%BD%91.png" srcset="undefined" class="" title="以太网"><p>总线上的每一个工作的计算机都能检测到B发送的数据信号。<br>由于只有jisuanjiD的地质与首部写入的地址一致，因此只有D才接受这个数据帧。<br>其他所有的计算机（A，C和E）都检测到不是发送给他们的数据帧，因此就丢弃这个数据帧而不能够收下来。<br>具有广播特性的总线上实现了一对一的通信。</p><h4 id="载波监听多点接入-碰撞检测-以太网使用CSMA-CD协议"><a href="#载波监听多点接入-碰撞检测-以太网使用CSMA-CD协议" class="headerlink" title="载波监听多点接入/碰撞检测 以太网使用CSMA/CD协议"></a>载波监听多点接入/碰撞检测 以太网使用CSMA/CD协议</h4><p>CSMA/CD表示 Carrier sense Multiple Access with Collision Detection。</p><p>“<strong>多点接入</strong>”表示许多计算机以多点接入的方式连接在一根总线上。</p><p>“<strong>载波监听</strong>”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发送碰撞。<br>它是用电子技术检测总线上有没有其他计算机发送的数据信号。</p><h2 id="以太局域网（以太网）"><a href="#以太局域网（以太网）" class="headerlink" title="以太局域网（以太网）"></a>以太局域网（以太网）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。<br>  IEEE的802.3标准。<br>  DIX Ethernet V2 标准与IEEE的802.3标准只有很小的差别，因此可以将802.3局域网简称为“以太网”<br>  严格来说，“以太网”应当是指符合DIX Ethernet V2 标准的局域网</p></blockquote><p>为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层：<br>    1. 逻辑链路层控制LLC（Logical Link Control）子层<br>    2. 媒体接入控制<code>MAC</code>（Medium Access Control）子层</p><h4 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h4><p>以太网提供的服务使不可靠的交付，即尽最大努力的交付。<br>当接收站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。<br>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个信道额数据帧来发送。</p><h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><ol><li>星型拓扑</li><li>集线器的一些特点：集线器时使用电子器件来模拟实际电缆线的工作，因此整个系统仍然享一个传统的以太网那样运行。 <img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9.png" srcset="undefined" class="" title="集线器的特点"> 集线器很像一个多借口的转发器，工作在物理层。</li><li>10Base-T</li></ol><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><h3 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h3><h4 id="MAC层的硬件地址（MAC地址）"><a href="#MAC层的硬件地址（MAC地址）" class="headerlink" title="MAC层的硬件地址（MAC地址）"></a>MAC层的硬件地址（MAC地址）</h4><p>在局域网种，硬件地址又称为物理地址，或MAC地址</p><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%9C%B0%E5%9D%80.png" srcset="undefined" class="" title="MAC地址"><h4 id="MAC帧格式"><a href="#MAC帧格式" class="headerlink" title="MAC帧格式"></a>MAC帧格式</h4><img src="/2019/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" srcset="undefined" class="" title="MAC帧格式"><h4 id="无效的MAC帧"><a href="#无效的MAC帧" class="headerlink" title="无效的MAC帧"></a>无效的MAC帧</h4><p>帧的长度不是整数个字节；<br>用收到的帧检验序列FCS查出有差错；<br>数据字段的长度不在46<del>1500字节之间。<br>有效的MAC帧长度为64</del>1518字节之间。<br>对于检查除的无效MAC帧就简单地丢弃，以太网不负责重传丢弃的帧。</p><h4 id="帧间最小间隔"><a href="#帧间最小间隔" class="headerlink" title="帧间最小间隔"></a>帧间最小间隔</h4><p>帧间最小间隔为9.6μs，相当于96bit的发送时间。一个站在检测到总线开始空闲后，还要等待9.6μs才能再次发送数据。<br>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h3 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h3><h4 id="物理扩展"><a href="#物理扩展" class="headerlink" title="物理扩展"></a>物理扩展</h4><p>扩展距离 100m -&gt; 光纤</p><p>集线器级联 使网络中计算机数量增加 组建了一个大的冲突域</p><ul><li>用集线器扩展局域网优点<ul><li>使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了局域网覆盖的递例范围</li></ul></li><li>用集线器扩展局域网的缺点<ul><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将他们互连起来</li></ul></li></ul><h3 id="优化以太网"><a href="#优化以太网" class="headerlink" title="优化以太网"></a>优化以太网</h3><h4 id="数据链路层的扩展"><a href="#数据链路层的扩展" class="headerlink" title="数据链路层的扩展"></a>数据链路层的扩展</h4><p>在数据链路层扩展局域网使使用<strong>网桥</strong><br>交换机的前身就是网桥。<br>交换机特点：端口带宽独享、安全、基于MAC地址转发、通过学习构建MAC地址表</p><h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><p>速率达到或超过100Mb/s的以太网成为高速以太网<br>100BASE-T以太网又称为快速以太网<br>吉比特以太网允许在1Gb/s下全双工和半双工两种方式工作</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓冲区的数据存取</title>
    <link href="undefined2019/12/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/NIO/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96/"/>
    <url>2019/12/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/NIO/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h2 id="缓冲区（buffer）的数据存取"><a href="#缓冲区（buffer）的数据存取" class="headerlink" title="缓冲区（buffer）的数据存取"></a>缓冲区（buffer）的数据存取</h2><ul><li>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li><li>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。</li></ul><p>缓冲区（Buffer）：在Java NIO中负责数据的 存取。缓冲区就是数组，用于存储不同数据类型的数据</p><p>根据数据类型不同（boolean除外），提供了相应类型的缓冲区：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>上述缓冲区的管理方式几乎一致，通过allocate()获取缓存区。<code>static XxxBuffer allocate(int capacity)</code> : 创建一个容量为 capacity 的 XxxBuffer 对象</p><h2 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h2><p>Buffer 中的重要概念：</p><ul><li>容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li><li>限制 (limit)：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li><li>位置 (position)：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li><li>标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.<br><code>标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></li></ul><h2 id="Buffer-的常用方法"><a href="#Buffer-的常用方法" class="headerlink" title="Buffer 的常用方法"></a>Buffer 的常用方法</h2><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td>Buffer clear()</td><td>清空缓冲区并返回对缓冲区的引用</td></tr><tr><td>Buffer flip()</td><td>将缓冲区的界限设置为当前位置，并将当前位置充值为 0</td></tr><tr><td>int capacity()</td><td>返回 Buffer 的 capacity 大小</td></tr><tr><td>boolean hasRemaining()</td><td>判断缓冲区中是否还有元素</td></tr><tr><td>int limit()</td><td>返回 Buffer 的界限(limit) 的位置</td></tr><tr><td>Buffer limit(int n)</td><td>将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</td></tr><tr><td>Buffer mark()</td><td>对缓冲区设置标记</td></tr><tr><td>int position()</td><td>返回缓冲区的当前位置 position</td></tr><tr><td>Buffer position(int n)</td><td>将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</td></tr><tr><td>int remaining()</td><td>返回 position 和 limit 之间的元素个数</td></tr><tr><td>Buffer reset()</td><td>将位置 position 转到以前设置的 mark 所在的位置</td></tr><tr><td>Buffer rewind()</td><td>将位置设为为 0， 取消设置的 mark</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO与IO区别</title>
    <link href="undefined2019/12/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/NIO/NIO%E4%B8%8EIO%E5%8C%BA%E5%88%AB/"/>
    <url>2019/12/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/NIO/NIO%E4%B8%8EIO%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="NIO主要内容"><a href="#NIO主要内容" class="headerlink" title="NIO主要内容"></a>NIO主要内容</h2><ol><li>Java NIO简介</li><li>Java NIO 与 IO 的主要区别</li><li>缓冲区(Buffer)和通道(Channel)</li><li>文件通道(FileChannel)</li><li>NIO 的非阻塞式网络通信<ul><li>选择器(Selector)</li><li>SocketChannel、ServerSocketChannel、DatagramChannel</li></ul></li><li>管道(Pipe)</li><li>Java NIO2 (Path、Paths 与 Files</li></ol><h2 id="Java-NIO简介"><a href="#Java-NIO简介" class="headerlink" title="Java NIO简介"></a>Java NIO简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p><h2 id="Java-NIO-与-IO-的主要区别"><a href="#Java-NIO-与-IO-的主要区别" class="headerlink" title="Java NIO 与 IO 的主要区别"></a>Java NIO 与 IO 的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流(Stream Oriented)</td><td>面向缓冲区(Buffer Oriented)</td></tr><tr><td>阻塞IO(Blocking IO)</td><td>非阻塞IO(Non Blocking IO)</td></tr><tr><td>(无)</td><td>选择器(Selectors)</td></tr></tbody></table><h2 id="通道（Channel）与缓冲区（Buffer）"><a href="#通道（Channel）与缓冲区（Buffer）" class="headerlink" title="通道（Channel）与缓冲区（Buffer）"></a>通道（Channel）与缓冲区（Buffer）</h2><p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p><p><code>简而言之，Channel 负责传输， Buffer 负责存储</code></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="undefined2019/12/18/%E5%89%8D%E7%AB%AF/Vue/vuex/"/>
    <url>2019/12/18/%E5%89%8D%E7%AB%AF/Vue/vuex/</url>
    
    <content type="html"><![CDATA[<h2 id="vuex理解"><a href="#vuex理解" class="headerlink" title="vuex理解"></a>vuex理解</h2><h3 id="vuex-是什么"><a href="#vuex-是什么" class="headerlink" title="vuex 是什么"></a>vuex 是什么</h3><p>1) github 站点: <a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">https://github.com/vuejs/vuex</a><br>2) 在线文档: <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/</a><br>3) 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)</p><p>使用vuex后，页面的属性就多store,getters属性了</p><h3 id="状态自管理应用"><a href="#状态自管理应用" class="headerlink" title="状态自管理应用"></a>状态自管理应用</h3><p>1) state: 驱动应用的数据源<br>2) view: 以声明方式将 state 映射到视图<br>3) actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法)</p><img src="/2019/12/18/%E5%89%8D%E7%AB%AF/Vue/vuex/vuex.png" srcset="undefined" class="" title="vuex"><h3 id="多组件共享状态的问题"><a href="#多组件共享状态的问题" class="headerlink" title="多组件共享状态的问题"></a>多组件共享状态的问题</h3><p>1) 多个视图依赖于同一状态<br>2) 来自不同视图的行为需要变更同一状态<br>3) 以前的解决办法<br>a. 将数据以及操作数据的行为都定义在父组件<br>b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)<br>4) vuex 就是用来解决这个问题的</p><img src="/2019/12/18/%E5%89%8D%E7%AB%AF/Vue/vuex/vuex(1).png" srcset="undefined" class="" title="vuex"><h2 id="vuex-核心概念和-API"><a href="#vuex-核心概念和-API" class="headerlink" title="vuex 核心概念和 API"></a>vuex 核心概念和 API</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>1) vuex 管理的状态对象<br>2) 它应该是唯一的</p><pre><code class="js">const state = {xxx: initValue}</code></pre><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>1) 包含多个直接更新 state 的方法(回调函数)的对象<br>2) 谁来触发: action 中的 commit(‘mutation 名称’)<br>3) 只能包含同步的代码, 不能写异步代码</p><pre><code class="js">const mutations = {yyy (state, {data1}) {// 更新 state 的某个属性}}</code></pre><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>1) 包含多个事件回调函数的对象<br>2) 通过执行: commit()来触发 mutation 的调用, 间接更新 state<br>3) 谁来触发: 组件中: $store.dispatch(‘action 名称’, data1) // ‘zzz’ 4) 可以包含异步代码(定时器, ajax)</p><pre><code class="js">const actions = {zzz ({commit, state}, data1) {commit(&#39;yyy&#39;, {data1})}}</code></pre><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>1) 包含多个计算属性(get)的对象<br>2) 谁来读取: 组件中: $store.getters.xxx</p><pre><code class="js">const getters = {mmm (state) {return ...</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全</title>
    <link href="undefined2019/12/18/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>2019/12/18/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/JUC/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li>继承Thread</li><li>实现Runnable</li><li>实现Callable<br> 一、相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常。<br> 二、执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果。FutureTask是Futrue接口的实现类</li><li>通过线程池声明</li></ol><h2 id="显示锁-Lock同步锁"><a href="#显示锁-Lock同步锁" class="headerlink" title="显示锁 Lock同步锁"></a>显示锁 Lock同步锁</h2><ul><li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li><li>ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</li></ul><ol><li>用于解决多线程安全问题的范式：<br> synchronized：隐式锁<ol><li>同步代码块</li><li>同步方法<br>jdk1.5后：</li><li>同步锁Lock<br> 注意：是一个显示锁，需要通过lock()方法上锁，必须通过unlock()方法进行释放锁</li></ol></li></ol><p>注意：<br>在可能出现线程异常的地方要把释放锁放在finally中</p><pre><code class="java">class Ticket implements Runnable {    private int tick = 100;    private Lock lock = new ReentrantLock();    @Override    public void run() {        while (true) {            lock.lock();            try{                if (tick &gt; 0) {                    try {                        Thread.sleep(200);                        System.out.println(Thread.currentThread().getName() + &quot; 完成售票，余票为： &quot; + --tick);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }else {                    break;                }            }finally {                lock.unlock();            }        }    }}</code></pre><h2 id="Condition-控制线程通信"><a href="#Condition-控制线程通信" class="headerlink" title="Condition 控制线程通信"></a>Condition 控制线程通信</h2><ul><li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li><li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。</li><li>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</li></ul><h3 id="生产者消费者案例"><a href="#生产者消费者案例" class="headerlink" title="生产者消费者案例"></a>生产者消费者案例</h3><pre><code class="java">/** * 生产者和消费者案例 */class TestProductorAndCunsumer {    public static void main(String[] args) {        Clerk clerk = new Clerk();        Productor productor = new Productor(clerk);        Consumer consumer = new Consumer(clerk);        new Thread(productor, &quot;生产者A&quot;).start();        new Thread(productor, &quot;生产者B&quot;).start();        new Thread(consumer, &quot;消费者A&quot;).start();        new Thread(consumer, &quot;消费者B&quot;).start();    }}//店员class Clerk {    private int product = 0;    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    //进货    public void get() {        try{            lock.lock();            //为了避免虚假唤醒问题，应该总是使用在循环中            while (product &gt;= 1) {                System.out.println(&quot;产品已满！&quot;);                try {//                    this.wait();                    condition.await();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + ++product);//            this.notifyAll();            condition.signalAll();        } finally {            lock.unlock();        }    }    //卖货    public void sale() {        lock.lock();        try{            //使用if会产生虚假唤醒问题            while (product &lt;= 0) {                System.out.println(&quot;缺货！&quot;);                try {//                    this.wait();                    condition.await();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + --product);//            this.notifyAll();            condition.signalAll();        } finally {            lock.unlock();        }    }}//生产者class Productor implements Runnable {    private Clerk clerk;    public Productor(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        for (int i = 0; i &lt; 20; i++) {            try {                Thread.sleep(200);            } catch (InterruptedException e) {                e.printStackTrace();            }            clerk.get();        }    }}//消费者class Consumer implements Runnable {    private Clerk clerk;    public Consumer(Clerk clerk) {        this.clerk = clerk;    }    @Override    public void run() {        for (int i = 0; i &lt; 20; i++) {            clerk.sale();        }    }}</code></pre><h2 id="线程按序交替"><a href="#线程按序交替" class="headerlink" title="线程按序交替"></a>线程按序交替</h2><blockquote><p>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。如：ABCABCABC…… 依次递归</p></blockquote><pre><code class="java">            // 1.判断            if (number != 1) {                condition1.await();            }            // 2.打印            for (int i = 1; i &lt;= 1; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i + &quot;\t&quot; + totalLoop);            }            //3.唤醒            number = 2;            condition2.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    /**     *     * @param totalLoop 循环第几轮     */    public void loopB(int totalLoop) {        lock.lock();        try {            // 1.判断            if (number != 2) {                condition2.await();            }            // 2.打印            for (int i = 1; i &lt;= 1; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i + &quot;\t&quot; + totalLoop);            }            //3.唤醒            number = 3;            condition3.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    /**     *     * @param totalLoop 循环第几轮     */    public void loopC(int totalLoop) {        lock.lock();        try {            // 1.判断            if (number != 3) {                condition3.await();            }            // 2.打印            for (int i = 1; i &lt;= 1; i++) {                System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + i + &quot;\t&quot; + totalLoop);            }            //3.唤醒            number = 1;            condition1.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}</code></pre><h2 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock 读写锁"></a>ReadWriteLock 读写锁</h2><ul><li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。</li><li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li></ul><ol><li>ReadWriteLock:读写锁</li></ol><p>写写/读写需要“互斥”<br>读读 不需要互斥</p><pre><code class="java">public class TestReadWriteLock {    public static void main(String[] args) {        ReadWriteLockDemo rw = new ReadWriteLockDemo();        for (int i = 0; i &lt; 10; i++) {            new Thread(() -&gt; rw.set(new Random().nextInt(101)), &quot; Write:&quot;).start();        }        for (int i = 0; i &lt; 100; i++) {            new Thread(rw::get, &quot;Read:&quot;).start();        }    }}class ReadWriteLockDemo {    private int number = 0;    private ReadWriteLock lock = new ReentrantReadWriteLock();    //读    public void get() {        lock.readLock().lock();        try {            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);        } finally {            lock.readLock().unlock();        }    }    //写    public void set(int number) {        lock.writeLock().lock();        try {            System.out.println(Thread.currentThread().getName());            this.number = number;        } finally {            lock.writeLock().unlock();        }    }}</code></pre><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><p>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</p><ul><li>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li><li>加个普通方法后发现和同步锁无关</li><li>换成两个对象后，不是同一把锁了，情况立刻变化。</li><li>都换成静态同步方法后，情况又变化</li><li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li><li>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li></ul><h3 id="判断打印的“one”-or-“two”"><a href="#判断打印的“one”-or-“two”" class="headerlink" title="判断打印的“one” or “two”"></a>判断打印的“one” or “two”</h3><ol><li>两个普通同步方法，两个线程，标准打印，打印？              one two</li><li>新增Thread.sleep()给getOne(),打印？                    one two</li><li>新增普通方法getThree()，打印？                         three one two</li><li>两个普通的同步方法，两个Number对象，打印？               two     one</li><li>修改getOne()为静态同步方法，打印？                      two     one</li><li>修改两个方法均为静态同步方法，一个Number对象？            one    two</li><li>一个静态同步方法，一个非静态同步方法，两个Number对象？     two    one</li><li>两个静态同步方法，两个Number对象？                       one    two</li></ol><h3 id="线程八锁的关键"><a href="#线程八锁的关键" class="headerlink" title="线程八锁的关键"></a>线程八锁的关键</h3><ol><li>非静态方法的锁默认为this，静态方法的锁为对应的Class实例</li><li>某一个时刻内，只能有一个县城持有锁，无论几个方法。</li></ol><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul><li>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li><li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li><li>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：<ul><li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li><li>Executors.newFixedThreadPool(int)（固定大小线程池）</li><li>Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。</li></ul></li></ul><ol><li><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建于晓辉额外开销，提高了相应的速度</p></li><li><p>线程池的体系结构：<br> java.util.concurrent.Executor:负责现场的使用与调度的根接口</p><pre><code> |--**ExectorService 子接口：线程池的主要接口     |--ThreadPoolExecutor 线程池的实现类     |--ScheduledExecutorService 子接口：负责线程的调度         |--ScheduledThreadPoolExecutor: 继承ThreadPoolExecutor，实现ScheduledExecutorService</code></pre></li><li><p>工具类：Executors<br> ExecutorService newFixedThreadPook()：创建固定大小的线程池<br> ExecutorService newCachedThreadPool(): 缓存线程池，线程池的数量不固定，可以根据需求自动的更新数量<br> ExecutorService newSingleThreadExecutor(): 创建单个线程池。线程池中只有一个线程</p><p> ScheduledExecutorService newScheduledThreadPool(): 创建固定大小的线程，可以延迟或定时的执行任务。</p></li></ol><pre><code class="java">public class TestThreadPool {    public static void main(String[] args) throws ExecutionException, InterruptedException {        //1. 创建线程池        ExecutorService pool = Executors.newFixedThreadPool(5);        ThreadPoolDemo threadPoolDemo = new ThreadPoolDemo();        //2. 为线程池中的线程分配任务        Future&lt;Long&gt; submit = pool.submit(() -&gt; LongStream.rangeClosed(0, 100).parallel().sum());        System.out.println(submit.get());//        for (int i = 0; i &lt; 10; i++) {//            pool.submit(threadPoolDemo);//        }        //3. 关闭线程池        //shutdown 平和的关闭，等待线程池中的所有线程执行完正在执行的程序，销毁线程池        //shutdownNow 暴力的关闭，立刻销毁线程池        pool.shutdown();    }}class ThreadPoolDemo implements Runnable{    private int i = 0;    @Override    public void run() {        while (i &lt;= 100) {            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);        }    }}</code></pre><pre><code class="java">public class TestScheduledThreadPool {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);        for (int i = 0; i &lt; 15; i++) {            ScheduledFuture&lt;Integer&gt; schedule = scheduledExecutorService.schedule(() -&gt; {                int num = new Random().nextInt(100);                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + num);                return num;            }, 3, TimeUnit.SECONDS);            System.out.println(schedule.get());        }        scheduledExecutorService.shutdown();    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
      <category>JUC线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="undefined2019/12/17/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/JUC/volatile/"/>
    <url>2019/12/17/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/JUC/volatile/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-JUC-简介"><a href="#Java-JUC-简介" class="headerlink" title="Java JUC 简介"></a>Java JUC 简介</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><ol><li>内存可见性（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</li><li>可见性错误是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</li><li>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以使用一种更加轻量级的 volatile 变量。</li></ol><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><ol><li>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：</li></ol><ul><li>对于多线程，不是一种互斥关系</li><li>不能保证变量状态的“原子性操作”</li></ul><pre><code class="java">public class TestVolatile {    public static void main(String[] args) {        ThreadDemo threadDemo = new ThreadDemo();        new Thread(threadDemo).start();        while (true) {            if (threadDemo.isFlag()) {                System.out.println(&quot;------------&quot;);                break;            }        }    }}class ThreadDemo implements Runnable{    private boolean flag = false;    @Override    public void run() {        try {            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        flag = true;        System.out.println(&quot;flag=&quot; + isFlag());    }    public boolean isFlag(){        return flag;    }    public void setFlag(boolean flag) {        this.flag = flag;    }}结果是flag=true并且循环不结束</code></pre><blockquote><p>原因：初始化时flag=false存在主存中，线程1，main线程从主存中分别拷贝后存在自己的线程的私有部分，当线程一将flag的值改变为true并协会主存后，并没有改写main线程中的值，因为main线程的while循环执行太快没有时间再次从主存中取值，所以main线程的值一直是false并且死循环。这个是内存可见性问题，当多个线程操作共享数据时，彼此不可见。</p></blockquote><p>如果加个对象锁，可以解决这个问题,但是加上对象锁后，多个线程会使程序运行效率变低。</p><pre><code class="java">public static void main(String[] args) {    ThreadDemo threadDemo = new ThreadDemo();    new Thread(threadDemo).start();    while (true) {        synchronized (threadDemo) {            if (threadDemo.isFlag()) {                System.out.println(&quot;------------&quot;);                break;            }        }    }}结果是------------flag=true</code></pre><p>volatile关键字也可以解决这个问题，他是通过直接操作主存中的数据来实现实时刷新共享数据的<br><code>private volatile boolean flag = false;</code><br>当多个线程进行操作共享数据时，可以保证内存中的数据可见。相较于synchronized是一种较为轻量级的同步策略。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>colatile不具备“互斥性”</li><li>volatile不能保证变量的“原子性”</li></ol><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="i-的原子性问题"><a href="#i-的原子性问题" class="headerlink" title="i++的原子性问题"></a>i++的原子性问题</h3><p>实际上分为三个步骤“读-改-写”</p><pre><code class="java">int i = 10;i = i++;//10//在底层int temp = i;i = i+1;i = temp;</code></pre><pre><code class="java">package Java_JUC;public class TestVolatile {    public static void main(String[] args) {        ThreadDemo threadDemo = new ThreadDemo();        new Thread(threadDemo).start();        while (true) {//            synchronized (threadDemo) {            if (threadDemo.isFlag()) {                System.out.println(&quot;------------&quot;);                break;            }//            }        }    }}class ThreadDemo implements Runnable{    private volatile boolean flag = false;    @Override    public void run() {        try {            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        flag = true;        System.out.println(&quot;flag=&quot; + isFlag());    }    public boolean isFlag(){        return flag;    }    public void setFlag(boolean flag) {        this.flag = flag;    }}</code></pre><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul><li>类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</li><li>类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</li><li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</li><li>核心方法：boolean compareAndSet(expectedValue, updateValue)</li><li>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:<ul><li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li><li>AtomicIntegerArray 、AtomicLongArray</li><li>AtomicMarkableReference</li><li>AtomicReferenceArray</li><li>AtomicStampedReferen</li></ul></li></ul><p>jdk1.5后java.util.concurrent.atomic包下提供了常用的原子变量：<br>    1. volatile保存内存可见性<br>    2. CAS（compare-And-Swap）算法保证数据的原子性<br>        CAS算法是硬件对于并发操作共享数据的支持<br>        CAS包含了三个操作数：<br>        内存值V<br>        预估值A<br>        更新值B<br>        当且仅当V == A时，V = B，否则，将不做任何操作</p><pre><code class="java">package Java_JUC;import java.util.concurrent.atomic.AtomicInteger;public class TestAtomicDemo {    public static void main(String[] args) {        AtomicDemo atomicDemo = new AtomicDemo();        for (int i = 0; i &lt; 10; i++) {            new Thread(atomicDemo).start();        }    }}class AtomicDemo implements Runnable {//    private volatile int serialNumber = 0;    private AtomicInteger serialNumber = new AtomicInteger();    @Override    public void run() {        try {            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(getSerialNumber());    }    public int getSerialNumber(){//        return serialNumber++;        return serialNumber.getAndIncrement();    }}</code></pre><h2 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h2><p>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</p><ul><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：</li><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li></ul><h2 id="ConcurrentHashMap-锁分段机制"><a href="#ConcurrentHashMap-锁分段机制" class="headerlink" title="ConcurrentHashMap 锁分段机制"></a>ConcurrentHashMap 锁分段机制</h2><ul><li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</li><li>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</li><li>此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。</li></ul><h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch 闭锁"></a>CountDownLatch 闭锁</h2><p>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能。</p><ul><li>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li><li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：</li><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li><li>等待直到某个操作所有参与者都准备就绪再继续执行。</li></ul><p>CountDownLatch：闭锁，在完成某些运算时，只有其他所有线程的运算全部完成，当前运算才继续执行</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
      <category>JUC线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快捷键</title>
    <link href="undefined2019/12/13/%E7%BC%96%E8%BE%91%E5%99%A8/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>2019/12/13/%E7%BC%96%E8%BE%91%E5%99%A8/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="同时编辑多行"><a href="#同时编辑多行" class="headerlink" title="同时编辑多行"></a>同时编辑多行</h2><p>Shift+Alt 加上鼠标左键点击</p>]]></content>
    
    
    <categories>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编辑器</tag>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复注解</title>
    <link href="undefined2019/12/13/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/"/>
    <url>2019/12/13/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="重复注解与类型注解"><a href="#重复注解与类型注解" class="headerlink" title="重复注解与类型注解"></a>重复注解与类型注解</h2><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中常用的数据类型</title>
    <link href="undefined2019/12/12/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>2019/12/12/%E5%89%8D%E7%AB%AF/JS/JS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="JS中常用的数据类型"><a href="#JS中常用的数据类型" class="headerlink" title="JS中常用的数据类型"></a>JS中常用的数据类型</h2><ul><li>基本数据类型<ul><li>数字number：常规数字和NaN</li><li>字符串string：所有用单引号、双引号、反引号（撇）包起来的都是字符串</li><li>布尔boolean：true/false</li><li>空对象指针：null</li><li>未定义：undefined</li></ul></li><li>引用数据类型<ul><li>对象数据类型object<pre><code>- {} 普通对象- [] 数组对象- /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/ 正则对象- Math数学函数对象- 日期对象- ...</code></pre></li><li>函数数据类型function</li></ul></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="number数字类型"><a href="#number数字类型" class="headerlink" title="number数字类型"></a>number数字类型</h3><blockquote><p>包含：常规数字、NaN</p></blockquote><p>NaN ：not a number</p><blockquote><p>不是一个数，但它属于数字类型</p></blockquote><p>NaN和任何值（包括自己）都不相等：NaN！=NaN，所以我们不能用相等的方式判断是否为有效数字</p><p>isNaN ：检测一个值是否为非有效数字，如果不是有效数字返回TRUE，反之返回false。</p><p>在使用isNaN进行检测的时候，受限会验证检测的值是否为数字类型，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测</p><h4 id="把其他类型值转换为数字类型"><a href="#把其他类型值转换为数字类型" class="headerlink" title="把其他类型值转换为数字类型"></a>把其他类型值转换为数字类型</h4><ul><li>Number([val])它是按照浏览器从底层机制，把其他数据类型转换为数字<ul><li>字符串：看是否半酣非有效数字字符，包含结果就是NaN；’’=&gt;0</li><li>布尔：true-&gt;1 false-&gt; 0</li><li>null： -&gt;0</li><li>undefined: -&gt; NaN</li><li>引用类型值都要先转换为字符串再转换为数字<ul><li>{}/正则/函数等 -&gt; NaN</li><li>[] -&gt; ‘’ -&gt; 0</li><li>[‘12’] -&gt; ‘12’ -&gt; 12</li><li>[12,23] -&gt; ‘12,23’ -&gt; NaN</li></ul></li></ul></li><li>parseInt/parseFloat([val],[进制])：也是转换为数字的方法，对于字符串来说，它是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不再找了），把找到的当作数字返回</li><li>==进行比较的时候,可能要出现把其他类型值转换为数字</li></ul><h2 id="string字符串数据类型"><a href="#string字符串数据类型" class="headerlink" title="string字符串数据类型"></a>string字符串数据类型</h2><blockquote><p>所有用单引号、双引号、反引号（撇ES6模板字符串）抱起来的都是字符串</p></blockquote><h3 id="把其他类型值转换为字符串"><a href="#把其他类型值转换为字符串" class="headerlink" title="把其他类型值转换为字符串"></a>把其他类型值转换为字符串</h3><ul><li>[val].toString</li><li>字符串拼接</li></ul><pre><code class="java">//===========字符串拼接//四则运算法则中，除加法之外，其余都是数学计算，只有假发可能存在字符串拼接（一旦遇到字符串，则不是数学运算，而是字符串拼接）console.log(&#39;10&#39;+10)//=》&#39;1010&#39;//用Number来转换（默认）console.log(&#39;10&#39;-10)console.log(&#39;10px&#39;-10)//=》NaN-10=NaNlet a = 10 + null + true + [] + true + undefined + &#39;珠峰&#39; + null + 32 + false + {name:&quot;sss&quot;}/*10 + null -&gt; 10 + 0 = 1010 + true -&gt; 10 + 1 = 1111 + [] -&gt; 11 + &#39;&#39; = &#39;11&#39; 空数组变为数字，先要经历变为空字符串，遇到字符串直接变为字符串拼接*/console.log(a)// 11trueundefined珠峰null32false[object Object]</code></pre><h2 id="boolean布尔数据类型"><a href="#boolean布尔数据类型" class="headerlink" title="boolean布尔数据类型"></a>boolean布尔数据类型</h2><blockquote><p>只有两个值true/false</p></blockquote><h3 id="把其他类型值转换为布尔类型"><a href="#把其他类型值转换为布尔类型" class="headerlink" title="把其他类型值转换为布尔类型"></a>把其他类型值转换为布尔类型</h3><blockquote><p>只有0、NaN、’’、null、undifined五个值转换为FALSE，其余都转换为TRUE（而且没有任何的特殊情况）</p></blockquote><ul><li>Boolean([val])</li><li>!/!!</li><li>条件判断</li></ul><h2 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null/undefined"></a>null/undefined</h2><blockquote><p>null和undefined都代表的是没有</p></blockquote><ul><li>null：意料之中（一般都是开始不知道值，我们手动先设置为null，后期再给予赋值操作）</li></ul><pre><code class="js">let num = null // let num = 0 一般最好用null作为初始的空值，因为零不是空值，他在栈内存中有自己的存储空间（占了位置）num = 12</code></pre><ul><li>undifined: 意料之外（不是我能决定的）</li></ul><pre><code class="js">let num//-》创建一个变量没有赋值，默认值是undefinednum = 12</code></pre><h2 id="object对象数据类型-普通对象"><a href="#object对象数据类型-普通对象" class="headerlink" title="object对象数据类型-普通对象"></a>object对象数据类型-普通对象</h2><blockquote><p>{[key]:[value],…}任何一个对象都是由0到多组键值对（属性名：属性值）组成的<br>  数组是特殊的对象数据类型</p></blockquote><h2 id="数据类型的区别"><a href="#数据类型的区别" class="headerlink" title="数据类型的区别"></a>数据类型的区别</h2><p>&lt;% asset_img 数据类型之间的区别.png 数据类型之间的区别 %&gt;</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li>第一题</li></ol><pre><code class="js">var str = &#39;abc123&#39;;var num = parseInt(str);if(num == NaN) {  alert(NaN)}else if( num == 123) {  alert(123)}else if (typeof num == &#39;number&#39;){  alert(&#39;number&#39;)}else {  alert(&#39;str&#39;)}</code></pre><p>结果是number<br>原因是parseInt(‘abc123’)等于NaN<br>parseInt(‘123abc’)是123<br>并且NaN不等于NaN所以是number</p><ol start="2"><li>第二题</li></ol><pre><code class="js">console.log(alert(1))结果是undefined，原因是alert函数没有返回值（默认返回值undefined）</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编程风格</title>
    <link href="undefined2019/12/12/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <url>2019/12/12/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="实体类编写规范"><a href="#实体类编写规范" class="headerlink" title="实体类编写规范"></a>实体类编写规范</h2><pre><code class="java">/** * 通过卷宗主键和创建人Id获得批注列表，以最后修改时间升序排列 * @return 批注实体列表 * @author dingjsh * time 2018年1月28日上午10:56:08 * @version 4.0.0 */@ApiOperation(value = &quot;根据卷宗Id和创建人id查询批注&quot;, notes = &quot;用于iframe的pdf渲染批注位置&quot;)@GetMapping(value = &quot;/iframe/{caseId}&quot;, produces = &quot;application/json;charset=UTF-8&quot;)@ApiResponses({ @ApiResponse(code = 200, message = &quot;操作成功, 返回数据.&quot;),@ApiResponse(code = 400, message = &quot;参数不正确&quot;), })public ResponseEntity&lt;List&lt;JzpzEntity&gt;&gt; getPzForPdf(@PathVariable(name = &quot;caseId&quot;) @ApiParam(value = &quot;caseId&quot;, required = true) String caseId) {}</code></pre><p>@ApiOperation是批注类，用在swagger上。<br>@GetMapping不仅要设置value还要设置produces属性,并根据程序功能进行修改</p><h2 id="工具类编写规范"><a href="#工具类编写规范" class="headerlink" title="工具类编写规范"></a>工具类编写规范</h2><pre><code class="java">@NoArgsConstructor(access = AccessLevel.PRIVATE)public final class SortUtil</code></pre><p>@NoArgsConstructor(access = AccessLevel.PRIVATE) lombok中用来生产私有构造方法的注解<br>工具类不会被继承也不会被声明实例对象，因此要用final修饰，是为了防止其他程序员不小心声明对象浪费内存。</p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>如果只有两种情况，那就用if/else，就算else可以省略也不要省略，这样为了方便代码阅读者理清的思维逻辑，可以更加快速的读懂你的代码</p><h2 id="循环编写"><a href="#循环编写" class="headerlink" title="循环编写"></a>循环编写</h2><p>如果集合中的数据量在1w以下，用普通的循环遍历即可，如果在1w以上，不考虑线程安全问题使用并行流parallelStream，考虑线程安全问题使用stream</p>]]></content>
    
    
    <categories>
      
      <category>编程风格</category>
      
      <category>Java编程风格</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程风格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiValueMap</title>
    <link href="undefined2019/12/12/%E5%90%8E%E7%AB%AF/Java/MultiValueMap/"/>
    <url>2019/12/12/%E5%90%8E%E7%AB%AF/Java/MultiValueMap/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">MultiValueMap&lt;String, String&gt; stringMultiValueMap = new LinkedMultiValueMap&lt;&gt;();stringMultiValueMap.add(&quot;早班 9:00-11:00&quot;, &quot;周一&quot;);stringMultiValueMap.add(&quot;早班 9:00-11:00&quot;, &quot;周二&quot;);stringMultiValueMap.add(&quot;中班 13:00-16:00&quot;, &quot;周三&quot;);stringMultiValueMap.add(&quot;早班 9:00-11:00&quot;, &quot;周四&quot;);stringMultiValueMap.add(&quot;测试1天2次 09:00 - 12:00&quot;, &quot;周五&quot;);stringMultiValueMap.add(&quot;测试1天2次 09:00 - 12:00&quot;, &quot;周六&quot;);stringMultiValueMap.add(&quot;中班 13:00-16:00&quot;, &quot;周日&quot;);    //打印所有值Set&lt;String&gt; keySet = stringMultiValueMap.keySet();for (String key : keySet) {    List&lt;String&gt; values = stringMultiValueMap.get(key);    System.out.println(StringUtils.join(values.toArray(),&quot; &quot;)+&quot;:&quot;+key);}</code></pre><blockquote><p>周一 周二 周四:早班 9:00-11:00<br>    周三 周日:中班 13:00-16:00<br>    周五 周六:测试1天2次 09:00 - 12:00</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新时间API</title>
    <link href="undefined2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%96%B0%E6%97%B6%E9%97%B4API/"/>
    <url>2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%96%B0%E6%97%B6%E9%97%B4API/</url>
    
    <content type="html"><![CDATA[<h2 id="新的时间API特点"><a href="#新的时间API特点" class="headerlink" title="新的时间API特点"></a>新的时间API特点</h2><blockquote><p>线程安全</p></blockquote><h2 id="使用-LocalDate、LocalTime、LocalDateTime"><a href="#使用-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="使用 LocalDate、LocalTime、LocalDateTime"></a>使用 LocalDate、LocalTime、LocalDateTime</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法</p><h2 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h2><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p><h2 id="Duration-和-Period"><a href="#Duration-和-Period" class="headerlink" title="Duration 和 Period"></a>Duration 和 Period</h2><ul><li>Duration:用于计算两个“时间”间隔</li><li>Period:用于计算两个“日期”间隔</li></ul><h2 id="日期的操纵"><a href="#日期的操纵" class="headerlink" title="日期的操纵"></a>日期的操纵</h2><ul><li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</li><li>TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。<br>例如获取下个周日：<code>LocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY));</code></li></ul><h2 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h2><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：<br>    - 预定义的标准格式<br>    - 语言环境相关的格式<br>    - 自定义的格式</p><h2 id="时区的处理"><a href="#时区的处理" class="headerlink" title="时区的处理"></a>时区的处理</h2><p>Java8 中加入了对时区的支持，带时区的时间为分别为：<br>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等<br>ZoneId：该类中包含了所有的时区信息<br>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><h2 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h2><pre><code class="java">//DateTimeFormatter:格式化时间/日期@Testpublic void test5() {    DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_DATE;    LocalDateTime l = LocalDateTime.now();    String strDate = l.format(dateTimeFormatter);    System.out.println(strDate);    DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);    System.out.println(l.format(dateTimeFormatter1));    LocalDateTime of = LocalDateTime.parse(l.format(dateTimeFormatter1), dateTimeFormatter1);    System.out.println(of);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口中的默认方法与静态方法</title>
    <link href="undefined2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <url>2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h2><h3 id="接口默认方法的”类优先”原则"><a href="#接口默认方法的”类优先”原则" class="headerlink" title="接口默认方法的”类优先”原则"></a>接口默认方法的”类优先”原则</h3><blockquote><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时<br>    - 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。<br>    - 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。</p></blockquote><pre><code class="java">public class Fclass {    public String Xiao(){        return &quot;呵呵呵呵呵呵&quot;;    }}</code></pre><pre><code class="java">public interface MyInterface1 {    default String Xiao(){        return &quot;哈哈哈哈哈哈&quot;;    }}</code></pre><pre><code class="java">public interface MyInterface2 {    default String Xiao(){        return &quot;嘿嘿嘿嘿嘿嘿嘿&quot;;    }}</code></pre><pre><code class="java">import org.junit.Test;public class Cclass extends Fclass implements MyInterface1, MyInterface2 {    @Test    public void test1(){        Cclass cclass = new Cclass();        System.out.println(cclass.Xiao());    }}// 结果是// 呵呵呵呵呵呵</code></pre><pre><code class="java">public class Cclass implements MyInterface1, MyInterface2 {    @Test    public void test1(){        Cclass cclass = new Cclass();        System.out.println(cclass.Xiao());    }    @Override    public String Xiao() {        return MyInterface1.super.Xiao();    }}// 结果是// 哈哈哈哈哈哈</code></pre><pre><code class="java">import org.junit.Test;public class Cclass implements MyInterface1, MyInterface2 {    @Test    public void test1(){        Cclass cclass = new Cclass();        System.out.println(cclass.Xiao());    }    @Override    public String Xiao() {        return MyInterface2.super.Xiao();    }}// 结果是// 嘿嘿嘿嘿嘿嘿嘿</code></pre><h2 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h2><p>Java8 中，接口中允许添加静态方法</p><pre><code class="java">public interface MyInterface1 {    default String Xiao(){        return &quot;哈哈哈哈哈哈&quot;;    }    static void show(){        System.out.println(&quot;我是静态方法，我再接口里面&quot;);    }}</code></pre><pre><code class="java">public class Fclass {    public String Xiao(){        return &quot;呵呵呵呵呵呵&quot;;    }    static void show(){        System.out.println(&quot;我是静态方法，我再里面&quot;);    }}</code></pre><pre><code class="java">import org.junit.Test;public class Cclass implements MyInterface1, MyInterface2 {    @Test    public void test1(){        Cclass cclass = new Cclass();        System.out.println(cclass.Xiao());//        Cclass.show();        Fclass.show();        MyInterface1.show();    }    @Override    public String Xiao() {        return MyInterface2.super.Xiao();    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optional类</title>
    <link href="undefined2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Optional%E7%B1%BB/"/>
    <url>2019/12/12/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Optional%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><blockquote><p>Optional&lt;T&gt; 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p></blockquote><p>常用方法：<br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值orElse(T t) : 如果调用对象包含值，返回该值，否则返回<br>torElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Option</p><pre><code class="java">public class TestOptional {    @Test    public void test1(){        Optional&lt;Employee&gt; employee = Optional.of(new Employee());        Optional&lt;Employee&gt; employee1 = Optional.of(null);        Employee emp = employee.get();        System.out.println(emp);    }    // 快速定位空指针异常位置    @Test    public void test2(){        Optional&lt;Employee&gt; employee = Optional.empty();        System.out.println(employee.get());    }    // 快速定位空指针异常位置    @Test    public void test3(){//        Optional&lt;Employee&gt; o = Optional.ofNullable(new Employee());        Optional&lt;Employee&gt; o = Optional.ofNullable(null);//        if (o.isPresent()) {//            System.out.println(o.get());//        }//        Employee employee = o.orElse(new Employee(&quot;张三&quot;, 19, 29393, Employee.Status.FREE));//        System.out.println(employee);        Employee employee1 = o.orElseGet(() -&gt; new Employee(&quot;李四&quot;, 19, 29393, Employee.Status.FREE));        System.out.println(employee1);    }    //Employee{name=&#39;李四&#39;, age=19, salary=29393.0, Status=FREE}    @Test    public void test4(){        Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee(&quot;张三&quot;, 19, 29393, Employee.Status.FREE));//        Optional&lt;String&gt; s = op.map(e -&gt; e.getName());//        System.out.println(s.get());        Optional&lt;String&gt; s2 = op.flatMap(e -&gt; Optional.of(e.getName()));        System.out.println(s2.get());    }    //张三}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronized</title>
    <link href="undefined2019/12/11/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized/"/>
    <url>2019/12/11/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized/</url>
    
    <content type="html"><![CDATA[<h2 id="synchronized的作用"><a href="#synchronized的作用" class="headerlink" title="synchronized的作用"></a>synchronized的作用</h2><blockquote><p>同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的。</p></blockquote><p>能够保证在<code>同一时刻</code>最多只有<code>一个</code>线程执行该段代码，以达到保证并发安全的效果。</p><h2 id="Synchronized的地位"><a href="#Synchronized的地位" class="headerlink" title="Synchronized的地位"></a>Synchronized的地位</h2><ul><li>Synchronized是Java的<code>关键字</code>，被Java语言原生支持</li><li>是<code>最基本</code>的额互斥同步手段</li><li>是并发编程中的<code>元老级</code>角色，是并发编程的<code>必学</code>内容</li></ul><h2 id="不使用并发手段会有什么后果"><a href="#不使用并发手段会有什么后果" class="headerlink" title="不使用并发手段会有什么后果"></a>不使用并发手段会有什么后果</h2><p>代码实战：两个线程同时a++，最后结果会比预计的少</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class DisppearRequest1 implements Runnable{    static DisppearRequest1 instance = new DisppearRequest1();    static int i = 0;    public static void main(String[] args) throws InterruptedException {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(i);    }    @Override    public void run() {        for (int j = 0; j &lt; 100000; j++) {            i++;        }    }}</code></pre><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>count++，它看上去只是一个操作，实际上包含了三个动作：</p><ol><li>读取count</li><li>将count加一</li><li>讲count的值写入到内存中</li></ol><h2 id="Synchronized的两个用法"><a href="#Synchronized的两个用法" class="headerlink" title="Synchronized的两个用法"></a>Synchronized的两个用法</h2><p><strong>对象锁</strong><br>包括<code>方发锁</code><strong>（默认锁对象为this当前实例对象）</strong>和<code>同步代码块锁</code><strong>（自己指定锁对象）</strong></p><p><strong>类锁</strong><br>指synchronized修饰<code>静态</code>的方法或指定锁为<code>Class对象</code>。</p><h3 id="第一个用法：对象锁"><a href="#第一个用法：对象锁" class="headerlink" title="第一个用法：对象锁"></a>第一个用法：对象锁</h3><p>代码块形式：手动指定锁对象<br>方发锁形式：synchronized修饰普通方法，锁对象默认为this</p><pre><code class="java">// 代码块形式public class SynchronizedObjectCodeBlock2 implements Runnable {    static SynchronizedObjectCodeBlock2 instance = new SynchronizedObjectCodeBlock2();    Object lock1 = new Object();    Object lock2 = new Object();    @Override    public void run() {        synchronized (lock1) {            System.out.println(&quot;我叫lock1代码块形式。我叫&quot; + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;lock1运行结束。&quot;);        }        synchronized (lock2) {            System.out.println(&quot;我收lock2代码块形式。我叫&quot; + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;lock2运行结束。&quot;);        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }}</code></pre><pre><code class="java">//方发锁形式public class SynchronizedObjectMethod3 implements Runnable{    static SynchronizedObjectMethod3 instance = new SynchronizedObjectMethod3();    Object lock1 = new Object();    Object lock2 = new Object();    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println(&quot;我的对象锁 的方法修饰符形式 ，我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;运行结束。&quot;);    }    public static void main(String[] args) {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }}</code></pre><h3 id="第二个用法：类锁"><a href="#第二个用法：类锁" class="headerlink" title="第二个用法：类锁"></a>第二个用法：类锁</h3><p><strong>只有一个Class对象</strong>：Java类可能会有很多个对象，但是只有一个Class对象。<br><strong>本质</strong>：所以所谓的类锁，不过是Class对象的锁而已。<br><strong>用法和效果</strong>：类锁只能在同一时刻被一个对象拥有。</p><blockquote><p>两种形式<br>    1. 形式1：synchronized加static方法上<br>    2. 形式2：synchronized（*.class）代码块</p></blockquote><pre><code class="java">// 形式1：synchronized加static方法上public class SynchronizedClassStatic4 implements Runnable{    static SynchronizedClassStatic4 instance1 = new SynchronizedClassStatic4();    static SynchronizedClassStatic4 instance2 = new SynchronizedClassStatic4();    @Override    public void run() {        method();    }    public static synchronized void method(){        System.out.println(&quot;我的类锁 的第一种形式 ，我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;运行结束。&quot;);    }    public static void main(String[] args) {        Thread t1 = new Thread(instance1);        Thread t2 = new Thread(instance2);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }}// 形式2：synchronized（*.class）代码块public class SynchronizedClassClass5 implements Runnable {    static SynchronizedClassClass5 instance1 = new SynchronizedClassClass5();    static SynchronizedClassClass5 instance2 = new SynchronizedClassClass5();    @Override    public void run() {        method();    }    public void method(){        synchronized (SynchronizedClassClass5.class) {            System.out.println(&quot;我是类锁的第二种形式：synchronized（*.class）。我叫&quot; + Thread.currentThread());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread() + &quot;运行结束&quot;);        }    }    public static void main(String[] args) {        Thread t1 = new Thread(instance1);        Thread t2 = new Thread(instance2);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }}</code></pre><h2 id="多线程访问同步方法的7中情况（面试常考）"><a href="#多线程访问同步方法的7中情况（面试常考）" class="headerlink" title="多线程访问同步方法的7中情况（面试常考）"></a>多线程访问同步方法的7中情况（面试常考）</h2><ol><li>两个线程同时访问一个对象的同步方法                    =&gt;  串行</li><li>两个线程访问的使两个对象的同步方法                    =&gt;  并行</li><li>两个线程访问的是synchronized的静态方法               =&gt;  串行</li><li>同时访问同步方法与非同步方法                         =&gt;  并行</li><li>访问同一个对象的不同的普通同步方法                   =&gt;  串行</li><li>同时访问静态synchronized和非静态synchronized方法     =&gt;  并行</li><li>方法抛异常后，会<strong>释放锁</strong>(lock不会释放)</li></ol><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol><li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（1，5）</li><li>每个实例都对应有自己的一把锁，不同势力之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把类锁（2，3，4，6）</li><li>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（7）</li></ol><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><blockquote><p>什么是可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁</p></blockquote><ul><li>好处：避免死锁、提升封装性</li><li>粒度：线程而非调用（用3种情况来说明和pthread的区别）<ul><li>情况1：证明同一个方法是可重入的</li><li>情况2：证明可重入不要求是同一个方法</li><li>情况3：证明可重入不要求是同一个类种的</li></ul></li></ul><h3 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h3><p>一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，知道别的线程<strong>释放</strong>这个锁。如果别人永远不释放锁，那么我只能永远地等下去。</p><p>相比之下，未来会介绍的Lock类，可以拥有中断的能力，第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行；第二点，如果我觉得我等待的时间太长了不想再等了，也可以退出。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>加锁和释放锁的原理：现象、实际、深入JVM看字节码</li><li>可重入原理：加锁次数计数器</li><li>保证可见性的原理：内存模型</li></ol><p>加锁和释放锁的原理<br>现象<br>获取和释放锁的时机：内置锁</p><p>Java内置反编译指令  javap （-verbose） Decompilation14.class</p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><blockquote><p>加锁次数计数器</p></blockquote><ol><li>JVM负责跟踪对象被加锁的次数</li><li>线程第一次给对象加锁的时候，技术变为1.每当这个相同的线程在此对象上再次获得锁时，计数会递增。</li><li>每当任务离开时，计数递减，当计数为0的时候，锁被完全释放。</li></ol><h3 id="可见性原理：Java内存模型"><a href="#可见性原理：Java内存模型" class="headerlink" title="可见性原理：Java内存模型"></a>可见性原理：Java内存模型</h3><img src="/2019/12/11/%E5%90%8E%E7%AB%AF/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/Synchronized/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="undefined" class="" title="内存模型"><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol><li>效率低：锁的释放情况少，试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程。</li><li>不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能时不够的。</li><li>无法知道是否成功的获取到锁。</li></ol><h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><ol><li>使用注意点：锁对象不能为空、作用域不宜过大、避免死锁</li><li>如何选择Lock和synchronized关键字？<ol><li>如果可以尽量用java.util.concurrent包中的类，不需要自己作同步工作。</li><li>如果synchronized关键字适用，那么就优先适用synchronized关键字，这样可以减少我们编写的代码。</li><li>如果需要使用Lock或condition特性的时候，那么才使用他们。</li></ol></li><li>多线程访问同步方法的各种具体情况。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行流和串行流</title>
    <link href="undefined2019/12/11/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%92%8C%E4%B8%B2%E8%A1%8C%E6%B5%81/"/>
    <url>2019/12/11/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%92%8C%E4%B8%B2%E8%A1%8C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h2><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。<br>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p><h2 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h2><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。</p><h3 id="Fork-Join-框架与传统线程池的区别"><a href="#Fork-Join-框架与传统线程池的区别" class="headerlink" title="Fork/Join 框架与传统线程池的区别"></a>Fork/Join 框架与传统线程池的区别</h3><blockquote><p>采用 “工作窃取”模式（work-stealing）：<br>    当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。<br>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能。</p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><pre><code class="java">import org.junit.Test;import java.util.concurrent.RecursiveTask;import java.util.stream.LongStream;/*RecursiveAction没有返回值RecursiveTask有返回值 */public class ForkJoinCalculate extends RecursiveTask&lt;Long&gt; {    private long start;    private long end;    private static final long THRESHOLD = 10000;    public ForkJoinCalculate(long start, long end) {        this.start = start;        this.end = end;    }    @Override    protected Long compute() {        long length = end - start;        if (length &lt;= THRESHOLD) {            long sum = 0;            for (long i = start; i &lt;= end; i++) {                sum += i;            }            return sum;        } else {            long middle = (start + end) / 2;            ForkJoinCalculate left = new ForkJoinCalculate(start, middle);            left.fork(); // 拆分子任务，同时压入线程队列            ForkJoinCalculate right = new ForkJoinCalculate(middle + 1, end);            right.fork();            return left.join() + right.join();        }    }}</code></pre><pre><code class="java">import org.junit.Test;import java.time.Duration;import java.time.Instant;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.stream.LongStream;public class TestForkJoin {    @Test    public void test1() {        long start = System.currentTimeMillis();        ForkJoinPool pool = new ForkJoinPool();        ForkJoinTask&lt;Long&gt; task = new ForkJoinCalculate(0, 10000000000L);        Long sum = pool.invoke(task);        System.out.println(sum);        long end = System.currentTimeMillis();        System.out.println(&quot;耗费时间：&quot; + (end - start) + &quot;ms&quot;);    }    @Test    public void test2() {        Instant start = Instant.now();        long sum = 0;        for (long i = 0; i &lt;= 100000000000L; i++) {            sum += i;        }        System.out.println(sum);        Instant end = Instant.now();        System.out.println(&quot;耗费时间：&quot; + Duration.between(start, end).toMillis() + &quot;ms&quot;);    }    /**     * java8并行流     */    @Test    public void test3() {        Instant start = Instant.now();        LongStream.rangeClosed(0, 10000000000L).parallel().reduce(0, Long::sum);        Instant end = Instant.now();        System.out.println(&quot;耗费时间：&quot; + Duration.between(start, end).toMillis() + &quot;ms&quot;);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS命名规范</title>
    <link href="undefined2019/12/10/%E5%89%8D%E7%AB%AF/JS/JS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>2019/12/10/%E5%89%8D%E7%AB%AF/JS/JS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="JS中的命名规范"><a href="#JS中的命名规范" class="headerlink" title="JS中的命名规范"></a>JS中的命名规范</h2><ul><li>严格区分大小写</li></ul><pre><code class="js">let Test=100;console.log(test);//=&gt;无法输出，因为第一个字母小写了</code></pre><ul><li>使用数字、字母、下划线、$，数字不能作为开头</li></ul><pre><code class="js">let $box; //=&gt;一般用JQ获取的以$开头let _box; //=&gt;一般公共变量都是_开头let 1box; //=&gt;不可以，但是可以写box1</code></pre><ul><li>使用驼峰命名法：首字母小写，其余每一个有意义单词的首字母都要大写（命名尽可能语义化明显，使用英文单词）</li></ul><pre><code class="js">let studentInformation;let studentInfo;//常用的缩写：add/insert/create/new（新增）、update（修改）、delete/del/remove/rm（删除）、sel/select/query/get（查询）、info（信息）...//不正确的写法let xueshengInfo;let xueshengxinxi;let xsxx;</code></pre><ul><li>不能使用关键字和保留字</li></ul><pre><code class="js">当下有特殊含义的是关键字，未来可能会成为关键字的叫做保留字(？)var let const function ...var var = 10; //=&gt;肯定不行的</code></pre><p>//=&gt;代码强迫症（代码洁癖）：良好的编程习惯、极客精神</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用浏览器</title>
    <link href="undefined2019/12/10/%E5%89%8D%E7%AB%AF/JS/%E5%B8%B8%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>2019/12/10/%E5%89%8D%E7%AB%AF/JS/%E5%B8%B8%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的浏览器"><a href="#常用的浏览器" class="headerlink" title="常用的浏览器"></a>常用的浏览器</h2><ul><li>webkit内核(V8引擎)<ul><li>谷歌Chrome</li><li>Safari</li><li>Opera &gt;=V14</li><li>国产浏览器</li><li>手机浏览器</li><li>…</li></ul></li><li>Gecko<ul><li>火狐Firefox</li></ul></li><li>Presto<ul><li>Opera &lt;V14</li></ul></li><li>Trident<ul><li>IE</li><li>IE EDGE开始采用双内核（其中包含chrome迷你）</li></ul></li></ul><p>谷歌浏览器的控制台（F12/Fn+F12）<br>    - Elements：查看结构样式，可以修改这些内容<br>    - Console：查看输出结果和报错信息，是JS调试的利器<br>    - Sources：查看项目源码<br>    - Network：查看当前网站所有资源的请求信息（包括和服务器传输的HTTP报文信息）、加载时间等（根据加载时间进行项目优化）<br>    - Application：查看当前网站的数据存储和资源文件（可以盗图）</p><h2 id="JS做客户端语言"><a href="#JS做客户端语言" class="headerlink" title="JS做客户端语言"></a>JS做客户端语言</h2><blockquote><p>按照相关的JS语法，去操作页面中的元素，有时还要操作浏览器里面的一些功能<br>    - ECMAScript3/5/6…：JS的语法规范（变量、数据类型、操作语句等等）<br>    - DOM（document object model）：文档对象模型，提供一些JS的属性和方法，用来操作页面中的DOM元素<br>    - BOM（browser object model）：浏览器对象模型，提供一些JS的属性和方法，用来操作浏览器的</p></blockquote><h2 id="JS中的变量-variable"><a href="#JS中的变量-variable" class="headerlink" title="JS中的变量 variable"></a>JS中的变量 variable</h2><blockquote><p>变量：可变的量，在编程语言中，变量其实就是一个名字，用来存储和代表不同值的东西</p></blockquote><pre><code class="js">//ES3var a = 12;a = 13;console.log(a); //=&gt;输出的是a代表的值13//ES6let b = 100;b = 200;const c = 1000;c = 2000; //=&gt;报错：CONST创建的变量，存储的值不能被修改（可以理解为叫做常量）//创建函数也相当于在创建变量function fn(){}//创建类也相当于创建变量class A{}//ES6的模块导入也可以创建变量import B from &#39;./B.js&#39;;//Symbol创建唯一值let n=Symbol(100);let m=Symbol(100);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="undefined2019/12/10/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Stream/"/>
    <url>2019/12/10/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h2><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 <strong>Stream API(java.util.stream.*)</strong>。<br>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br><strong>“集合讲的是数据，流讲的是计算！”</strong><br>注意：<br>    1. Stream 自己不会存储元素。<br>    2. Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<br>    3. Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><h2 id="Stream-的操作三个步骤"><a href="#Stream-的操作三个步骤" class="headerlink" title="Stream 的操作三个步骤"></a>Stream 的操作三个步骤</h2><ul><li>创建 Stream<br>  一个数据源（如：集合、数组），获取一个流</li><li>中间操作<br>  一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作)<br>  一个终止操作，执行中间操作链，并产生结果</li></ul><h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>Java8 中的 Collection 接口被扩展，提供了<br>两个获取流的方法：<br>    - default Stream&lt;E&gt; stream() : 返回一个顺序流<br>    - default Stream&lt;E&gt; parallelStream() : 返回一个并行流</p><ol><li>由数组创建流</li><li>由值创建流</li><li>由函数创建流：创建无限流</li></ol><pre><code class="java">@Testpublic void test1(){    //1.可以公共Collection系列集合提供的stream()或parallelStream()    List&lt;String&gt; list = new ArrayList&lt;&gt;();    Stream&lt;String&gt; stream = list.stream();    //2. 通过Arrays中的静态方法stream()获取数组流    Employee[] employees = new Employee[10];    Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);    //3. 通过Stream类中的静态方法of()    Stream&lt;String&gt; stream2 = Stream.of(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);    //4. 创建无限流    //迭代    Stream&lt;Integer&gt; iterate = Stream.iterate(0, (x) -&gt; x + 2);    iterate.limit(10).forEach(System.out::println);    //生成    Stream.generate(() -&gt; (int) (Math.random() * 100))    .limit(5).forEach(System.out::println);}</code></pre><h2 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h2><p>多个<strong>中间操作</strong>可以连接起来形成一个<strong>流水线</strong>，除非流水线上触发终止操作，否则<strong>中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</strong></p><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter(Predicate p)</td><td>接收 Lambda ， 从流中排除某些元素。</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量。</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr></tbody></table><pre><code class="java">@Testpublic void test2(){    List&lt;Employee&gt; emps = Arrays.asList(            new Employee(&quot;张三&quot;, 18, 9999.99),            new Employee(&quot;李四&quot;, 59, 6669.99),            new Employee(&quot;王五&quot;, 18, 3333.99),            new Employee(&quot;赵六&quot;, 18, 2222.99),            new Employee(&quot;田七&quot;, 18, 5555.99),            new Employee(&quot;java&quot;, 18, 5555.99)    );    Stream&lt;Employee&gt; stream = emps.stream();    //中间操作：不会执行任何操作    Stream&lt;Employee&gt; employeeStream = stream.filter(e -&gt; e.getAge() &gt; 35);    //终止操作，执行终止操作才会操作中间操作，否则中间操作不会执行    //一次性执行全部内容，即“惰性求值”    employeeStream.forEach(System.out::println);}List&lt;Employee&gt; emps = Arrays.asList(        new Employee(&quot;张三&quot;, 18, 9999.99),        new Employee(&quot;李四&quot;, 59, 6669.99),        new Employee(&quot;王五&quot;, 18, 3333.99),        new Employee(&quot;赵六&quot;, 18, 2222.99),        new Employee(&quot;田七&quot;, 18, 5555.99),        new Employee(&quot;田七&quot;, 18, 5555.99),        new Employee(&quot;田七&quot;, 18, 5555.99),        new Employee(&quot;田七&quot;, 18, 5555.99),        new Employee(&quot;java&quot;, 18, 5555.99));@Testpublic void test2(){    Stream&lt;Employee&gt; stream = emps.stream();    //中间操作：不会执行任何操作    Stream&lt;Employee&gt; employeeStream = stream.filter(e -&gt; e.getAge() &gt; 35);    //终止操作，执行终止操作才会操作中间操作，否则中间操作不会执行    //一次性执行全部内容，即“惰性求值”    employeeStream.forEach(System.out::println);}@Testpublic void test3(){    emps.stream().filter(e -&gt; {        System.out.println(&quot;短路&quot;);        return e.getSalary() &gt; 5000;    }).limit(2).forEach(System.out::println);}@Testpublic void test4(){    emps.stream().filter(employee -&gt; {        System.out.println(&quot;跳过&quot;);        return employee.getSalary() &gt; 5000;    }).skip(2).forEach(System.out::println);}@Testpublic void test5(){    emps.stream().filter(employee -&gt; employee.getSalary() &gt; 5000)    .distinct().forEach(System.out::println);}</code></pre><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>map(Function f</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td></tr><tr><td>mapToInt(ToIntFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><pre><code class="java">@Testpublic void test6(){    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;eeee&quot;);    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);    emps.stream().map(Employee::getName).forEach(System.out::println);    System.out.println(&quot;-----------------&quot;);    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPI1::filterCharacter);    streamStream.forEach(sm -&gt; {        sm.forEach(System.out::println);    });    System.out.println(&quot;--------------&quot;);    Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPI1::filterCharacter);    characterStream.forEach(System.out::println);}public static Stream&lt;Character&gt; filterCharacter(String string) {    List&lt;Character&gt; list = new ArrayList&lt;&gt;();    for (Character character : string.toCharArray()) {        list.add(character);    }    return list.stream();}</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator comp)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><pre><code class="java">@Testpublic void test7(){    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;dddd&quot;,&quot;eeee&quot;);    list.stream().sorted().forEach(System.out::println);    emps.stream().sorted((a, b) -&gt; a.getAge() == b.getAge() ? a.getName().compareTo(b.getName()) : a.getAge() - b.getAge())    .forEach(System.out::println);}</code></pre><h2 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h2><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p><h3 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>min(Comparator c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td>内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td></tr></tbody></table><pre><code class="java">import java.util.Objects;public class Employee {    private String name;    private int age;    private double salary;    private Status Status;    public Employee() {    }    public Employee(String name) {        this.name = name;    }    public Employee(String name, int age, double salary, Employee.Status status) {        this.name = name;        this.age = age;        this.salary = salary;        Status = status;    }    public Employee.Status getStatus() {        return Status;    }    public void setStatus(Employee.Status status) {        Status = status;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Employee employee = (Employee) o;        return age == employee.age &amp;&amp;                Double.compare(employee.salary, salary) == 0 &amp;&amp;                Objects.equals(name, employee.name);    }    @Override    public int hashCode() {        return Objects.hash(name, age, salary);    }    @Override    public String toString() {        return &quot;Employee{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, salary=&quot; + salary +                &quot;, Status=&quot; + Status +                &#39;}&#39;;    }    public Employee(String name, int age, double salary) {        this.name = name;        this.age = age;        this.salary = salary;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public double getSalary() {        return salary;    }    public void setSalary(double salary) {        this.salary = salary;    }    public enum Status{        FREE,        BUSY,        VOCATION;    }}</code></pre><pre><code class="java">List&lt;Employee&gt; emps = Arrays.asList(        new Employee(&quot;张三&quot;, 42, 9999.99, Employee.Status.BUSY),        new Employee(&quot;李四&quot;, 59, 6669.99, Employee.Status.FREE),        new Employee(&quot;王五&quot;, 18, 3333.99, Employee.Status.BUSY),        new Employee(&quot;赵六&quot;, 15, 2222.99, Employee.Status.VOCATION),        new Employee(&quot;田七&quot;, 12, 5555.99, Employee.Status.VOCATION),        new Employee(&quot;田七&quot;, 13, 5555.99, Employee.Status.VOCATION),        new Employee(&quot;田七&quot;, 18, 5555.99, Employee.Status.FREE),        new Employee(&quot;田七&quot;, 18, 5555.99, Employee.Status.BUSY),        new Employee(&quot;java&quot;, 21, 5555.99, Employee.Status.BUSY));@Testpublic void test8(){    boolean b1 = emps.stream().allMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));    boolean b2 = emps.stream().anyMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));    boolean b3 = emps.stream().noneMatch(e -&gt; e.getStatus().equals(Employee.Status.BUSY));    System.out.println(b1);    System.out.println(b2);    System.out.println(b3);    Optional&lt;Employee&gt; first = emps.stream().sorted((e1, e2) -&gt; -Double.compare(e1.getSalary(), e2.getSalary())).findFirst();    System.out.println(first.get());    Optional&lt;Employee&gt; any = emps.parallelStream().filter(e -&gt; e.getStatus().equals(Employee.Status.FREE)).findAny();    System.out.println(any.get());}@Testpublic void test9(){    long count = emps.stream().count();    System.out.println(count);    Optional&lt;Employee&gt; max = emps.stream().max(Comparator.comparingDouble(Employee::getSalary));    Optional&lt;Double&gt; min = emps.stream().map(Employee::getSalary).min(Double::compareTo);    System.out.println(max.get());    System.out.println(&quot;salary&quot; + min);}</code></pre><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</td></tr></tbody></table><blockquote><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p></blockquote><pre><code class="java">@Testpublic void test10(){    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);    Integer sum = list.stream().reduce(0, Integer::sum);    System.out.println(sum);    System.out.println(&quot;-------------&quot;);    Optional&lt;Double&gt; reduce = emps.stream().map(Employee::getSalary).reduce(Double::sum);    System.out.println(reduce.get());}</code></pre><h3 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>toList</td><td>List&lt;T&gt;</td><td>把流中元素收集到List</td><td>List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</td></tr><tr><td>toSet</td><td>Set&lt;T&gt;</td><td>把流中元素收集到Set</td><td>Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</td></tr><tr><td>toCollection</td><td>Collection&lt;T&gt;</td><td>把流中元素收集到创建的集合</td><td>Collection&lt;Employee&gt;emps=list.stream().collect(Collectors.toCollection(ArrayList::new));</td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td><td>long count = list.stream().collect(Collectors.counting());</td></tr><tr><td>summingInt</td><td>Integer</td><td>对流中元素的整数属性求和</td><td>inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td><td>doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>收集流中Integer属性的统计值。如：平均值</td><td>IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td></tr><tr><td>joining</td><td>String</td><td>连接流中每个字符串</td><td>String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td></tr><tr><td>maxBy</td><td>Optional&lt;T&gt;</td><td>根据比较器选择最大值</td><td>Optional<Emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</td></tr><tr><td>minBy</td><td>Optional&lt;T&gt;</td><td>根据比较器选择最小值</td><td>Optional<Emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</td></tr><tr><td>reducing</td><td>归约产生的类型</td><td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td><td>inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果转换函数</td><td>inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td></tr><tr><td>groupingBy</td><td>Map&lt;K, List&lt;T&gt;&gt;</td><td>根据某属性值对流分组，属性为K，结果为V</td><td>Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td></tr><tr><td>partitioningBy</td><td>Map&lt;Boolean, List&lt;T&gt;&gt;</td><td>根据true或false进行分区</td><td>Map&lt;Boolean,List<Emp>&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td></tr></tbody></table><pre><code class="java">@Testpublic void test11(){    List&lt;String&gt; collect = emps.stream().map(Employee::getName).distinct().collect(Collectors.toList());    collect.forEach(System.out::println);    System.out.println(&quot;---------------&quot;);    Set&lt;String&gt; collect1 = emps.stream().map(Employee::getName).collect(Collectors.toSet());    collect1.forEach(System.out::println);    System.out.println(&quot;---------------&quot;);    HashSet&lt;String&gt; collect2 = emps.stream().map(Employee::getName).collect(Collectors.toCollection(HashSet::new));    collect2.forEach(System.out::println);    System.out.println(&quot;---------------&quot;);    Double collect3 = emps.stream().collect(Collectors.averagingDouble(Employee::getSalary));    System.out.println(collect3);    //分组    Map&lt;Employee.Status, List&lt;Employee&gt;&gt; collect4 = emps.stream().collect(Collectors.groupingBy(Employee::getStatus));    System.out.println(collect4);    //多级分组    System.out.println(&quot;--------------&quot;);    Map&lt;Employee.Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect5 = emps.stream().collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(e -&gt; {        if (e.getAge() &lt;= 20) {            return &quot;青年&quot;;        } else if (e.getAge() &lt;= 40) {            return &quot;中年&quot;;        } else {            return &quot;老年&quot;;        }    })));    System.out.println(collect5);    //分区    System.out.println(&quot;--------------&quot;);    Map&lt;Boolean, List&lt;Employee&gt;&gt; collect6 = emps.stream().collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; 7000));    System.out.println(collect6);    System.out.println(&quot;--------------&quot;);    DoubleSummaryStatistics collect7 = emps.stream().collect(Collectors.summarizingDouble(Employee::getSalary));    System.out.println(collect7.getMax());    System.out.println(&quot;--------------&quot;);    String collect8 = emps.stream().map(Employee::getName).collect(Collectors.joining(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;));    System.out.println(collect8);}结果为：张三李四王五赵六田七java---------------李四张三java王五赵六田七---------------李四张三java王五赵六田七---------------5556.323333333333{VOCATION=[Employee{name=&#39;赵六&#39;, age=15, salary=2222.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=12, salary=5555.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=13, salary=5555.99, Status=VOCATION}], BUSY=[Employee{name=&#39;张三&#39;, age=42, salary=9999.99, Status=BUSY}, Employee{name=&#39;王五&#39;, age=18, salary=3333.99, Status=BUSY}, Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=BUSY}, Employee{name=&#39;java&#39;, age=21, salary=5555.99, Status=BUSY}], FREE=[Employee{name=&#39;李四&#39;, age=59, salary=6669.99, Status=FREE}, Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=FREE}]}--------------{VOCATION={青年=[Employee{name=&#39;赵六&#39;, age=15, salary=2222.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=12, salary=5555.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=13, salary=5555.99, Status=VOCATION}]}, BUSY={青年=[Employee{name=&#39;王五&#39;, age=18, salary=3333.99, Status=BUSY}, Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=BUSY}], 老年=[Employee{name=&#39;张三&#39;, age=42, salary=9999.99, Status=BUSY}], 中年=[Employee{name=&#39;java&#39;, age=21, salary=5555.99, Status=BUSY}]}, FREE={青年=[Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=FREE}], 老年=[Employee{name=&#39;李四&#39;, age=59, salary=6669.99, Status=FREE}]}}--------------{false=[Employee{name=&#39;李四&#39;, age=59, salary=6669.99, Status=FREE}, Employee{name=&#39;王五&#39;, age=18, salary=3333.99, Status=BUSY}, Employee{name=&#39;赵六&#39;, age=15, salary=2222.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=12, salary=5555.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=13, salary=5555.99, Status=VOCATION}, Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=FREE}, Employee{name=&#39;田七&#39;, age=18, salary=5555.99, Status=BUSY}, Employee{name=&#39;java&#39;, age=21, salary=5555.99, Status=BUSY}], true=[Employee{name=&#39;张三&#39;, age=42, salary=9999.99, Status=BUSY}]}--------------9999.99--------------[张三,李四,王五,赵六,田七,田七,田七,田七,java]</code></pre><h2 id="Stream-API练习"><a href="#Stream-API练习" class="headerlink" title="Stream API练习"></a>Stream API练习</h2><pre><code class="java">//交易员类public class Trader {    private String name;    private String city;    public Trader() {    }    public Trader(String name, String city) {        this.name = name;        this.city = city;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    @Override    public String toString() {        return &quot;Trader [name=&quot; + name + &quot;, city=&quot; + city + &quot;]&quot;;    }}</code></pre><pre><code class="java">//交易类public class Transaction {    private Trader trader;    private int year;    private int value;    public Transaction() {    }    public Transaction(Trader trader, int year, int value) {        this.trader = trader;        this.year = year;        this.value = value;    }    public Trader getTrader() {        return trader;    }    public void setTrader(Trader trader) {        this.trader = trader;    }    public int getYear() {        return year;    }    public void setYear(int year) {        this.year = year;    }    public int getValue() {        return value;    }    public void setValue(int value) {        this.value = value;    }    @Override    public String toString() {        return &quot;Transaction [trader=&quot; + trader + &quot;, year=&quot; + year + &quot;, value=&quot;                + value + &quot;]&quot;;    }}</code></pre><pre><code class="java">public class TestTransaction {    List&lt;Transaction&gt; transactions = null;    @Before    public void before(){        Trader raoul = new Trader(&quot;Raoul&quot;, &quot;Cambridge&quot;);        Trader mario = new Trader(&quot;Mario&quot;, &quot;Milan&quot;);        Trader alan = new Trader(&quot;Alan&quot;, &quot;Cambridge&quot;);        Trader brian = new Trader(&quot;Brian&quot;, &quot;Cambridge&quot;);        transactions = Arrays.asList(                new Transaction(brian, 2011, 300),                new Transaction(raoul, 2012, 1000),                new Transaction(raoul, 2011, 400),                new Transaction(mario, 2012, 710),                new Transaction(mario, 2012, 700),                new Transaction(alan, 2012, 950)        );    }    //1. 找出2011年发生的所有交易， 并按交易额排序（从低到高）    @Test    public void test1(){        transactions.stream().filter(transaction -&gt; transaction.getYear() == 2011)                .sorted(Comparator.comparingInt(Transaction::getValue))                //.sorted((v1,v2)-&gt;v2.getValue() - v1.getValue())   从高到低                .forEach(System.out::println);    }    //2. 交易员都在哪些不同的城市工作过？    @Test    public void test2(){        transactions.stream().map(transaction -&gt; transaction.getTrader().getCity())                .distinct().forEach(System.out::println);    }    //3. 查找所有来自剑桥的交易员，并按姓名排序    @Test    public void test3(){        transactions.stream().map(Transaction::getTrader).filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))                .sorted(Comparator.comparing(Trader::getName)).distinct()                .forEach(System.out::println);    }    //4. 返回所有交易员的姓名字符串，按字母顺序排序    @Test    public void test4(){        transactions.stream().map(transaction -&gt; transaction.getTrader().getName())                .sorted().forEach(System.out::println);        System.out.println(&quot;----------------&quot;);        String collect = transactions.stream().map(transaction -&gt; transaction.getTrader().getName())                .sorted().distinct().collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;));        System.out.println(collect);        System.out.println(&quot;----------------&quot;);        transactions.stream().map(transaction -&gt; transaction.getTrader().getName()).flatMap(TestTransaction::filterCharacter)                .sorted(String::compareToIgnoreCase).forEach(System.out::print);    }    public static Stream&lt;String&gt; filterCharacter(String str){        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for (Character ch : str.toCharArray()) {            list.add(ch.toString());        }        return list.stream();    }    //5. 有没有交易员是在米兰工作的？    @Test    public void test5(){        boolean milan = transactions.stream().anyMatch(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Milan&quot;));        System.out.println(milan);    }    //6. 打印生活在剑桥的交易员的所有交易额    @Test    public void test6(){        Integer cambridge = transactions.stream().filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))                .map(Transaction::getValue).reduce(0, Integer::sum);        Integer cambridge1 = transactions.stream().filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))                .collect(Collectors.summingInt(Transaction::getValue));        Integer cambridge2 = transactions.stream().filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))                .mapToInt(Transaction::getValue).sum();        System.out.println(cambridge);        System.out.println(cambridge1);        System.out.println(cambridge2);    }    //7. 所有交易中，最高的交易额是多少    @Test    public void test7(){        Optional&lt;Integer&gt; max = transactions.stream().map(Transaction::getValue).max(Integer::compare);        System.out.println(max.orElse(0));    }    //8. 找到交易额最小的交易    @Test    public void test8(){        Optional&lt;Transaction&gt; min = transactions.stream().min(Comparator.comparingInt(Transaction::getValue));        System.out.println(min.get());    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据过滤</title>
    <link href="undefined2019/12/10/%E5%89%8D%E7%AB%AF/JS/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/"/>
    <url>2019/12/10/%E5%89%8D%E7%AB%AF/JS/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h3 id="对象中包含子对象"><a href="#对象中包含子对象" class="headerlink" title="对象中包含子对象"></a>对象中包含子对象</h3><p>如果需要用子对象中的属性过滤，需要用forEach套filter，然后再filter过滤</p><pre><code class="js">// 声明中间变量，用于第一层filter过滤的深拷贝let newArr = []// 先将所有数据深拷贝给需要过滤的数据this.pzLeftData = JSON.parse(JSON.stringify(this.AllData))// 第一层过滤this.pzLeftData.forEach((value, index) =&gt; {    newArr[index] = value    // 将里层pzlist数组按照evidenceTypeCode过滤并声明一个新的数组复制给pzList    newArr[index].pzList = value.pzList.filter(item =&gt; item.evidenceTypeCode === &#39;2&#39;)})// 第二层过滤，讲里层数组个数为0的分类过滤掉this.pzLeftData = this.pzLeftData.filter(pzType =&gt; pzType.pzList.length &gt; 0)</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端发展史</title>
    <link href="undefined2019/12/09/%E5%89%8D%E7%AB%AF/JS/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <url>2019/12/09/%E5%89%8D%E7%AB%AF/JS/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="服务器渲染时代"><a href="#服务器渲染时代" class="headerlink" title="服务器渲染时代"></a>服务器渲染时代</h2><img src="/2019/12/09/%E5%89%8D%E7%AB%AF/JS/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E6%97%B6%E4%BB%A3.png" srcset="undefined" class="" title="服务器渲染时代"><h2 id="客户端渲染时代"><a href="#客户端渲染时代" class="headerlink" title="客户端渲染时代"></a>客户端渲染时代</h2><img src="/2019/12/09/%E5%89%8D%E7%AB%AF/JS/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%97%B6%E4%BB%A3.png" srcset="undefined" class="" title="客户端渲染时代"><h2 id="前端侵占移动端APP市场"><a href="#前端侵占移动端APP市场" class="headerlink" title="前端侵占移动端APP市场"></a>前端侵占移动端APP市场</h2><img src="/2019/12/09/%E5%89%8D%E7%AB%AF/JS/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/%E5%89%8D%E7%AB%AF%E4%BE%B5%E5%8D%A0%E7%A7%BB%E5%8A%A8%E7%AB%AFAPP%E5%B8%82%E5%9C%BA.png" srcset="undefined" class="" title="前端侵占移动端APP市场">]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="undefined2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>网络设备的机械特性 电器特性 功能特性 过程特性<br>数据通信的基础知识<br>    数字信号<br>    模拟信号<br>频分多路复用<br>时分多路复用</p><a id="more"></a><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层解决如何在连接各个计算机的<code>传输媒体</code>上传输<code>数据比特流</code>而不是指具体的传输媒体。<br>物理层的主要人数描述为：确定媒体的接口的一些特性，即<br>    - 机械特性：例接口形状，大小，引线数目<br>    - 电器特性：例规定电压范围（-5到+5v）<br>    - 功能特性：例规定-5V表示0，+5V表示1<br>    - 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤</p><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1.png" srcset="undefined" class="" title="数据通信"><p>如果两台电脑通过交换机传输就直接使用数字信号通信不用转换成模拟信号</p><p>通信的目的是传送消息<br>数据（data)————运动消息的实体。<br>信号（singnal）数据的电气的或电磁的表现。<br>“模拟信号”————代表消息的参数的取值是连续的。<br>“数字信号”————代表消息的参数的取值是离散的。<br>码元（code）————在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元<br>在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔的信号成为二进制码元。而这个间隔被成为码元长度。1码元可以携带nbit的信息量。</p><h3 id="信道的基本概念"><a href="#信道的基本概念" class="headerlink" title="信道的基本概念"></a>信道的基本概念</h3><p>信道一般表示向一个方向传送信息的媒体。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接受信息的信道。<br><strong>单项通信</strong>（单工通信）————只能有一个方向的通信而没有反向的交互。<br><strong>双向交替通信</strong>（半双工通信）————通信的双方都可以发送信息，但不能双方同时发送（当然也就布恩那个同时接收）。<br><strong>双向同时通信</strong>（全双工通信）————通信的双方可以同时发送和接收信息</p><h3 id="基带（baseband）信号和带通（band-pass）信号"><a href="#基带（baseband）信号和带通（band-pass）信号" class="headerlink" title="基带（baseband）信号和带通（band pass）信号"></a>基带（baseband）信号和带通（band pass）信号</h3><p><strong>基带信号</strong>（即基本频带信号）————来自信源的信号。向计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号<br><strong>带通信号</strong>————把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p><p>因此在传输距离较近时，计算机网络都采用<code>基带传输</code>方式由于近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用<code>基带传输</code>方式。如从计算机到监视器、打印机等外设的信号就是基带传输的。</p><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E4%BF%A1%E5%8F%B7.png" srcset="undefined" class="" title="信号"><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E5%9F%BA%E5%B8%A6%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7.png" srcset="undefined" class="" title="基带数字信号"><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E7%BC%96%E7%A0%81.png" srcset="undefined" class="" title="编码"><ol><li><p>曼彻斯特编码</p> <img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/mcst.png" srcset="undefined" class="" title="曼彻斯特编码"><p> 采用曼彻斯特编码，一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit但它能携带时钟信号，且可表示没有数据传输</p></li><li><p>差分曼彻斯特编码</p> <img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E5%B7%AE%E5%88%86%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.png" srcset="undefined" class="" title="差分曼彻斯特编码"><p> 差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性强于曼彻斯特编码</p></li></ol><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E7%BC%96%E7%A0%81%E4%BE%8B%E9%A2%98.png" srcset="undefined" class="" title="编码例题"><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E4%BF%A1%E9%81%93%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F.png" srcset="undefined" class="" title="信道极限容量"><h3 id="奈式准则"><a href="#奈式准则" class="headerlink" title="奈式准则"></a>奈式准则</h3><p>他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。<br>在任何信道中，码元传输的速度是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。<br>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</p><h3 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h3><p>香农（Shannon）用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。<br>信道的极限传输速率c可表达为<br>c = W log2^(1+S/N) b/s<br>W为信道的带宽（以Hz为单位）<br>S为信道内所传信号的平均功率<br>N为信道内部的高斯噪声功率</p><blockquote><p>香农公式表明：<br>    信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。<br>    若信道带宽W或信噪比S/N没有上限（当然实际信道不可能使这样的），则信道的极限信息传输速率c也就没有上限。<br>    实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</p></blockquote><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E9%80%9F%E5%BA%A6%E9%99%90%E5%88%B6.png" srcset="undefined" class="" title="速度限制"><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><h3 id="导向传输媒体"><a href="#导向传输媒体" class="headerlink" title="导向传输媒体"></a>导向传输媒体</h3><p>导向传输媒体中，电磁波沿着固体媒体传播<br>双绞线<br>    - 屏蔽双绞线STP<br>    - 五屏蔽双绞线UTP<br>同轴电缆<br>    - 50Ω同轴电缆用于数字传输，由于多用于基带传输，也叫基带同轴电缆；<br>    - 75Ω同轴电缆用于模拟传输，即宽带同轴电缆<br>光缆</p><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E7%94%B5%E7%BC%86.png" srcset="undefined" class="" title="电缆"><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E5%AE%9E%E9%99%85%E7%94%B5%E7%BC%86.png" srcset="undefined" class="" title="实际电缆"><h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><p>无线传输所使用的频段很广。<br>短波通信主要是靠电离层的反射，但短波信道的通信质量较差。</p><blockquote><p>微波在空间主要是直线传播。<br>  1.地面微波接力通信<br>  2.卫星通信</p></blockquote><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E9%A2%91%E8%B0%B1.png" srcset="undefined" class="" title="频谱"><h3 id="物理层设备-集线器"><a href="#物理层设备-集线器" class="headerlink" title="物理层设备-集线器"></a>物理层设备-集线器</h3><p>工作特点：它在网络中只起到信号放大和重发作用，其目的是扩大网络的传输范围，而<code>不具备</code>信号的定向传送能力<br>最大传输距离：100m<br>集线器是一个大的冲突域</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>复用(multiplexing)是通信技术中的基本概念。</p><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.png" srcset="undefined" class="" title="信道复用"><h3 id="频分复用-FDM-Frequency-Division-Multiplexing"><a href="#频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用 FDM (Frequency Division Multiplexing)"></a>频分复用 FDM (Frequency Division Multiplexing)</h3><ol><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ol><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" srcset="undefined" class="" title="频分复用"><h3 id="时分复用TDM（Time-Fivision-Multiplexing）"><a href="#时分复用TDM（Time-Fivision-Multiplexing）" class="headerlink" title="时分复用TDM（Time Fivision Multiplexing）"></a>时分复用TDM（Time Fivision Multiplexing）</h3><p><code>时分复用</code>则是将时间划分为一段段等长的<code>时分复用帧</code>（TDM帧）。每一个时分复用的用户再每一个TDM帧中占用固定序号的时隙。<br>每一个用户所占用的时隙时<code>周期性</code>地出现（其周期就是TDM帧的长度<code>对应的时间</code>）。<br>TDM信号也称为<code>等时</code>信号。<br>时分复用的所有用户是在不同的时间占用<code>同样的</code>频带宽度。</p><p>时分复用可能会造成线路资源的浪费<br>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p><h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>脉码调制OCM体制最初时为了在电话局之间的中继线上传送多路的电话。由于历史上的原因，PCM由两个互不兼容的过积标准，即北美的24路PCM（简称为T1）和欧洲的30路PCM（简称为E1）。我国采用的时欧洲的E1标准。</p><p>E1的速率时2.028Mb/s，而T1的速率时1.544Mb/s。<br>当需要由更高的数据率时，可采用复用的方法。</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><h3 id="xDSL（用数字技术对现有的模拟电话用户线进行改造）"><a href="#xDSL（用数字技术对现有的模拟电话用户线进行改造）" class="headerlink" title="xDSL（用数字技术对现有的模拟电话用户线进行改造）"></a>xDSL（用数字技术对现有的模拟电话用户线进行改造）</h3><p>标准模拟电话信号的频带被限制在300<del>3400Hz的范围内，但用户线本身实际可通过的信号频率仍然超过1MHz。<br>xDSL技术就把0</del>4kHz低端频谱留给传统电话使用，而把<code>原来没有被利用的高端频谱留给用户上网使用。</code></p><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/xDSL.png" srcset="undefined" class="" title="xDSL"><blockquote><p>xDSL 的几种类型<br>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线<br>HDSL (High speed DSL)：高速数字用户线<br>SDSL (Single-line DSL)：1 对线的数字用户线<br>VDSL (Very high speed DSL)：甚高速数字用户线<br>DSL ：ISDN 用户线。<br>RADSL (Rate-Adaptive DSL)：速率自适应  DSL，是 ADSL 的一个子集，可自动调节线路速率）.</p></blockquote><h3 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h3><h4 id="ADSL-的极限传输距离"><a href="#ADSL-的极限传输距离" class="headerlink" title="ADSL 的极限传输距离"></a>ADSL 的极限传输距离</h4><ol><li>ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系（用户线越细，信号传输时的衰减就越大），而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</li><li>例如，0.5 毫米线径的用户线，传输速率为 1.5 ~ 2.0 Mb/s 时可传送 5.5 公里，但当传输速率提高到 6.1 Mb/s 时，传输距离就缩短为 3.7 公里。</li><li>如果把用户线的线径减小到0.4毫米，那么在6.1 Mb/s的传输速率下就只能传送2.7公里</li></ol><h4 id="ADSL-的特点"><a href="#ADSL-的特点" class="headerlink" title="ADSL 的特点"></a>ADSL 的特点</h4><ul><li>上行和下行带宽做成不对称的。</li><li>上行指从用户到 ISP，而下行指从 ISP 到用户。</li><li>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</li><li>我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</li></ul><h3 id="DMT技术"><a href="#DMT技术" class="headerlink" title="DMT技术"></a>DMT技术</h3><p>DMT调制技术采用频分复用的方法，把40kHz以上一直到1.1MHz的高端频谱划分为许多的子信道，其中25个子信道用于上行信道，而249个子信道用于下行信道。<br>每个子信道占据4kHz带宽，并使用不同的载波（即不同的音调）进行数字调制。这种做法像防御在一堆用户线上使用许多小的调制解调器并行地传送数据。</p><img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/ADSL.png" srcset="undefined" class="" title="ADSL"><h3 id="光纤同轴混合网HFC-Hybrid-Fiber-Coax"><a href="#光纤同轴混合网HFC-Hybrid-Fiber-Coax" class="headerlink" title="光纤同轴混合网HFC (Hybrid Fiber Coax)"></a>光纤同轴混合网HFC (Hybrid Fiber Coax)</h3><ul><li>HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</li><li>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</li><li>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。而 HFC 网则需要对 CATV 网进行改造，  </li></ul><h4 id="HFC-的主要特点"><a href="#HFC-的主要特点" class="headerlink" title="HFC 的主要特点"></a>HFC 的主要特点</h4><ol><li>HFC网的主干线路采用光纤<ul><li>HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</li><li>在模拟光纤中采用光的振幅调制 AM，这比使用数字光纤更为经济。</li><li>模拟光纤从头端连接到光纤结点(fiber node)，即光分配结点 ODN (Optical Distribution Node)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</li></ul></li><li>HFC 网采用结点体系结构 <img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/HFS.png" srcset="undefined" class="" title="HFS"></li><li>HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能 <img src="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/HFS1.png" srcset="undefined" class="" title="HFS1"></li><li>每个家庭要安装一个用户接口盒<br> 用户接口盒 UIB (User Interface Box)要提供三种连接，即：<ul><li>使用同轴电缆连接到机顶盒(set-top box)，然后再连接到用户的电视机。</li><li>使用双绞线连接到用户的电话机。</li><li>使用电缆调制解调器连接到用户的计算机。</li></ul></li></ol><h4 id="HFC-网的最大优点"><a href="#HFC-网的最大优点" class="headerlink" title="HFC 网的最大优点"></a>HFC 网的最大优点</h4><ol><li>具有很宽的频带，并且能够利用已经有相当大的覆盖面的有线电视网。</li><li>要将现有的 450 MHz 单向传输的有线电视网络改造为 750 MHz 双向传输的 HFC 网（还要将所有的用户服务区互连起来而不是一个个 HFC 网的孤岛），也需要相当的资金和时间。</li><li>在电信政策方面也有一些需要协调解决的问题。</li></ol><h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><ul><li>FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。</li><li>光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。</li><li>光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li><li>光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锚点树</title>
    <link href="undefined2019/12/08/%E5%89%8D%E7%AB%AF/Vue/%E9%94%9A%E7%82%B9%E6%A0%91/"/>
    <url>2019/12/08/%E5%89%8D%E7%AB%AF/Vue/%E9%94%9A%E7%82%B9%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="锚点树"><a href="#锚点树" class="headerlink" title="锚点树"></a>锚点树</h2><p>通过右侧的滚轮滚动，激活左侧目录，同时点击左侧目录右侧滚动</p><p><code>锚点树代码</code></p><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;time-line&quot;&gt;    &lt;div v-for=&quot;(item,index) in array&quot;  :key=&quot;index&quot; class=&quot;time-item&quot; :id=&quot;&#39;timeline&#39; + index&quot; @click=&quot;scrolljump(item.fname)&quot;&gt;      &lt;!--点--&gt;      &lt;div class=&quot;time-item-point&quot;&gt;        &lt;div class=&quot;time-item-point-img&quot;  :class=&quot;active(item.fname)&quot;&gt;&lt;/div&gt;        &lt;div :class=&quot;index===array.length-1?&#39;&#39;:&#39;time-item-line&#39;&quot;&gt;&lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;time-item-point-word&quot; :class=&quot;cancel(item.fname)&quot;&gt;{{item.fname}}&lt;/div&gt;      &lt;!--线--&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &#39;mds&#39;,    props: {      array: Array,      activeSzxx: Array,      scrollHeight: Number    },    data() {      return {        activeIndex: &#39;&#39;,        arrayCancel: [],        scrollActive: []      }    },    created() {      this.copyArray(this.activeSzxx)    },    mounted() {      this.setScrollActive()    },    watch: {      activeSzxx: {        handler(newVal, oldVal) {          this.arrayCancel = []          this.copyArray(newVal)        },        deep: true      },      scrollHeight(newVal, oldVal) {        // 将变更的滚轮高度限和边界值比较        if (this.scrollActive.length === 0) {          this.setScrollActive()        }        for (var i = 0; i &lt; this.scrollActive.length; i++) {          if (newVal &gt;= this.scrollActive[i].height &amp;&amp; newVal &lt; this.scrollActive[i + 1].height) {            // 激活activeIndex            this.activeIndex = this.scrollActive[i].fname            break          }        }      }    },    computed: {      active() {        return function(fname) {          if (this.activeIndex === fname &amp;&amp; this.cancel(fname) !== &#39;cancel&#39;) {            return &#39;activetime&#39;          }        }      },      cancel() {        return function(fname) {          var count = 0          for (var i = 0; i &lt; this.arrayCancel.length; i++) {            if (this.arrayCancel[i] === fname) {              count++              break            }          }          if (count !== 1) {            return &#39;cancel&#39;          }        }      }    },    methods: {      setScrollActive() {        var j = 0        for (var i = 0; i &lt; this.arrayCancel.length; i++) {          while (j &lt; this.activeSzxx.length) {            if (this.arrayCancel[i] === this.activeSzxx[j].fname) {              let ele = document.getElementById(this.activeSzxx[j].id + &#39;pz&#39;)              let height = ele.offsetTop ? ele.offsetTop - 130 : 0              this.scrollActive.push({                &#39;height&#39;: height,                &#39;fname&#39;: this.arrayCancel[i]              })            } else {              break            }            j++          }        }      },      scrolljump(fname) {        this.activeIndex = fname        // 传给父组件类别        this.$root.$emit(&#39;fname&#39;, fname)      },      copyArray(arr) {        for (var i = 0; i &lt; arr.length; i++) {          if (this.arrayCancel.indexOf(arr[i].fname) === -1) {            this.arrayCancel.push(arr[i].fname)          }        }      }    }  }&lt;/script&gt;&lt;style scoped&gt;  .time-line{    position: relative;    cursor: pointer;    height: 571px;    background-color: #edf7f9;    border: 2px dashed #C9DAEB;    border-radius: 5px;    padding: 10px;    font-size: 14px;    overflow:scroll  }  .time-item{    position: relative;    width: 100%;    height: 40px;  }  .time-item-point{    position: absolute;    top: 8px;    width: 10px;    height: 40px;    display: inline-block;  }  .time-item-point-img{    position: absolute;    width: 6px;    height: 6px;    border-radius: 100px;    background-color: #C9DAEA;    opacity: 0.5;    display: inline-block;  }  .time-item-point-img.activetime{    left: -2px;    width: 10px;    height: 10px;    background-color: #1E9DFF;  }  .time-item-point-word{    width: 260px;    height: 40px;    text-align: left;    position: absolute;    left: 15px;    display: inline-block;  }  .time-item-point-word.cancel{    color: #C5D2E5;  }  .time-item-line{    position: absolute;    top: 12px;    height: 30px;    width: 3px;    border-right: 1px dashed #C9DAEA;  }&lt;/style&gt;</code></pre><p>props：中三个属性的含义：</p><ul><li>array：左侧目录数据</li><li>activeSzxx: 右侧所有数据，数据中需要包含左侧分类名称也就是fname</li><li>scrollHeight: 右侧滚动条距离顶部高度，也就是scrollTop</li></ul><p><code>弹窗代码</code></p><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;dialog fd-pic-pstil&quot; pzyl pzylwbpz&gt;    &lt;el-row style=&quot;flex:1&quot;&gt;      &lt;el-col :span=&quot;8&quot;&gt;        &lt;mds2 :array=&quot;PDF_SELECT&quot; :activeSzxx=&quot;postilList&quot; :scrollHeight2=&#39;scroll2&#39;&gt;&lt;/mds2&gt;      &lt;/el-col&gt;      &lt;el-col :span=&quot;16&quot; class=&quot;checkBox&quot;&gt;        &lt;el-checkbox v-model=&quot;checkAll&quot; @change=&quot;handleCheckAllChange&quot; class=&quot;select_all&quot;&gt;全选&lt;/el-checkbox&gt;        &lt;el-checkbox-group id=&quot;checkboxGroup&quot; v-model=&quot;checkedCities&quot; @change=&quot;handleCheckedCitiesChange&quot; class=&quot;right_group2&quot;&gt;        &lt;pzitem v-for=&quot;item in postilList&quot; :pzdata=&#39;item&#39; :key=&quot;item.id&quot; @del=&#39;del&#39; :id=&quot;item.id + &#39;pz&#39;&quot;&gt;          &lt;template slot=&quot;checkbox&quot;&gt;            &lt;el-checkbox :label=&quot;item.id&quot; class=&quot;checkboxwrap&quot;&gt;&lt;/el-checkbox&gt;          &lt;/template&gt;        &lt;/pzitem&gt;      &lt;/el-checkbox-group&gt;      &lt;/el-col&gt;    &lt;/el-row&gt;    &lt;el-row class=&quot;content_btn_box&quot;&gt;      &lt;el-button type=&quot;primary&quot; @click=&quot;confirmExport()&quot; class=&#39;fd-export-ppt&#39;&gt;导出ppt&lt;/el-button&gt;    &lt;/el-row&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import pzitem from &#39;./postilItem&#39;  import Bus from &#39;src/views/publicJs/bus.js&#39;  import api from &#39;src/api&#39;  import $ from &#39;jquery&#39;  import mds2 from &#39;./mds2.vue&#39;  import annotationType from &#39;../../../static/annotationType/annotationType&#39;  export default {    components: {      pzitem,      mds2    },    data() {      return {        postilList: [],        isShowTools: false,        checkedCities: [],        showSzms: true, // 展示示证模式工具栏        caseId: this.$route.params.caseId,        caseNumber: window.localStorage.getItem(&#39;caseNumber&#39;),        tysah: window.localStorage.getItem(&#39;tysah&#39;),        config: {          initialFrameWidth: null,          initialFrameHeight: window.innerHeight * 0.73        },        templateInfo: &#39;&#39;,        // jpgUrl: &#39;&#39;,        szxx: [],        szxxId: &#39;&#39;,        enable: true,        inputSize: {          minRows: &#39;2&#39;,          maxRows: &#39;2&#39;        },        showDialog: false, // 截图放大展示        imgUrl: &#39;&#39;,        imgWidth: &#39;400px&#39;,        imgTitle: &#39;&#39;,        szxxSelectedList: [], // 选中的示证id数组集合        szxxSelectedListTemp: [], // 用来全选功能        dcPPTShow: false, // 控制是否展示到处PPT样式        isIndeterminate: true,        checkAll: true, // 控制全选        showDcPPTStyle: false, // 控制是否展示导出样式        PDF_SELECT: [],        scroll2: 0      }    },    computed: {      zjmc() {        return this.$store.state.evidenceName      },      ym() {        return this.$store.state.evidencePage      },      wsbh() {        return this.$store.state.currentTreeId      }    },    mounted() {      this.$root.$on(&#39;fname2&#39;, (index) =&gt; {        for (var i = 0; i &lt; this.postilList.length; i++) {          var tz = this.postilList[i]          if (index === tz.fname) {            let ele = document.getElementById(tz.id + &#39;pz&#39;)            let height = ele.offsetTop - 30            $(&#39;#checkboxGroup&#39;).animate({scrollTop: height}, 300)            this.$store.commit(&#39;setCurrentClickTppz&#39;, this.postilList[i].id)            break          }        }      })      this.$root.$on(&#39;initData&#39;, () =&gt; {        this.initData()      })      document.querySelector(&#39;.right_group2&#39;).addEventListener(&#39;scroll&#39;, this.scrollMenu)    },    created() {      this.PDF_SELECT = annotationType.data.typeList      this.initData()      this.$root.$on(&#39;setZjmcYm&#39;, (zjmc, ym) =&gt; {        this.zjmc = zjmc        this.ym = ym      })      this.$root.$on(&#39;isShowSzms&#39;, (val) =&gt; {        this.showSzms = val      })      // this.$root.$on(&#39;addSzzj&#39;, (val) =&gt; {      //   this.addSzzj(val)      // })      this.$root.$on(&#39;exportPPTShow&#39;, () =&gt; {        this.showExportPPTShow()      })      this.$root.$on(&#39;exportPPTHidden&#39;, () =&gt; {        this.cancelExport()      })    },    methods: {      scrollMenu() {        this.scroll2 = Number(document.querySelector(&#39;.right_group2&#39;).scrollTop)        console.log(this.scroll2)      },      handleCheckedCitiesChange(value) {        this.checkAll = value.length === this.postilList.length      },      handleCheckAllChange(value) {        if (value) {          this.postilList.forEach(element =&gt; {            this.checkedCities.push(element.id)          })        } else {          this.checkedCities = []        }      },      del(id) {        this.deletePost(id)        let index = &#39;&#39;        this.postilList.forEach((element, i) =&gt; {          if (element.id === id) {            index = i          }        })        this.postilList.splice(index, 1)      },      showShotTools() {        this.isShowTools = true        $(&#39;#yjScreenShot&#39;).click()      },      closePages() {        this.$root.$emit(&#39;closeSzzj&#39;, false)        this.showSzms = false        this.$nextTick(() =&gt; {          this.$root.$emit(&#39;resetShot&#39;)        })        Bus.$emit(&#39;showtext&#39;, &#39;0&#39;)      },      deletePost(id) {        // 删除        var param = {          szxxId: id        }        api.post(&#39;/deleteSzms&#39;, param, {}).then(response =&gt; {          if (response.status === 204 | response.status === 200) {            if (response.data) {              this.$message({                message: &#39;删除成功&#39;,                type: &#39;success&#39;              })              // this.initData()            } else {              this.$message({                message: &#39;删除失败，请重新尝试或联系管理员&#39;,                type: &#39;warning&#39;              })            }          }        }, err =&gt; {          this.$message({            message: &#39;查询失败，请重新尝试或联系管理员&#39;,            type: &#39;warning&#39;          })          console.log(err)        })      },      changeName(arg, index) {        if (this.szxx[index].id) {          this.save(this.szxx[index])        }      },      showCapture(url, wsName) {        let img = new Image()        img.src = url        img.onload = () =&gt; {          let width = img.width &lt; 200 ? 200 : img.width          this.imgWidth = width + 30 + &#39;px&#39;          this.imgUrl = url          this.imgTitle = wsName          this.showDialog = true        }      },      showDialogF() {        this.showDialog = true      },      showEnlargeIcon(item) {        this.$set(item, &#39;enlargeIcon&#39;, true)      },      closeEnlargeIcon(item) {        this.$set(item, &#39;enlargeIcon&#39;, false)      },      initData() {        var param = {}        return api.get(&#39;/pz/pzyl/&#39; + this.caseId + &#39;/2&#39;, param, {}).then(response =&gt; {          if (response.status === 204 || response.status === 200) {            this.postilList = response.data            this.sort(this.postilList)            this.handleCheckAllChange(true)            this.initCheckBox()            this.postilList.forEach((item, index) =&gt; {              this.$set(item, &#39;enlargeIcon&#39;, false)            })          }        }, err =&gt; {          this.$message({            message: &#39;查询失败，请重新尝试或联系管理员&#39;,            type: &#39;warning&#39;          })          console.log(err)        })      },      sort(list) {        for (var i = 0; i &lt; list.length; i++) {          for (var j = 0; j &lt; this.PDF_SELECT.length; j++) {            if (list[i].fname === this.PDF_SELECT[j].fname) {              this.$set(list[i], &#39;fid&#39;, this.PDF_SELECT[j].fid)            }          }        }        list.sort(function (a, b) {          return Number(a.fid) &lt; Number(b.fid) ? -1 : 1        })        return list      },      save(item) {        var param = {}        Object.assign(param, item)        return api.post(&#39;/saveContent&#39;, param, {}).then(response =&gt; {          if (response.status === 204 | response.status === 200) {            if (this.szxxSelectedList.indexOf(response.data) === -1) {              this.szxxSelectedList.push(response.data)            }            if (this.szxxSelectedListTemp.indexOf(response.data) === -1) {              this.szxxSelectedListTemp.push(response.data)            }            this.$message({              message: &#39;保存成功&#39;,              type: &#39;success&#39;            })            return response.data          }        }, err =&gt; {          this.$message({            message: &#39;保存失败，请重新尝试或联系管理员&#39;,            type: &#39;warning&#39;          })          console.log(err)        })      },      /**       * 点击页码跳转对应的文书       */      toWsBybh(item) {        this.$root.$emit(&#39;wsbh&#39;, item.wsbh)        this.$root.$emit(&#39;changeTreeSelect&#39;, item.wsbh)        this.$store.commit(&#39;setEvidenceName&#39;, item.wsName.split(&#39;-&#39;)[0])        this.$store.commit(&#39;setEvidencePage&#39;, item.wsName.split(&#39;-&#39;)[1])      },      /**       * 显示编辑示证内容方法       */      editSznr(index) {        // this.szxx[index].showEditorSznr = true        this.$set(this.szxx[index], &#39;showEditorSznr&#39;, true)      },      /**       * 编辑示证内容失去焦点实时保存方法       */      pinkUpLoseFocus(index) {        // TODO保存示证内容        this.szxx[index].showEditorSznr = false        if (this.szxx[index].id) {          this.save(this.szxx[index])        }      },      /**       * 清空示证内容       */      clearSznr(index) {        this.szxx[index].sznr = &#39;&#39;      },      /**       * 截图鼠标松开，自动添加示证证据的方法       * @param {String} imagData 图片的base64码       */      addSzzj(pzData) {        // 增加示证证据        // this.szxx.forEach((item, index) =&gt; {        //   item.show = true        // })        let szxxItem = {}        // szxxItem.id = this.globel.util.newId()        szxxItem.ajbh = this.caseId // &#39;4F2B6816E90C454280DFAB61FA0857AE&#39; // this.caseId,        szxxItem.bmsah = this.caseNumber // &#39;修检起诉受[2014]52012300069号&#39; // this.caseNumber,        szxxItem.tysah = &#39;&#39; // this.tysah,        // szxxItem.szbt = `示证证据分类${this.szxx.length + 1}`        szxxItem.szbt = pzData.code        szxxItem.wsName = `${this.zjmc}-${this.ym}`        // szxxItem.ym = this.ym        szxxItem.pic = pzData.dataURL        szxxItem.sznr = pzData.text        szxxItem.wsbh = this.wsbh        szxxItem.showEditorSznr = true        this.szxx.push(szxxItem)        this.$nextTick(() =&gt; {          $(&#39;#szmsContent&#39;).scrollTop($(&#39;#szmsContent&#39;)[0].scrollHeight)          // $(&#39;#sznr&#39; + (this.szxx.length - 1)).focus() // 获取焦点        })        this.save(szxxItem).then(result =&gt; {          szxxItem.id = result        })      },      // 初始化选中数组      initCheckBox() {        this.szxx.forEach(element =&gt; {          this.szxxSelectedList.push(element.id)          this.szxxSelectedListTemp.push(element.id)        })      },      // 全选功能      // handleCheckAllChange(val) {      //   this.szxxSelectedList = val ? this.szxxSelectedListTemp : []      //   this.isIndeterminate = false      // },      // 展示导出PPT样式      showExportPPTShow() {        if (this.$store.state.isShotModal) {          this.$message({            message: &#39;请先取消截图状态&#39;,            type: &#39;warning&#39;          })          return        }        this.showDcPPTStyle = true        this.szxxSelectedList = this.szxxSelectedListTemp        this.isIndeterminate = true      },      cancelExport() {        this.showDcPPTStyle = false      },      // 导出选中的图片批注至PPT      confirmExport() {        if (this.checkedCities.length === 0) {          this.$message({            message: &#39;请至少选择一个图片批注&#39;,            type: &#39;warning&#39;          })          return        }        let uri = &#39;/rest/v4/exportPPT/&#39; + this.caseId + &#39;/&#39; + this.checkedCities        window.location.href = window.location.protocol + &#39;//&#39; + window.location.host + uri        this.showDcPPTStyle = false      }    }  }&lt;/script&gt;&lt;style lang=&#39;less&#39;&gt;  .fd-dialog-pic .el-dialog__body{    padding-bottom: 0;  }  .fd-pic-pstil{    padding-bottom: 79px;    position: relative;    overflow: visible !important;  }  div[pzylwbpz] {    display: flex;    max-height: 652px;    overflow: hidden;    .select_all {        margin-left: 2.5%;        padding-left: 5px;        .el-checkbox__label {          font-weight: bold;        }      }    .fd-left {      width: 30%;      height: 100%;    }    .el-checkbox__input.is-checked .el-checkbox__inner {        background: #00a1a8;        border-color: #00a1a8;      }      .right_group2 {        font-size: 14px;        max-height: 549px;        overflow: auto;        padding: 0 0 10px 0;      }      .checkboxwrap {        position: absolute;        left: 5px;        top: -2px;        .el-checkbox__label {          display: none;        }      }      .content_btn_box {        position: absolute;        bottom: 0px;        right: -15px;        padding:15px 15px 15px 0;        width: calc(~&quot;100% + 30px&quot;);        height: 64px;        text-align: right;        background: #edf1fa;        z-index:10;        border-radius: 5px;        .fd-export-ppt{          background: url(&#39;../../assets/sidebar/4_05.png&#39;) no-repeat center;          background-size: 100% 100%;          color: #fff;        }      }      .right {      width: 70%;      height: 100%;      .el-checkbox__input.is-checked .el-checkbox__inner {        background: #00a1a8;        border-color: #00a1a8;      }      .right_group2 {        font-size: 14px;        max-height: 549px;        overflow: auto;        padding: 0 0 10px 0;      }      .checkboxwrap {        position: absolute;        left: 5px;        top: -2px;        .el-checkbox__label {          display: none;        }      }    }  }&lt;/style&gt;</code></pre><h3 id="左侧联动右侧"><a href="#左侧联动右侧" class="headerlink" title="左侧联动右侧"></a>左侧联动右侧</h3><p>锚点树左侧目录点击后，右侧监听并进行滚动，下发时监听滚动的代码</p><pre><code class="js">mounted() {    this.$root.$on(&#39;fname2&#39;, (index) =&gt; {    for (var i = 0; i &lt; this.postilList.length; i++) {        var tz = this.postilList[i]        if (index === tz.fname) {        let ele = document.getElementById(tz.id + &#39;pz&#39;)        let height = ele.offsetTop - 30        $(&#39;#checkboxGroup&#39;).animate({scrollTop: height}, 300)        this.$store.commit(&#39;setCurrentClickTppz&#39;, this.postilList[i].id)        break        }    }    })}</code></pre><h3 id="右侧联动左侧"><a href="#右侧联动左侧" class="headerlink" title="右侧联动左侧"></a>右侧联动左侧</h3><p>通过class获取右侧滚动区域，给它加上滚动监听时间scroll和触发的方法，将滚动的高度赋值并回传给左侧锚点树</p><pre><code class="js">&lt;mds2 :array=&quot;PDF_SELECT&quot; :activeSzxx=&quot;postilList&quot; :scrollHeight2=&#39;scroll2&#39;&gt;&lt;/mds2&gt;document.querySelector(&#39;.right_group2&#39;).addEventListener(&#39;scroll&#39;, this.scrollMenu)scrollMenu() {    this.scroll2 = Number(document.querySelector(&#39;.right_group2&#39;).scrollTop)    console.log(this.scroll2)}</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
      <category>锚点树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Vue</tag>
      
      <tag>锚点树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="undefined2019/12/02/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>2019/12/02/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li>Lambda 表达式</li><li>函数式接口</li><li>方法引用与构造器引用</li><li>Stream API</li><li>接口中的默认方法与静态方法</li><li>新时间日期 API</li><li>其他新特性</li></ol><h2 id="Java-8新特性简介"><a href="#Java-8新特性简介" class="headerlink" title="Java 8新特性简介"></a>Java 8新特性简介</h2><ol><li>速度更快</li><li>代码更少（增加了新的语法 Lambda 表达式）</li><li>强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li><li>其中最为核心的为 Lambda 表达式与Stream API</li></ol><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ol><li><p>Lambda表达式的基础语法：Java8中引入了一个新的操作符“-&gt;”该操作符成为箭头操作符或Lambda操作符<br> 箭头操作符将Lambda表达式拆分成两部分：<br> 左侧：Lambda表达式的参数列表<br> 右侧：Lambda表达式中所需执行的功能，即Lambda体</p><ul><li><p>语法格式一：无参数，无返回值<br>  <code>()-&gt;System.out.println(&quot;hello Lambda!&quot;);</code></p></li><li><p>语法格式二：有一个参数，并且无返回值</p></li><li><p>语法格式三：若只有一个参数，小括号可以省略不写</p></li><li><p>语法格式四：又两个以上的参数，并且有多条语句</p></li><li><p>语法格式五：若Lambda体中只有一条语句，return和大括号都可以省略不写</p></li><li><p>语法格式六：Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</p><pre><code class="java">@Testpublic void test1(){  int num = 0;//jdk1.7前，必须是final,现在默认加上了，可以省略  Runnable runnable = new Runnable() {      @Override      public void run() {          System.out.println(&quot;Hello world&quot; + num);      }  };  runnable.run();  System.out.println(&quot;-------------&quot;);  Runnable runnable1 = () -&gt; System.out.println(&quot;Hello World!&quot; + num);  runnable1.run();}</code></pre></li></ul></li><li><p>Lambda表达式需要“函数式接口”的支持<br> 函数式接口:接口中只有一个抽象方法的接口，称为函数式接口。可以使用朱姐@FunctionalInterface修饰<br> 可以检查是否是函数式接口</p></li></ol><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>什么是函数式接口？</p><ol><li>只包含一个抽象方法的接口，称为函数式接口。</li><li>你可以通过 Lambda 表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li><li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li></ol><p>作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。</p><h2 id="Java内置四大核心函数式接口"><a href="#Java内置四大核心函数式接口" class="headerlink" title="Java内置四大核心函数式接口"></a>Java内置四大核心函数式接口</h2><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer&lt;T&gt;消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作，包含方法：void accept(T t)</td></tr><tr><td>Supplier&lt;T&gt;供给型接口</td><td>无</td><td>T</td><td>返回类型为T的对象，包含方法：T get();</td></tr><tr><td>Function&lt;T, R&gt;函数型接口</td><td>T</td><td>R</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t);</td></tr><tr><td>Predicate&lt;T&gt;断定型接口</td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法boolean test(T t);</td></tr></tbody></table><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用：若Lambda体中的内容有方法已经实现了，我们可以使用“方法引用”<br>可以理解为方法引用时Lambda表达式的另外一种表现形式</p><p>主要有三种语法格式：</p><ul><li><p>对象::实例方法名</p><pre><code class="java">  //对象::实例方法名  @Test  public void test1(){      Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);      PrintStream ps1 = System.out;      Consumer&lt;String&gt; consumer1 = (x) -&gt; ps1.println(x);      PrintStream ps = System.out;      Consumer&lt;String&gt; consumer2 = ps::println;      Consumer&lt;String&gt; consumer3 = System.out::println;      consumer3.accept(&quot;aaaasdc&quot;);  }</code></pre></li><li><p>类::静态方法名</p><pre><code class="java">  @Test  public void test3(){      Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);      Comparator&lt;Integer&gt; com1 = Integer::compare;  }</code></pre></li><li><p>类::实例方法名</p><pre><code class="java">  @Test  public void test4(){      BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);      BiPredicate&lt;String, String&gt; bp1 = String::equals;  }</code></pre></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的函数列表和返回值类型保持一致!</li><li>若Lambda参数列表中的第一参数是实例方法的调用者，而第二个参数是实例方法的参数时，可以使用ClassName::method</li></ol><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式：ClassName::new</p><pre><code class="java">@Testpublic void test5(){    Supplier&lt;Employee&gt; supplier = () -&gt; new Employee();    Supplier&lt;Employee&gt; supplier1 = Employee::new;    Employee employee = supplier1.get();    System.out.println(employee);    Function&lt;String, Employee&gt; function = (x) -&gt; new Employee(x);    Function&lt;String,Employee&gt; function1 = Employee::new;    Employee employee1 = function1.apply(&quot;张三&quot;);    System.out.println(employee1);}结果：Employee{name=&#39;null&#39;, age=0, salary=0.0}Employee{name=&#39;张三&#39;, age=0, salary=0.0}</code></pre><p>注意：需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表保持一致！</p><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>Type::new</p><pre><code class="java">@Testpublic void test6(){    Function&lt;Integer, String[]&gt; function = (x) -&gt; new String[x];    String[] apply = function.apply(10);    System.out.println(apply.length);    Function&lt;Integer, String[]&gt; function1 = String[]::new;    String[] strings = function1.apply(20);    System.out.println(strings.length);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java8新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络性能</title>
    <link href="undefined2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
    <url>2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/%E6%80%A7%E8%83%BD.png" srcset="undefined" class="" title="性能 [性能]"><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>连接在计算机网络上的<strong>主机</strong>在数字信道上传送<strong>数据位数</strong>的速率，也成为<strong>data rate或bit rate</strong><br>单位是b/s,kb/s,Mb/s,Gb/s</p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>数据通信领域中，数组<strong>信道</strong>所能传送的最高数据率<br>单位是b/s,kb/s,Mb/s,Gb/s</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>在单位时间内通过某个网络的数据量；<br>单位是b/s,kb/s,Mb/s,Gb/s</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/%E6%97%B6%E5%BB%B6.png" srcset="undefined" class="" title="时延 [时延]"><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF.png" srcset="undefined" class="" title="时延带宽积 [时延带宽积]"><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT（Round-Trip Time）<br>从发送方发送数据开始，到发送方收到接受方确认<br>使用 <code>ping 网址</code> 测试</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ol><li>信道利用率：有数据通过时间/（有+无）数据通过时间</li><li>网络利用率：信道利用率甲醛平均值<img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/%E5%88%A9%E7%94%A8%E7%8E%87.png" srcset="undefined" class="" title="利用率 [利用率]"></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSI</title>
    <link href="undefined2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/"/>
    <url>2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/</url>
    
    <content type="html"><![CDATA[<h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><ul><li>应用层 所有能产生网络流量的程序</li><li>表示层 在传输之前是否进行加密或压缩处理 二进制 ASCII（编码和解码一致才不会乱码）</li><li>会话层 查木马 neststat -n查看所有会话，netstat -nb查看会话是由谁建立的</li><li>传输层 可靠传输（发送后需要确认） 流量控制 不可靠传输（发送数据包，不管结果，如果丢包，再次请求）</li><li>网络层 负责选择最佳路径 规划IP地址</li><li>数据链路层 帧的开始和结束 透明传输 差错校验</li><li>物理层 接口标准 电器标准 如何在物理链路上传输更快的速度</li></ul><h2 id="网络排错指导"><a href="#网络排错指导" class="headerlink" title="网络排错指导"></a>网络排错指导</h2><ol><li>物理层故障<br> 查看连接状态，查看发送和接受的数据包 <img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%E5%8C%85.png" srcset="undefined" class="" title="发送和接受数据包"></li><li>数据链路层故障<br> MAC地址冲突，ADSL欠费，网速没办法协商，计算机连接到错误的VLAN <img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/%E7%BD%91%E9%80%9F%E5%8D%8F%E5%95%86.png" srcset="undefined" class="" title="网速协商"></li><li>网络层故障<br> 配置错误的IP地址，子网掩码，配置错误的网关，路由器没有配置到达目标网络的路由</li><li>应用层故障<br> 应用程序配置错误</li></ol><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><ol><li>物理层安全<br> 把不用的网线拔掉或者把这个口通过命令shut down</li><li>数据链路层安全<br> ADSL，账户密码，VLAN交换机端口绑定MAC地址</li><li>网络层安全<br> 在路由器上使用ACL控制数据包流量，网络防火墙</li><li>应用层安全<br> 开发的应用程序没有漏洞</li></ol><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/TCP%E5%92%8CIP.png" srcset="undefined" class="" title="TCP和IP"><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B.png" srcset="undefined" class="" title="封装过程"><p>FCS校验值，用来校验MAC地址和IP地址的。<br>例如：发个快递，快递封皮写里面有1个本2支笔，打开发现匹配，就收下，否则就拒收。FCS就是起这个作用的</p><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/%E6%95%B0%E6%8D%AE%E5%8C%85.png" srcset="undefined" class="" title="数据包"><p>计算机在接受到数据帧后，需要去掉为了传输而添加的附加信息，这成为解封装，是上述封装操作的逆向过程。</p><img src="/2019/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI/%E8%A7%A3%E5%B0%81%E8%A3%85.png" srcset="undefined" class="" title="解封装">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML5概述</title>
    <link href="undefined2019/11/30/%E5%89%8D%E7%AB%AF/HTML/HTML5%E6%A6%82%E8%BF%B0/"/>
    <url>2019/11/30/%E5%89%8D%E7%AB%AF/HTML/HTML5%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h2><ol><li>用于绘画的canvas标签</li><li>用于媒介回访放的video和audio元素</li><li>对本地离线存储的更好支持</li><li>新的特殊内容元素<br> 如：article、footer、header、nav、section</li><li>新的表单控件<br> 如：calendar、date、time、email、url、search</li><li>浏览器的支持<br> Safai、Chrome、Firefox以及Opera包括IE9基本支持了HTML5</li></ol><h2 id="HTML基础讲解"><a href="#HTML基础讲解" class="headerlink" title="HTML基础讲解"></a>HTML基础讲解</h2><ol><li>声明&lt;!DOCTYPE&gt;<br> HTML也有多个不同的版本，只有完全明白页面中只用的确切HTML版本，浏览器才能完全正确地显示出HTML页面。这就是&lt;!DOCTYPE&gt;的用处</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用jQuery实现Ajax</title>
    <link href="undefined2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/%E4%BD%BF%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0Ajax/"/>
    <url>2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/%E4%BD%BF%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0Ajax/</url>
    
    <content type="html"><![CDATA[<h2 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2><p>jQuery对Ajax操作进行了封装，在jQuery中最底层的方法时$.ajax(),第二层使load(),$.get()和$.post(),第三层使$.getScript()和$.getJSON()</p><ol><li><p>什么是Ajax？<br>不用刷新页面，但可以和服务器进行通信的方式，使用Ajax的主要方式时XMLHttpRequest对象</p></li><li><p>使用XMLHttpRequest对象实现Ajax【了解】</p></li><li><p>Ajax传输数据的三种方式<br> XML：笨重，解析困难，但XML是通用的数据交换格式。<br> HTML：不需要解析可以直接放到文档中，若仅更新一部分区域，但传输的数据不是很方便，且HTML代码需要拼装完成。<br> JSON：小巧，有面向对象的特征，且有很多第三方的jar包可以把Java对象或集合转为JSON字符串。</p></li><li><p>使用jQuery完成Ajax操作<br> 1). load方法：可以用于HTML文档的元素更新，把结果直接加为对应节点的子元素，通常而言，load方法加载后的数据时一个HTML片段。</p><p> var $obj = …<br> var url = …<br> var args = {key:value…};<br> $obj.load(url,args);</p><p> 2). $.get,$.post, $getJSON:更加灵活，除去使用load方法的情况，大部分时候都使用这3个方法。</p><pre><code> 1. 基本的使用 url:Ajax请求的目标URL args：传递的参数：JSON类型 data：Ajax响应成功后的数据，可能是XML，HTML，JSON $.get(url,args,function(data){}) 2. 请求JSON数据 $.get(url,args,function(data){},&quot;JSON&quot;) $.post(url,args,function(data){},&quot;JSON&quot;) $.getJSON(url,args,function(data){})</code></pre></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><pre><code>```js&lt;script src=&quot;../jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;$(function () {            $(&quot;a&quot;).click(function () {                var url = this.href + &quot; h2, a&quot;;                $(&quot;#details&quot;).load(url);                //任何一个html节点都可以使用load方法来加载Ajax，结果将直接插入到html节点中。                return false;            })        })```</code></pre><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><pre><code>```js$(function () {            $(&quot;a&quot;).click(function () {                var url = this.href;                var args = {&quot;time&quot;: new Date()};                //url:                //args:JSON格式                //function：回调函数，当响应结束时，回调函数被触发，响应结果在data中。                $.get(url,args,function (data) {                    var name = $(data).find(&quot;name&quot;).text();                    var email = $(data).find(&quot;email&quot;).text();                    var website = $(data).find(&quot;website&quot;).text();                    $(&quot;#details&quot;).empty()                        .append(&quot;&lt;h2&gt;&lt;a href=&#39;mailto:&quot; + email + &quot;&#39;&gt;&quot; + name + &quot;&lt;/a&gt;&lt;/h2&gt;&quot;)                        .append(&quot;&lt;a href=&#39;&quot; + website + &quot;&#39;&gt;&quot; + website + &quot;&lt;/a&gt;&quot;);                });                return false;            })        })```</code></pre><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><pre><code>```js$(function () {            $(&quot;a&quot;).click(function () {                var url = this.href;                var args = {&quot;time&quot;: new Date()};                //url:                //args:JSON格式                //function：回调函数，当响应结束时，回调函数被触发，响应结果在data中。                $.getJSON(url,args,function (data) {                    var name = data.person.name;                    var email = data.person.email;                    var website = data.person.website;                    $(&quot;#details&quot;).empty()                        .append(&quot;&lt;h2&gt;&lt;a href=&#39;mailto:&quot; + email + &quot;&#39;&gt;&quot; + name + &quot;&lt;/a&gt;&lt;/h2&gt;&quot;)                        .append(&quot;&lt;a href=&#39;&quot; + website + &quot;&#39;&gt;&quot; + website + &quot;&lt;/a&gt;&quot;);                });                return false;            })        })```</code></pre><h3 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h3><pre><code>```js&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;../jquery-3.4.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(function () {            $(&quot;a&quot;).click(function () {                //使用load方法处理Ajax                var url = this.href;                var args = {&quot;time&quot;: new Date()};                $(&quot;#content&quot;).load(url, args);                return false;            })        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;helloAjax.txt&quot;&gt;HelloAjax&lt;/a&gt;    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;```</code></pre>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax_数据格式</title>
    <link href="undefined2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/Ajax-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"/>
    <url>2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/Ajax-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="数据格式提要"><a href="#数据格式提要" class="headerlink" title="数据格式提要"></a>数据格式提要</h2><ol><li>在服务器端AJAX是一门与语言无关的技术。再业务逻辑层使用何种服务器端语言都可以。</li><li>从服务器端接受数据的时候，那些数据必须以浏览器能够理解的格式来发送。服务器端的编程语言只能以如下3中格式返回数据：<ul><li>XML</li><li>JSON</li><li>HTML</li></ul></li></ol><h2 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h2><ol><li>HTML由一些普通文本组成。如果服务器通过XMLHttpRequest发送HTML，文本将存储在responseText属性中。</li><li>不必从responseText属性中读取数据。它已经是希望的格式，可以直接将他插入到页面中。</li><li>插入HTML代码最简单的方法是更新这个元素的innerHTML属性</li></ol><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function () {            var aNodes = document.getElementsByTagName(&quot;a&quot;);            for (var i = 0; i &lt; aNodes.length; i++) {                aNodes[i].onclick = function () {                    var  request = new XMLHttpRequest();                    var method = &quot;GET&quot;;                    var url = this.href;                    request.open(method, url);                    request.send(null);                    request.onreadystatechange = function () {                        if (request.readyState == 4) {                            if (request.status == 200 || request.status == 304) {                                document.getElementById(&quot;details&quot;).innerHTML = request.responseText;                            }                        }                    }                    return false;                }            }        }    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;people&lt;/h1&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=&quot;files/andy.html&quot;&gt; Andy&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;files/richard.html&quot;&gt; Richard&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;files/jeremy.html&quot;&gt; Jeremy&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div id=&quot;details&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>从服务器端发送的HTML代码在浏览器端不需要用JavaScript进行解析。</li><li>HTML的可读性好。</li><li>HTML代码块与innerHTML属性搭配，效率高</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>若需要通过AJAX更新一篇文档的多个部分，HTML不合适</li><li>innerHTML并非DOM标准</li></ul><h2 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h2><pre><code class="java">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function () {            var aNodes = document.getElementsByTagName(&quot;a&quot;);            for (var i = 0; i &lt; aNodes.length; i++) {                aNodes[i].onclick = function () {                    var  request = new XMLHttpRequest();                    var method = &quot;GET&quot;;                    var url = this.href;                    request.open(method, url);                    request.send(null);                    request.onreadystatechange = function () {                        if (request.readyState === 4) {                            if (request.status === 200 || request.status === 304) {                                //1.结果为XML格式，所有需要使用responseXML来获取                                var result = request.responseXML;                                //2. 结果不能直接使用，必须先创建对应的节点，再把节点加入到#details中                                //目标格式为：                                /*                                 *&lt;h2&gt;Andy&lt;/h2&gt;                                 *&lt;a href=&quot;www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;                                 */                                var name = result.getElementsByTagName(&quot;name&quot;)[0].firstChild.nodeValue;                                var website = result.getElementsByTagName(&quot;website&quot;)[0].firstChild.nodeValue;                                var email = result.getElementsByTagName(&quot;email&quot;)[0].firstChild.nodeValue;                                // alert(name);                                // alert(website);                                // alert(email);                                var aNode = document.createElement(&quot;a&quot;);                                aNode.appendChild(document.createTextNode(name));                                aNode.href = &quot;mailto:&quot; + email;                                var h2Node = document.createElement(&quot;h2&quot;);                                h2Node.appendChild(aNode);                                var aNode1 = document.createElement(&quot;a&quot;);                                aNode.appendChild(document.createTextNode(website));                                aNode.href = website;                                var detailsNode = document.getElementById(&quot;details&quot;);                                detailsNode.innerHTML = &quot;&quot;;                                detailsNode.appendChild(aNode);                                detailsNode.appendChild(aNode1);                            }                        }                    }                    return false;                }            }        }    &lt;/script&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;people&lt;/h1&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=&quot;files/andy.xml&quot;&gt; Andy&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;files/richard.xml&quot;&gt; Richard&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;files/jeremy.xml&quot;&gt; Jeremy&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div id=&quot;details&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>XML是一种通用的数据格式</li><li>不必把数据强加到已定义好的格式中，而是要为数据自定义合适的标记。</li><li>李彤DOM可以完全掌控文档。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果文档来自于服务器，就必须得包含文档含有正确的首部信息。若文档类型不正确，那么responseXML的值将是空的。</li><li>当浏览器接收到长的XML文件后，DOM解析可能会很复杂</li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ol><li>JSON（javaScript Object Notation）一种简单的数据格式，比xml更轻巧。JSON是JavaScript原生格式，这意味着在JavaScript中处理JSON数据不需要任何特殊的API或工具包。</li><li>JSON的规则很简单：对象是一个无需的“‘名称/值’ 对”集合。一个对象以“{”（左括号）开始，“}”（右括号） 结束。每个名称后跟一个“：”冒号；“‘名称/值’ 对”照顾华北是固体不过“，”都好分隔。</li></ol><h4 id="JSON示例"><a href="#JSON示例" class="headerlink" title="JSON示例"></a>JSON示例</h4><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var jsonObject = {            &quot;name&quot;: &quot;matthew&quot;,            &quot;age&quot;: 12,            &quot;address&quot;:{&quot;city&quot;:&quot;上海&quot;, &quot;school&quot;: &quot;北京大学&quot;},            &quot;teaching&quot;:function () {                alert(&quot;Java EE,spring.....&quot;);            }        };        alert(jsonObject.name);        alert(jsonObject.address.city);        jsonObject.teaching();    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>JSON用冒号（而不是等号）来复制，每一条赋值语句用逗号隔开，整个对象用大括号封装起来，可用大括号分级潜逃数据。<br>对象描述中存储的数据可以是字符串，数字或者布尔值，对象描述也可存储函数，那就是对象的方法。</p><h3 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h3><ol><li>JSON只是一种文本字符串，他被存储在responseText属性中</li><li>为了读取存储在responseText属性中的JSON数据，需要根据JavaScript的eval语句。<font color=blue>函数eval会把一个字符串当作它的参数，然后这个字符串会被当做JavaScript代码来执行。因为JSON的字符串就是由JavaScript代码构成的，所以它本身是可执行的</font></li></ol><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol><li>作为一种数据传输格式，JSON与XML很相似，但是它更加灵巧</li><li>JSON不需要从服务器端发送含有特定内容类型的首部信息</li></ol><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol><li>语法过于严谨</li><li>代码不易读</li><li>eval函数存在风险</li></ol>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用XMLHttpRequest实现Ajax</title>
    <link href="undefined2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/%E4%BD%BF%E7%94%A8XMLHttpRequest%E5%AE%9E%E7%8E%B0Ajax/"/>
    <url>2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/%E4%BD%BF%E7%94%A8XMLHttpRequest%E5%AE%9E%E7%8E%B0Ajax/</url>
    
    <content type="html"><![CDATA[<h2 id="XMLHttpRequest的概述"><a href="#XMLHttpRequest的概述" class="headerlink" title="XMLHttpRequest的概述"></a>XMLHttpRequest的概述</h2><ol><li>XMLHttpRequest最早是在IE5中以ActiveX组件的形式实现的。非W3C标准。</li><li>创建XMLHttpRequest对象<font color=blue>（由于非标准所有实现方法不统一）</font><ul><li>Internet Explor把XMLHttpRequest实现为一个ActiveX对象</li><li>其他浏览器（Firefox、Safari、Opera。。。）把它实现为一个本地的JavaScript</li><li><font color=blue>XMLHttpRequest在不同浏览器上的实现是兼容的。</font>所有可以用同样的方式访问XMLHttpRequest实例的属性和方法，而不论这个实例创建的方法是什么。</li></ul></li></ol><h2 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h2><p>为了每次下Ajax的时候都节省一点时间，可以把对象检查的内容打包成一个可服用的函数；</p><pre><code class="js">function getHTTPObject(){    var xhr = false;    if(window.XMLHttpRequest){        xhr = new XMLHttpRequest();    } else if(window.ActiveXObject){        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    }    return xhr;}</code></pre><p>说明：对weindow.XMLHttpRequest的调用会返回一个对象或null，if语句会把调用返回的结果看作是true或false<font color=blue>（如果返回对象则为true，返回null则为false）。如果XMLHttpRequest对象存在，则把xhr的值设为对象的新实例。如果不存在，就去驾车ActiveObject的实例是否存在，如果答案是肯定的，则把微软XMLHTTP的新实例付给xhr</p><h2 id="XMLHttpRequest的方法"><a href="#XMLHttpRequest的方法" class="headerlink" title="XMLHttpRequest的方法"></a>XMLHttpRequest的方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>abort()</td><td>停止当前请求</td></tr><tr><td>getAllResponseHeaders()</td><td>把HTTP请求的所有响应首部作为键/值对返回</td></tr><tr><td>getResponseHeader(“header”)</td><td>返回指定首部的串值</td></tr><tr><td>open(“method”,”url”)</td><td>建立对服务器的调用，Method参数可以是GET、POST或PUT、url参数额可以是相对URL或绝对URL</td></tr><tr><td>send(content)</td><td>向服务器发送请求</td></tr><tr><td>setRequestHeader(“header”,”value”)</td><td>把指定首部设置为所提供的值。在设置任何首部之前必须先调用open（）</td></tr></tbody></table><h2 id="XMLHttpRequest的属性"><a href="#XMLHttpRequest的属性" class="headerlink" title="XMLHttpRequest的属性"></a>XMLHttpRequest的属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>每个状态改变是都会触发这个事件处理器，通常会调用一个javaScript函数</td></tr><tr><td>readyState</td><td>请求的状态，由5个可取值，0：未初始化、1：正在加载、2：已经加载、3：交互中、4：完成</td></tr><tr><td>responseText</td><td>服务器的响应，表示为一个串</td></tr><tr><td>responseXML</td><td>服务器的响应，表示为XML，这个对象可以解析为DOM对象</td></tr><tr><td>status</td><td>服务器的HTTP状态码（200对应OK，404对应NotFound、等）</td></tr><tr><td>statusText</td><td>HTTP状态码的相应文本（OK或NotFound等）</td></tr></tbody></table><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><ol><li><p>利用XMLHttpRequest实例与服务器进行通信包含以下3个关键部分：</p><ul><li>onreadystatechange事件处理函数</li><li>open方法</li><li>send方法</li></ul></li><li><p>oreadystatechange：</p><ul><li>该事件处理函数由服务器触发，而不是用户</li><li>在Ajax执行过程中，服务器会通知客户端当前的同学的状态，这依靠跟新XMLHttpRequest对象的readyState来实现。改变readyState属性是服务器对客户端连接操作的一种方式。每次readyState属性的改变都会触发readystatechange事件</li></ul></li><li><p>open（method，url，asynch）</p><ul><li>XMLHttpRequest对象的open方法<font color=blue>允许程序员用一个Ajax调用向服务器发送请求。</font></li><li>method：请求类型，类似“GET”或“POST”的字符串。若只想从服务器检索一个文件，而不需要发送任何数据，使用GET（可以在GET请求里通过附加在URL上的擦汗寻字符串来发送数据，不过数据大小限制为2000个字符）。若需要向服务器发送数据，用POST。</li><li>在某些情况下，有些浏览器会把多个XMLHttpRequest请求的结果缓存在同一个URL。如果对每个请求的响应不同，就会带来不好的结果。<font color=blue>在此将时间戳追加到URL的最后，就能确保URL的唯一性，从而避免浏览器缓存结果。</font></li><li>url：路径字符串，指向你所请求的服务器上的那个文件，可以是绝对路径或相对路径。</li><li>asynch：表示请求是否要异步传输，默认值为true，指定true，在读取后面的脚本之前，不需要等服务器的的响应。指定false当脚本处理过程经过这点时，会停下来，一直等到Ajax请求执行完毕后再继续执行。<br><img src="https://img-blog.csdnimg.cn/20190701155453329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="&lt;/font&gt;"></li></ul></li><li><p>send（data）</p><ul><li><p>open方法定义了Ajax请求的一些细节，<font color=blue>send方法可为已经待命的请求发送指令</font></p></li><li><p>data：将要传送给服务器的字符串；</p></li><li><p><font color=blue>若选用的时GET请求，则不会发送任何数据，给send方法传递努力了即可：request.send(null);</font></p></li><li><p>当向send（）方法提供参数时，要确保open（）中指定的方法时POST，如果没有数据作为请求体的一部分发送，则使用null</p></li><li><p>完整的Ajax的GET请求示例：</p><pre><code class="js">var request = getHttpObject();if(request){  request.onreadystatechange = doSomeThing;  request.open(&quot;GET&quot;,&quot;file.text&quot;,true);  request.send(null);}</code></pre></li></ul></li><li><p>setRequestHeader(header,value)</p><ul><li><p>当浏览器向服务器请求页面时，它会伴随这个请求发送一组首部信息。这些首部信息是一系列描述请求的元数据（metadata）。首部信息用来声明一个请求时GET还是POST。</p></li><li><p>Ajax请求中，发送首部信息的工作可以由setRequestHeader该完成</p></li><li><p>参数header：首部的名字；参数value；首部的值</p></li><li><p>如果用POST请求向服务器发送数据，需要将“Content-type”的首部设置为“application/x-www-form-urlencoded”.他会告知服务器正在发送数据，并且数据已经符合URL编码了。</p></li><li><p>该方法必须再open（）之后才能调用</p></li><li><p>完整的Ajax的POST请求示例：</p><pre><code class="js">var url = &quot;../jsp/forumServlet&quot;;var nameValue = trim(document.forumAddForm.name.value);xhr.open(&quot;POST&quot;,url);xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);xhr.send(&quot;method-name_isExist&quot;+&quot;&amp;name&quot;+nameValue);</code></pre></li></ul></li></ol><h2 id="接受响应"><a href="#接受响应" class="headerlink" title="接受响应"></a>接受响应</h2><ol><li><p>用XMLHttpRequest的方法可向服务器发送请求。再Ajax处理过程中，XMLHttpRequest的如下属性可被服务器更改：</p><ul><li>readState</li><li>status</li><li>responseText</li><li>responseXML</li></ul></li><li><p>readyState</p><ul><li>readyState属性表示Ajax请求的当前状。它的值用数字代表。<ul><li>0代表未初始化，还没有调用open方法</li><li>1代表正在加载。open方法已被调用，但send方法还没有被调用</li><li>2代表已加载完毕。send已被调用。请求已经开始</li><li>3代表交互中。服务器正在发送响应</li><li>4代表完成。响应发送完毕</li></ul></li><li>每次readyState值的改变，都会触发readystatechange事件。如果把onreadysataechange事件处理函数赋给一个函数，那么每次readyState值的改变都会引发该函数的执行。</li><li>readyState值的变化会因浏览器的不同而有所差异。但是当请求结束的时候，每个浏览器都会把readyState的值统一设为4.</li></ul></li><li><p>status</p><ul><li>服务器发送给的每一个响应也都带有首部信息。三位数的状态码是服务器发送的响应中最重要的首部信息，并且属于超文本传输协议中的一部分。</li><li>常用状态码及其含义：<ul><li>404没找到页面（not found）</li><li>403禁止访问（forbidden）</li><li>500内部服务器出错（internal service error）</li><li>200一切正常（ok）</li><li>304没有被修改（not modifiled）</li></ul></li><li>再XMLHttpRequest对象中，服务器发送的状态码都保存再status属性里。通过把这个值和200或304比较，可以确保服务器是否已发送一个成功的响应</li></ul></li><li><p>responseText</p><ul><li><p>XMLHttpRequest的responseText属性包含了从服务器发送的数据。它是一个HTML，XML或普通文本，这取决于服务器发送的内容。</p></li><li><p>当readyState属性值变成4时，responseText属性才可用，表名Ajax请求已经结束</p><pre><code class="js">function doSomeThing(){  if(request.readyState == 4){      if(request.status == 200 || request.status == 304){          alert(request.responseText);      }  }}</code></pre></li></ul></li><li><p>responseXML</p><ul><li>如果服务器返回的是XML，那么数据将储存再responseXML属性中。</li><li>只用服务器发送了带有正确首部信息数据时，responseXML属性才是可用的。MIME类型必须为text/xml</li></ul></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><pre><code class="js">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function () {        //1.获取a节点，并为onclick响应函数        document.getElementsByTagName(&quot;a&quot;)[0].onclick = function() {            //3. 创建一个XMLHttpRequest对象            var request = new XMLHttpRequest();            //4.准备发送请求的数据：url            var url = this.href + &quot;?time= &quot; + new Date();            var method = &quot;GET&quot;;            //5.调用XMLHttoRequest对象的open方法            request.open(method,url);            //6.调用XMLHttpRequest对象的send方法            request.send(null);            //7.为XMLHttpRequest对象添加onreadstatechange响应函数            request.onreadystatechange = function() {                //8.判断响应式否完成：XMLHttpRequest对象的readyState属性值为4的时候                if(request.readyState == 4){                    //9.判断响应是否可用：XMLHttpRequest对象status属性值为200                    if(request.status == 200 || request.status == 304){                        //10.打印响应结果：responseText                        alert(request.responseText);                    }                }            }            //2. 取消a节点的默认行为            return false;        }    }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;helloAjax.txt&quot;&gt;HelloAjax&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><pre><code class="js">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.onload = function () {        //1.获取a节点，并为onclick响应函数        document.getElementsByTagName(&quot;a&quot;)[0].onclick = function() {            //3. 创建一个XMLHttpRequest对象            var request = new XMLHttpRequest();            //4.准备发送请求的数据：url            var url = this.href + &quot;?time= &quot; + new Date();            var method = &quot;POST&quot;;            //5.调用XMLHttoRequest对象的open方法            request.open(method,url);            request.setRequestHeader(&quot;ContentType&quot;,&quot;application/x-www-form-urlencoded&quot;);            //6.调用XMLHttpRequest对象的send方法            request.send(&quot;name = &#39;matthew&#39; &quot;);            //7.为XMLHttpRequest对象添加onreadstatechange响应函数            request.onreadystatechange = function() {                //8.判断响应式否完成：XMLHttpRequest对象的readyState属性值为4的时候                if(request.readyState == 4){                    //9.判断响应是否可用：XMLHttpRequest对象status属性值为200                    if(request.status == 200 || request.status == 304){                        //10.打印响应结果：responseText                        alert(request.responseText);                    }                }            }            //2. 取消a节点的默认行为            return false;        }    }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;helloAjax.txt&quot;&gt;HelloAjax&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="shell">Hello Ajax(*^_^*)</code></pre><p><img src="https://img-blog.csdnimg.cn/20190701162821788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax概述</title>
    <link href="undefined2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/Ajax%E6%A6%82%E8%BF%B0/"/>
    <url>2019/11/27/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ajax/Ajax%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ol><li><p>Ajax的技术的产生</p><ul><li>Ajax被认为是（Asynchronous【异步】 JavaScript and XML的缩写）。现在，允许浏览器与服务器通信无须刷新当前页面的技术都被叫做Ajax。</li><li>“Ajax”这个名字是在2005年2月，Adaptive Path的Jesse James Garrett再他的文章Ajax：A New Approach to Web Application中创造。</li><li>而Ajax这项技术，是Google再Google Labs发布Google Maps和GoogleSuggest后真正为人所认识。<br><img src="https://img-blog.csdnimg.cn/20190701134153248.png" srcset="undefined" alt="在这里插入图片描述"><br>图1 Web的传统模型，客户端向服务器发送一个请求，服务器返回整个页面，如此反复。<br><img src="https://img-blog.csdnimg.cn/20190701134240626.png" srcset="undefined" alt="在这里插入图片描述"><br>图2 在Ajax模型中，数据在客户端与服务器之间独立传输。服务器不再返回整个页面。</li></ul></li><li><p>不用刷新整个页面便可与服务器通讯的方法：</p><ul><li>Flash</li><li>Java applet</li><li>框架:如果使用一组框架构造了一个网页，可以只更新其中一个框架，而不必惊动整个页面</li><li>隐藏的iframe</li><li>XMLHttpRequest：该对象是对JavaScript的一个扩展，可使网页与服务器进行通信。是创建Ajax应用的最佳选择。<strong>实际上通常把Ajax当成XMLHttpRequest对象的代名词</strong></li></ul></li></ol><h2 id="Ajax的工作原理图"><a href="#Ajax的工作原理图" class="headerlink" title="Ajax的工作原理图"></a>Ajax的工作原理图</h2><p><img src="https://img-blog.csdnimg.cn/20190701134724700.png" srcset="undefined" alt="在这里插入图片描述"></p><h2 id="Ajax工具包"><a href="#Ajax工具包" class="headerlink" title="Ajax工具包"></a>Ajax工具包</h2><p>Ajax并不是一项新技术，它实际上是几种技术，每种技术各尽其职，以一种全新的方式聚合在一起</p><ul><li><font color=red>服务器端语言</font>：服务器需要具备向浏览器发送特定信息的能力。<font color=blue>Ajax与服务器端语言无关。</font></li><li><font color=red>XML</font>(eXtensible Markup Language,可扩展标记语言)是一种描述数据的格式，<font color=blue>Ajax程序需要某种格式化的格式来在服务器和客户端之间传递信息，XML是其中的一种选择</font></li><li><font color=red>XHTML</font>（eXtended Hypertext Markup Language，使用扩展超媒体标记语言）和<font color=red>CSS</font>（Cascading Style Sheet，级联样式单）<font color=blue>标准化呈现；</font></li><li><font color=red>DOM</font>（Document   Object Module，文档对象模型）实现动态显示和交互；</li><li>使用XMLHTTP组件<font color=red>XMLHttpRequest对象</font><font color=blue>进行异步数据读取</font></li><li>使用<font color=red>JavaScript</font><font color=blue>绑定和处理所有数据</font></li></ul><h2 id="Ajax的缺陷"><a href="#Ajax的缺陷" class="headerlink" title="Ajax的缺陷"></a>Ajax的缺陷</h2><p>AJAX不是完美的技术。使用AJAX,它的一些缺陷不得不权衡一下：</p><ul><li>由Javascript和AJAX引擎导致的浏览器的<font color=blue>兼容</font></li><li>页面局部刷新，导致<font color=blue>后退等功能失效。</font></li><li>对流媒体的支持没有FLASH、Java Applet好</li><li>一些手机设备（如手机、PDA等）支持性差。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack与Queue</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/Stack%E4%B8%8EQueue/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/Stack%E4%B8%8EQueue/</url>
    
    <content type="html"><![CDATA[<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack(栈)"></a>Stack(栈)</h2><p>栈(Stack)也是一种特殊的线性表，是一种后进先出(LIFO)的结构。</p><ol><li>栈是限定仅在表尾进行插入和删除运算的线性表，表尾称为栈顶(top)，表头称为栈底(bottom)。</li><li>栈的物理存储可以用顺序存储结构，也可以用链式存储结构。<br><img src="https://img-blog.csdnimg.cn/20181227084350862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></li></ol><h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h2><p>队列(Queue)是限定所有的插入只能在表的一端进行，而所有的删除都在表的另一端进行的线性表。</p><ol><li>表中允许插入的一端称为队尾(Rear)，允许删除的一端称为队头(Front)。</li><li>队列的操作是按先进先出(FIFO)的原则进行的。</li><li>队列的物理存储可以用顺序存储结构，也可以用链式存储结构。<br><img src="https://img-blog.csdnimg.cn/20181227084616495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></li></ol><pre><code class="java">package fourtyFourth;import java.util.LinkedList;import java.util.Queue;public class MyQueue{    private LinkedList list = new LinkedList();    public void add(Object o){        list.addLast(o);    }    public Object poll(){        return list.removeFirst();    }    public boolean isEmpty(){        return list.isEmpty();    }    public static void main(String[] args){        MyQueue myQueue = new MyQueue();        myQueue.add(&quot;one&quot;);        myQueue.add(&quot;two&quot;);        myQueue.add(&quot;three&quot;);        System.out.println(myQueue.poll());        System.out.println(myQueue.poll());        System.out.println(myQueue.poll());        System.out.println(myQueue.isEmpty());        Queue queue = new LinkedList();        queue.add(&quot;one&quot;);        queue.offer(&quot;two&quot;);        queue.add(&quot;three&quot;);        System.out.println(queue.poll());        System.out.println(queue.poll());        System.out.println(queue.peek());        System.out.println(queue.isEmpty());    }}</code></pre><p>结果是<br>one<br>two<br>three<br>true<br>one<br>two<br>three<br>false</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/List/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/List/</url>
    
    <content type="html"><![CDATA[<h2 id="链表List"><a href="#链表List" class="headerlink" title="链表List"></a>链表List</h2><h3 id="ArrayList（数组列表）"><a href="#ArrayList（数组列表）" class="headerlink" title="ArrayList（数组列表）"></a>ArrayList（数组列表）</h3><ol><li>java.util<br>Class ArrayList&lt;E&gt;<br>java.lang.Object<br>extended by java.util.AbstractCollection&lt;E&gt;<br>   extended by java.util.AbstractList&lt;E&gt;<pre><code>   extended by java.util.ArrayList\&lt;E&gt;</code></pre></li></ol><table><thead><tr><th>构造方法（Constructor Summary）</th><th>具体含义</th></tr></thead><tbody><tr><td>ArrayList()</td><td>Constructs an empty list with an initial capacity of ten. 他是一个集合，通过add（E e） 添加</td></tr></tbody></table><table><thead><tr><th>Method Summary</th><th>具体含义</th></tr></thead><tbody><tr><td>public boolean add(E e)</td><td>Appends the specified element to the end of this list.</td></tr><tr><td>public int size()</td><td>Returns the number of elements in this list.</td></tr><tr><td>public void clear()</td><td>Removes all of the elements from this list. The list will be empty after this call returns.</td></tr><tr><td>public boolean isEmpty()</td><td>Returns true if this list contains no elements.</td></tr><tr><td>public E remove(int index)</td><td>Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).</td></tr><tr><td>public boolean remove(Object o)</td><td>Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).</td></tr><tr><td>public int indexOf(Object o)</td><td>Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.</td></tr><tr><td>Object[] toArray()</td><td>Returns an array containing all of the elements（元素） in this list in proper sequence (from first to last element).</td></tr></tbody></table><h4 id="add方法，get方法，size方法，remove方法，clear方法"><a href="#add方法，get方法，size方法，remove方法，clear方法" class="headerlink" title="add方法，get方法，size方法，remove方法，clear方法"></a>add方法，get方法，size方法，remove方法，clear方法</h4><pre><code class="java">import java.util.ArrayList;public class ArrayListTest1 {    public static void main(String[] args) {        ArrayList arrayList = new ArrayList();        arrayList.add(&quot;hello&quot;);        arrayList.add(&quot;world&quot;);        arrayList.add(&quot;world&quot;);        arrayList.add(&quot;welcome&quot;);        String s1 = (String) arrayList.get(0);        String s2 = (String) arrayList.get(1);        String s3 = (String) arrayList.get(2);        String s4 = (String) arrayList.get(3);        System.out.println(s1);        System.out.println(s2);        System.out.println(s3);        System.out.println(s4);        System.out.println(&quot;-----------------&quot;);        for (int i = 0; i &lt; arrayList.size(); i++) {            System.out.println(arrayList.get(i));        }        arrayList.remove(0);        arrayList.remove(&quot;welcome&quot;);        System.out.println(&quot;-----------------&quot;);        for (int i = 0; i &lt; arrayList.size(); i++) {            System.out.println(arrayList.get(i));        }        arrayList.add(&quot;aaa&quot;);        arrayList.add(&quot;bbb&quot;);        System.out.println(arrayList.indexOf(&quot;world&quot;));        System.out.println(arrayList.indexOf(&quot;aaa&quot;));        arrayList.clear();        System.out.println(arrayList.size());        System.out.println(arrayList.isEmpty());    }}</code></pre><p>结果是<br>hello<br>world<br>world<br>welcome</p><hr><p>hello<br>world<br>world<br>welcome</p><hr><p>world<br>world<br>0<br>2<br>0<br>true</p><p>说明集合元素可重复。</p><pre><code class="java">import java.util.ArrayList;public class ArrayListTest2 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(&quot;hello&quot;);        list.add(new Integer(2));        String str = (String)list.get(0);        Integer in = (Integer)list.get(1);        System.out.println(str);        System.out.println(in.intValue());    }}</code></pre><p>结果是<br>hello<br>2</p><p>输入什么类型输出什么类型，如果将in的类型改为String编译时不会出错，但运行时会出错，出错原因： <strong><em>java.lang.Integer cannot be cast to java.lang.String</em></strong>。</p><pre><code class="java">ArrayList list = new ArrayList();list.add(3);int i = (int)list.get(0);System.out.println(i);</code></pre><p>这样是错误的因为add中的参数是对象，而8种原生数据类型不是对象，所以会出错。<br>但是实际上你编译运行时是不会报错的是因为编译器自动将3装箱放入ArrayList中，get方法又将object强转为integer对象</p><pre><code class="java">public class Main {    public static void main(String[] args) {    //自动装箱    Integer total = 99;    //自定拆箱    int totalprim = total;    }}</code></pre><p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p><p>我们用arrayList实现个例子：将3，4，5，6存到集合中然后取出求和输出</p><pre><code class="java">import java.util.ArrayList;public class ArrayListTest3 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(new Integer(3));        list.add(new Integer(4));        list.add(new Integer(5));        list.add(new Integer(6));        int sum = 0;        for(int i=0;i&lt;list.size();i++) {            int value = ((Integer)list.get(i)).intValue();            sum+=value;        }        System.out.println(sum);    }}</code></pre><p>结果是<br>18</p><pre><code class="java">import java.util.ArrayList;public class ArrayListTest4 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(new Integer(1));        list.add(new Integer(2));        list.add(new Integer(3));        list.add(new Integer(4));        list.add(new Integer(5));        list.add(new Integer(6));        Integer[] in = (Integer[])list.toArray();        for(int i= 0;i&lt;in.length;i++) {            System.out.println(in[i].intValue());        }    }}</code></pre><p>结果出错<br><strong><em>[Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;</em></strong><br>虽然Object可以转换为Integer，但Object[]不能转换为Integer[]，因此我们只能用遍历。</p><pre><code class="java">public class ArrayListTest4 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(new Integer(1));        list.add(new Integer(2));        list.add(new Integer(3));        list.add(new Integer(4));        list.add(new Integer(5));        list.add(new Integer(6));        /*        * 不能将Object[]转换为Integer[]        * 因为Integer[]继承的是Object而不是Object[]        * 或者我们可以这么想，假设Object[]中有字符串那么我们转换时就会出错。        */        Object[] in = list.toArray();        for(int i= 0;i&lt;in.length;i++) {            System.out.println(((Integer)in[i]).intValue());        }    }}</code></pre><p><strong>集合中存放的依然是对象的引用而不是对象本身</strong>。</p><pre><code class="java">package Fortieth;import java.util.ArrayList;public class ArrayListTest5 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(new Point(2, 3));        list.add(new Point(2, 2));        list.add(new Point(4, 4));        for (int i = 0; i &lt; list.size(); i++) {            System.out.println(list.get(i));// 虽然返回的是Object但是实际上是Point，系统会调用Point的toString方法，因为我们没有重写所以会继承Object中的toString方法        }        System.out.println(list);// 调用list的toString方法    }}</code></pre><pre><code class="java">package Fortieth;public class Point {    int x;    int y;    /**    * @param x coordinate of x    * @param y coordinate of y    */    Point(int x, int y) {        this.x = x;        this.y = y;    }}</code></pre><p>结果是<br>Fortieth.Point@75b84c92<br>Fortieth.Point@6bc7c054<br>Fortieth.Point@232204a1<br>[Fortieth.Point@75b84c92, Fortieth.Point@6bc7c054, Fortieth.Point@232204a1]<br>很显然直接输出get返回的参数是Point调用自己的toString方法，因为没有重写，所以使用的是继承Object方法中的toString。<br>而直接输出list先调用list的toString方法输出[]然后再调用每一个元素的toString方法。</p><pre><code class="java">import java.util.ArrayList;public class ArrayListTest5 {    public static void main(String[] args) {        ArrayList list = new ArrayList();        list.add(new Point(2, 3));        list.add(new Point(2, 2));        list.add(new Point(4, 4));        for (int i = 0; i &lt; list.size(); i++) {            System.out.println(list.get(i));// 虽然返回的是Object但是实际上是Point，系统会调用Point的toString方法，因为我们没有重写所以会继承Object中的toString方法        }        System.out.println(list);// 调用list的toString方法    }}</code></pre><pre><code class="java">public class Point {    int x;    int y;    /**    * @param x coordinate of x    * @param y coordinate of y    */    Point(int x, int y) {        this.x = x;        this.y = y;    }    /**    * @return return coordinate of axis of x and y    */    public String toString() {        return &quot;x=&quot; + this.x + &quot;,y=&quot; + this.y;    }}</code></pre><p>结果是<br>x=2,y=3<br>x=2,y=2<br>x=4,y=4<br>[x=2,y=3, x=2,y=2, x=4,y=4]</p><ol><li>ArrayList 底层采用数组实现，当使用不带参数的构造方法生成ArrayList对象时，实际上会在底层生成一个长度为 10 的 Object 类型数组</li><li>如果增加的元素个数超过了 10 个，那么 ArrayList 底层会新生成一个数组，长度为原数组的 1.5 倍+1， 然后将原数组的内容复制到新数组当中，并且后续增加的内容都会放到新数组当中。当新数组无法容纳增加的元素时，重复该过程。</li><li>对于 ArrayList 元素的删除操作，需要将被删除元素的后续元素向前移动，代价比较高，对于 ArrayList 元素的插入操作，同样如此，如果已经有3个元素，再第二个元素位插入一个新的元素，后续元素将向后移动。</li><li>集合当中只能放置对象的引用，无法放置原生数据类型，我们需要使用原生数据类型的包装类才能加入到集合当中。</li><li>集合当中放置的都是 Object 类型，因此取出来的也是 Object 类型，那么必须要使用强制类型转换将其转换为真正的类型（放置进去的类型）。</li></ol><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>无参的构造方法我们已经了解了，接下来我们了解下有参的构造方法</p><ol><li>public ArrayList(int initialCapacity)<br>Constructs an empty list with the specified initial capacity. （构造一个空的列表使用初始的容量）<br>initialCapacity - the initial capacity of the list （列表最开始的容量）<br>建立一个数组列表，该数组有指定的初始容量（capacity）。容量是用于存储元素的基本数组的大小。当元素被追加到数组列表上时，容量会自动增加。</li><li>public ArrayList(Collection&lt;? extends E&gt; c)<br>Constructs a list containing the elements of the specified collection, in the order they are returned by the collection’s iterator. （构造一个列表包含指定集合的元素，顺序是在集合迭代的顺序返回）<br>c - the collection whose elements are to be placed into this list<br>建立一个数组列表，该数组列表由类集c中的元素初始化</li></ol><p><strong>但是LinkedList只有两个没有第三个，因为没必要</strong></p><h3 id="LinkedList（链表）（链接的列表）"><a href="#LinkedList（链表）（链接的列表）" class="headerlink" title="LinkedList（链表）（链接的列表）"></a>LinkedList（链表）（链接的列表）</h3><p>java.util<br>Class LinkedList&lt;E&gt;<br>java.lang.Object<br>java.util.AbstractCollection&lt;E&gt;<br>java.util.AbstractList&lt;E&gt;<br>java.util.AbstractSequentialList&lt;E&gt;<br>java.util.LinkedList&lt;E&gt;</p><p>LinkedList和ArrayList都是实现的list接口但是LinkedList有一些特有的方法</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><pre><code class="java">LinkedList list = new LinktedLIst();list.add(&quot;aaa&quot;);</code></pre><ol><li>当向 ArrayList 添加一个对象时，实际上就是将该对象放置到了 ArrayList 底层所维护的数组当中；当向 LinkedList 中添加一个对象时，实际上 LinkedList 内部会生成一个Entry 对象，该 Entry 对象的结构为：</li></ol><pre><code class="java">Entry{    Entry previous;    Object element;    Entry next;}Entry entry = new Entry();entry.element = &quot;aaa&quot;;entrylis.add(;```)其中的 Object 类型的元素 element 就是我们向 LinkedList 中所添加的元素，然后 Entry又构造好了向前与向后的引用 previous、 next，最后将生成的这个 Entry 对象加入到了表当中。 换句话说， **LinkedList 中所维护的是一个个的 Entry 对象**。#### addLastpublic void addLast(E e)Appends the specified element to the end of this list.#### addFirstpublic void addFirst(E e)Inserts the specified element at the beginning of this list.```javapackage fourtyFirst;import java.io.ObjectStreamException;import java.util.LinkedList;public class LinkedListTest1 {    public static void main(String[] args) {        LinkedList list = new LinkedList();        list.add(&quot;F&quot;);        list.add(&quot;B&quot;);        list.add(&quot;D&quot;);        list.add(&quot;E&quot;);        list.add(&quot;C&quot;);        list.addLast(&quot;Z&quot;);        list.addFirst(&quot;A&quot;);        list.add(1, &quot;A2&quot;);        System.out.println(&quot;最初的集合&quot; + list);        list.remove(&quot;F&quot;);        list.remove(2);        System.out.println(&quot;变化之后的集合&quot;+list);        Object value = list.get(2);        list.set(2, (String)value + &quot;changed&quot;);        System.out.println(&quot;最后的集合&quot;+ list);    }}</code></pre><p>结果是<br>最初的集合[A, A2, F, B, D, E, C, Z]<br>变化之后的集合[A, A2, D, E, C, Z]<br>最后的集合[A, A2, Dchanged, E, C, Z]</p><h2 id="链表的数据结构"><a href="#链表的数据结构" class="headerlink" title="链表的数据结构"></a>链表的数据结构</h2><ol><li>一般将数据结构分为两大类：<strong>线型数据结构和非线性数据结构</strong>。线型数据结构有线性表、栈、队列、串、数组和文件非线性数据结构有树和图（继承）</li><li>线性表的逻辑结构是n个数据元素的有限序列:(a1, a2 ,a3,…an)n为线性表的长度(n≥0)， n=0的表称为空表。2 数据元素呈线性关系。必存在唯一的称为“第一个” 的数据元素；必存在唯一的称为“最后一个”的数据元素；除第一个元素外，每个元素都有且只有一个前驱元素； 除最后一个素外，每个元素都有且只有一个后继元素。</li><li>所有数据元素在同一个线性表中必须是相同的数据类型。</li><li>线性表按其存储结构可分为顺序表和链表。用顺序存储结构存储的线性表称为顺序表；<br>用链式存储结构存储的线性表称为链表。</li><li>将线性表中的数据元素依次存放在某个存储区域中,所形成的表称为顺序表。 <strong>一维数组就是用顺序方式存储的线性表</strong>。</li></ol><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="https://img-blog.csdnimg.cn/20181222211910174.png" srcset="undefined" alt="在这里插入图片描述"></p><pre><code class="java">package fourtyFirst;public class NodeTest {    public static void main(String[] args) {        Node fNode = new Node(&quot;node1&quot;);        Node sNode = new Node(&quot;node2&quot;);        Node tNode = new Node(&quot;node3&quot;);        fNode.next = sNode;        sNode.next = tNode;        tNode.next = null;        System.out.println(fNode.next.next.data);    }}</code></pre><pre><code class="java">package fourtyFirst;public class Node {    String data;//存放节点数据本身    Node next; //存放指向下一个节点的引用    public Node(String str) {        data = str;    }}</code></pre><p>结果是<br>node3</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img src="https://img-blog.csdnimg.cn/20181222212240254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p><p>在上述main方法中加入下列代码</p><pre><code class="java">System.out.println(&quot;---------------&quot;);Node node4 = new Node(&quot;node4&quot;);fNode.next = node4;node4.next = sNode;System.out.println(fNode.next.next.next.data);</code></pre><p>结果是<br>node3<br>-————–<br>node3</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://img-blog.csdnimg.cn/20181222212729606.png" srcset="undefined" alt="在这里插入图片描述"></p><pre><code class="java">System.out.println(&quot;---------------&quot;);fNode.next = sNode;node4.next = null;System.out.println(fNode.next.next.data);</code></pre><p>结果是<br>node3<br>-————–<br>node3<br>-————–<br>node3</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://img-blog.csdnimg.cn/2018122221303666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p><pre><code class="java">tNode.next = fNode;</code></pre><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="https://img-blog.csdnimg.cn/20181222213105107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p><pre><code class="java">package fourtyFirst;public class Node2 {    Node2 previous;    String data;    Node2 next;    public Node2(String data) {        this.data = data;    }}</code></pre><pre><code class="java">package fourtyFirst;public class Node2Test {    public static void main(String[] args) {        Node2 node1 = new Node2(&quot;node1&quot;);        Node2 node2 = new Node2(&quot;node2&quot;);        Node2 node3 = new Node2(&quot;node3&quot;);        node1.previous = node3;        node2.previous = node1;        node3.previous = node2;        node1.next = node2;        node2.next = node3;        node3.next = node1;        Node2 node4 = new Node2(&quot;node4&quot;);        //插入到1和2之间        node1.next = node4;        node4.next = node2;        node2.previous = node4;        node4.previous = node1;        //删除4        node1.next = node2;        node4.next = null;        node2.previous = node1;        node4.previous = null;    }}</code></pre><p><code>LinkedList实际上就是双向链表</code></p><h2 id="关于-ArrayList-与-LinkedList-的比较分析"><a href="#关于-ArrayList-与-LinkedList-的比较分析" class="headerlink" title="关于 ArrayList 与 LinkedList 的比较分析"></a>关于 ArrayList 与 LinkedList 的比较分析</h2><ol><li>ArrayList 底层采用数组实现， LinkedList 底层采用双向链表实现。</li><li>当执行插入或者删除操作时， 采用 LinkedList 比较好。</li><li>当执行搜索操作时， 采用 ArrayList 比较好。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Iterator</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/Iterator/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/Iterator/</url>
    
    <content type="html"><![CDATA[<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>通常希望循环通过类集中的元素。例如，可能会希望显示每一个元素。到目前为止，处理这个问题的最简单方法是使用iterator，iterator是一个或者实现Iterator或者实现ListIterator接口的对象。 Iterator可以完成循环通过类集，从而获得或删除元素。 <strong>ListIterator扩展Iterator，允许双向遍历列表，并可以修改单元。</strong></p><p>对于执行List的类集，也可以通过调用ListIterator来获得迭代函数。正如上面解释的那样，列表迭代函数提供了前向或后向访问类集的能力，并可让你修改元素。否则， ListIterator如同Iterator功能一样</p><p>public Iterator&lt;E&gt; iterator()<br>Returns an iterator over the elements in this set. The elements are returned in no particular order.<br>（返回一个迭代器针对于集合中所有的元素，元素不以特定的顺序返回）</p><h2 id="Interface-Iterator-lt-E-gt"><a href="#Interface-Iterator-lt-E-gt" class="headerlink" title="Interface Iterator&lt;E&gt;"></a>Interface Iterator&lt;E&gt;</h2><p>public interface Iterator&lt;E&gt;</p><p>An iterator over a collection.（一个针对集合的迭代器） Iterator takes the place of Enumeration in the Java collections framework. Iterators differ from enumerations in two ways:</p><ul><li>Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.</li><li>Method names have been improved.</li></ul><p>This interface is a member of the Java Collections Framework.<br>|Method Summary||<br>|–|–|<br>| boolean |hashNext（） Returns true if the iteration has more elements.  |<br>|E|next()      Returns the next element in the iteration.|<br>|void|remove()    Removes from the underlying collection the last element returned by the iterator (optional operation).|</p><h2 id="hasNext"><a href="#hasNext" class="headerlink" title="hasNext"></a>hasNext</h2><p>boolean hasNext()<br>Returns true if the iteration has more elements.<br>（如果迭代还有更多的元素那就返回真）<br>(In other words, returns true if next would return an element rather than throwing an exception.)</p><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>E next()<br>Returns the next element in the iteration.<br>(返回迭代中的下一个元素）</p><h2 id="迭代器的工作原理"><a href="#迭代器的工作原理" class="headerlink" title="迭代器的工作原理"></a>迭代器的工作原理</h2><p><img src="https://img-blog.csdnimg.cn/20181229085859965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"><br>在通过迭代函数访问类集之前，必须得到一个迭代函数。每一个Collection类都提供一个iterator( )函数，该函数返回一个对类集头的迭代函数。通过使用这个迭代函数对象，可以访问类集中的每一个元素，一次一个元素。通常，使用迭代函数循环通过类集的内容，步骤如下</p><ol><li>通过调用类集的iterator( )方法获得对类集头的迭代函数。</li><li>建立一个调用hasNext( )方法的循环，只要hasNext( )返回true，就进行循环迭代。</li><li>在循环内部，通过调用next( )方法来得到每一个元素。</li></ol><pre><code class="java">package fourtySixth;import java.util.HashSet;import java.util.Iterator;public class InteratorTest {    public static void main(String[] args) {        HashSet set = new HashSet();        set.add(&quot;a&quot;);        set.add(&quot;b&quot;);        set.add(&quot;c&quot;);        set.add(&quot;d&quot;);        set.add(&quot;e&quot;);    //      Iterator iter = set.iterator();    //    //      while(iter.hasNext())    //      {    //          String value = (String)iter.next();    //          System.out.println(value);    //      }        for (Iterator iter = set.iterator(); iter.hasNext();) {            String value = (String) iter.next();            System.out.println(value);        }    }}</code></pre><p>结果是：<br>a<br>b<br>c<br>d<br>e</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/Set/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/Set/</url>
    
    <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>public interface Set&lt;E&gt;extends Collection&lt;E&gt;（继承collection接口）<br>A collection that contains no duplicate elements.<br>（一个集合不能包含重复的元素）</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>public boolean add(E e)<br>Adds the specified element to this set if it is not already present.<br>（将指定的元素e加入如果集合中没有）<br>More formally, adds the specified element e to this set if this set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).<br>（更重要的是，如果它不包含满足这个(e==null ? e2==null : e.equals(e2))条件的时候，它会将这个e加入这个集合中）<br> If this set already contains the element, the call leaves the set unchanged and returns false.<br> （如果这个集合中包含这个元素，这个集合就不改变，并且返回false）</p><pre><code class="java">package fourtyfifth;import java.util.HashSet;public class SetTest1 {    public static void main(String[] args) {        HashSet set = new HashSet();        set.add(&quot;c&quot;);        System.out.println(set.add(&quot;a&quot;));        set.add(&quot;b&quot;);        set.add(&quot;d&quot;);        System.out.println(set.add(&quot;a&quot;));        System.out.println(set);    }}</code></pre><p>结果是：<br>true<br>false<br>[a, b, c, d]<br>说明set是无序的，并且元素是不能重复的。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>Indicates whether some other object is “equal to” this one.<br>（用来指示是否另外一个对象“equal to”调用equals方法的对象）<br>The equals method implements an equivalence relation on non-null object references:</p><p>It is reflexive（自反的）: for any non-null reference（引用） value x, x.equals(x) should return true.<br>It is symmetric（对称的）: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.<br>It is transitive（传递性）: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.<br>It is consistent（一致性）: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.<br>For any non-null reference value x, x.equals(null) should return false.</p><p> 关于 Object 类的 equals 方法的特点<br>a) 自反性： x.equals(x)应该返回 true，前提是不为空。<br>b) 对称性： x.equals(y)为 true，那么 y.equals(x)也为 true。<br>c) 传递性： x.equals(y)为 true 并且 y.equals(z)为 true，那么 x.equals(z)也应该为 true。<br>d) 一致性： x.equals(y)的第一次调用为 true，那么 x.equals(y)的第二次、第三次、第 n次调用也应该为 true，前提条件是在比较之间没有修改 x 也没有修改y。<br>e) 对于非空引用 x， x.equals(null)返回 false。<br>The equals method for class Object implements the most discriminating possible equivalence relation on objects;（对于Object类的equals方法来说，它实现了最有差别的可能等价关系在对象上）<br> that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).<br> （对于任何的非空引用x，y来说，这个方法返回真并且只返回真，前提是x，y指向同一个对象）</p><p>Note that it is generally necessary to override the hashCode method whenever this method is overridden,<br>（注意通常我们有必要去重写hashCode方法当这个方法被重写的时候）<br> so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.<br>（以便维护hashCode方法的一般契约,表明相等的对象必须有相等的hashCode)</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>public int hashCode()<br>（返回一个整数）<br>Returns a hash code value for the object.<br>（返回这个对象的hash code 值<br>This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable.<br>（这个方法被支持为了hashtables这个方法）<br>The general contract of hashCode is:<br>（hashCode的一般性契约）<br>Whenever it is invoked on the same object more than once during an execution of a Java application,<br>（无论何时当我调用一个对象一次以上的hashCode在java应用的一次执行过程当中）<br>the hashCode method must consistently return the same integer,<br>（那么这个hashCode必须返回相同的整数值）<br>provided no information used in equals comparisons on the object is modified.<br>（假设这个对象的信息没有被修改）<br>This integer need not remain consistent from one execution of an application to another execution of the same application.<br>（这个整数不需要保持一致，在第一次执行过程和另一次执行过程）<br>If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.<br>（如果两个对象通过equals方法相等，那么这两个对象调用hashCode方法一定返回相同的整型值）<br>It is not required that if two objects are unequal according to the equals (java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.<br>（并不需要满足两个对象不相等，hashCode一定不一样，然而，如果不同则可以提高应用的性能）<br>As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects.<br>（根据实际的情况来说，有类Object定义的hashCode方法会针对不同的对象返回不同的整数值。）<br> (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)<br> （通常将内部的地址转换为十六进制的数，但是这种机制并不是强制的）</p><p>关于 Object 类的 hashCode()方法的特点：<br>a) 在 Java 应用的一次执行过程当中，对于同一个对象的 hashCode 方法的多次调用，他们应该返回同样的值（前提是该对象的信息没有发生变化）。<br>b) 对于两个对象来说，如果使用 equals 方法比较返回 true，那么这两个对象的 hashCode<br>值一定是相同的。<br>c) 对于两个对象来说，如果使用 equals方法比较返回 false，那么这两个对象的 hashCode<br>值不要求一定不同（可以相同，可以不同）， 但是如果不同则可以提高应用的性能。<br>d) 对于 Object类来说，不同的 Object对象的 hashCode值是不同的（Object类的 hashCode值表示的是对象的地址）。</p><p> 当使用 HashSet 时， hashCode()方法就会得到调用，判断已经存储在集合中的对象的hash code 值是否与增加的对象的 hash code 值一致；如果不一致，直接加进去；如果一致，再进行 equals 方法的比较， equals 方法如果返回 true，表示对象已经加进去了，就不会再增加新的对象，否则加进去。</p><pre><code class="java">package fourtyfifth;import java.util.HashSet;public class SetTest2{    public static void main(String[] args){        HashSet set = new HashSet();        set.add(new People(&quot;zhangsan&quot;));        set.add(new People(&quot;lisi&quot;));        set.add(new People(&quot;zhangsan&quot;));//两个zhangsan是不同的对象地址不同一定能放进去        System.out.println(set);        System.out.println(&quot;---------------&quot;);        People p1 = new People(&quot;zhangsan&quot;);        set.add(p1);        set.add(p1);//p1的地址是一样的，然后用equals方法，发现一致所以只能放一个        System.out.println(p1);        System.out.println(&quot;---------------&quot;);        String s1 = new String(&quot;a&quot;);        String s2 = new String(&quot;a&quot;);        System.out.println(&quot;hash code: &quot; + (s1.hashCode() == s2.hashCode()));        set.add(s1);        set.add(s2);        System.out.println(set);    }}class People{    String name;    public People(String name){        this.name = name;    }}</code></pre><p>结果是：<br>[fourtyfifth.People@6bc7c054,fourtyfifth.People@232204a1,fourtyfifth.People@75b84c92]<br>-————–<br>fourtyfifth.People@4aa298b7<br>-————–<br>hash code: true<br>[a,fourtyfifth.People@6bc7c054,fourtyfifth.People@232204a1,fourtyfifth.People@4aa298b7, fourtyfifth.People@75b84c92]</p><p> <strong><em>如果我们重写 equals 方法，那么也要重写 hashCode 方法，反之亦然。</em></strong></p><pre><code class="java">package fourtyfifth;import java.util.HashSet;public class SetTest3{    public static void main(String[] args){        HashSet set = new HashSet();        Student s1 = new Student(&quot;zhangsan&quot;);        Student s2 = new Student(&quot;zhangsan&quot;);        System.out.println(s1.hashCode()==s2.hashCode());        set.add(s1);        set.add(s2);        System.out.println(set.hashCode());        System.out.println(set);    }}class Student{    String name;    public Student(String name){        this.name = name;    }    @Override    public int hashCode() {        final int prime = 31;        int result = 1;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }    @Override    public boolean equals(Object obj) {        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (name == null) {            if (other.name != null)                return false;        } else if (!name.equals(other.name))            return false;        return true;    }    /* public int hashCode()        {        return this.name.hashCode();        }        public boolean equals(Object obj)        {        if(this == obj)        {        return true;        }        if(null != obj &amp;&amp; obj instanceof Student)        {        Student s = (Student)obj;        if(name.equals(s.name))        {        return true;        }        }        return false;        }    */}</code></pre><p>结果是：<br>true<br>-1432604525<br>[fourtyfifth.Student@aa9c3093]<br>注释中是我们自己编写的hashCode和equals方法实现的功能和eclipse生成的一样。</p><h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>public interface SortedSet&lt;E&gt;extends Set&lt;E&gt;</p><p>A Set that further provides a total ordering on its elements. The elements are ordered using their natural ordering（自然排序）, or by a <em>Comparator</em> typically provided at sorted set creation time.</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>java.util<br>Class TreeSet&lt;E&gt;<br>java.lang.Object<br>  extended by java.util.AbstractCollection&lt;E&gt;<br>      extended by java.util.AbstractSet&lt;E&gt;<br>          extended by java.util.TreeSet&lt;E&gt;<br>All Implemented Interfaces:<br>Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, NavigableSet&lt;E&gt;,<strong><em>Set&lt;E&gt;, SortedSet&lt;E&gt;</em></strong><br>TreeSet为使用树来进行存储的Set接口提供了一个工具， 对象按升序存储。访问和检索是很快的。在存储了大量的需要进行快速检索的排序信息的情况下， TreeSet是一个很好的选择。</p><pre><code class="java">package fourtyThird;import java.util.TreeSet;public class TreeSetTest{    public static void main(String[] args){        TreeSet set = new TreeSet();        set.add(&quot;C&quot;);        set.add(&quot;A&quot;);        set.add(&quot;B&quot;);        set.add(&quot;E&quot;);        set.add(&quot;F&quot;);        set.add(&quot;D&quot;);        System.out.println(set);    }}</code></pre><p>结果是：<br>[A, B, C, D, E, F]<br>正如上面解释的那样，因为TreeSet按树存储其元素，它们被按照排序次序自动安排，如程序输出所示<br>| 构造函数 | 解释 |<br>|–|–|<br>| TreeSet( ) | 第一种形式构造一个空的树集合，该树集合将根据其元素的自然顺序按升序排序。 |<br>|TreeSet(Collection c)|第二种形式构造一个包含了c的元素的树集合。|<br>|TreeSet(Comparator comp)|第三种形式构造一个空的树集合，它按照由comp指定的比较函数进行排序。|<br>|TreeSet(SortedSet ss)|第四种形式构造一个包含了ss的元素的树集合|</p><h3 id="Comparator（比较函数）"><a href="#Comparator（比较函数）" class="headerlink" title="Comparator（比较函数）"></a>Comparator（比较函数）</h3><p>java.util<br>Interface Comparator&lt;T&gt;<br>Type Parameters:<br>T - the type of objects that may be compared by this comparator</p><h4 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h4><p>int compare(T o1,T o2)<br>Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.<br><strong>Returns:</strong><br>a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. （返回一个正数，0，或负数，当第一个参数小于，等于，或者大于第二个参数时）</p><pre><code class="java">compare（new Integer(1), new Integer(2));//返回一个正数compare（new Integer(2), new Integer(2));//返回0compare（new Integer(3), new Integer(2));//返回负数</code></pre><p>Note that it is always safe not to override Object.equals(Object)。</p><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><p>Throws:<br><strong>ClassCastException</strong> - if the specified object cannot be compared with the elements currently in this set<br><strong>NullPointerException</strong> - if the specified element is null and this set uses natural ordering, or its comparator does not permit null elements</p><pre><code class="java">package fourtyThird;import java.util.Comparator;import java.util.Iterator;import java.util.TreeSet;public class TreeSetTest2{    public static void main(String[] args){        TreeSet set = new TreeSet(new PersonComparator());//当排序的类可以自然排序时可以不指定比较方法        Person p1 = new Person(10);        Person p2 = new Person(20);        Person p3 = new Person(30);        Person p4 = new Person(40);        set.add(p1);        set.add(p2);//如果不告诉TreeSet类用什么方法去比较，就会抛出异常,也就是说TreeSet set = new TreeSet();，在调用set.add(p2)就会抛出ClassCastException异常。        set.add(p3);        set.add(p4);        for(Iterator iter = set.iterator(); iter.hasNext();)        {            Person p = (Person)iter.next();            System.out.println(p.score);        }    }}class Person{    int score;    public Person(int score){        this.score = score;    }    public String toString(){        return String.valueOf(this.score);    }}class PersonComparator implements Comparator//告诉TreeSet如何比较Person类{    public int compare(Object arg0, Object arg1){        Person p1 = (Person) arg0;        Person p2 = (Person) arg1;        return p1.score -p2.score;//升序    //  return p2.score - p1.score;//降序    }}</code></pre><p>结果是：<br>10<br>20<br>30<br>40</p><pre><code class="java">package fourtyThird;import java.util.Comparator;import java.util.Iterator;import java.util.TreeSet;public class TreeSetTest3 {    public static void main(String[] args) {        TreeSet set = new TreeSet(new MyComparator());        set.add(&quot;C&quot;);        set.add(&quot;A&quot;);        set.add(&quot;B&quot;);        set.add(&quot;E&quot;);        set.add(&quot;a&quot;);        set.add(&quot;F&quot;);        set.add(&quot;D&quot;);        for (Iterator iter = set.iterator(); iter.hasNext();) {            String value = (String) iter.next();            System.out.println(value);        }    }    }    class MyComparator implements Comparator {    @Override    public int compare(Object arg0, Object arg1) {        String s1 = (String) arg0;        String s2 = (String) arg1;        return s2.compareTo(s1);    }}</code></pre><p>结果是：<br>a<br>F<br>E<br>D<br>C<br>B<br>A</p><p>int compare(T o1,T o2)<br>Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.<br>s2.compareTo(s1);是降序</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ol><li><p>HashSet扩展AbstractSet并且实现Set接口。</p></li><li><p>它创建一个类集，该类集使用散列表进行存储。散列表通过使用称之为散列法的机制来存储信息。</p></li><li><p>在散列（hashing）中，一个关键字的信息内容被用来确定唯一的一个值，称为<strong>散列码</strong>（hash code）。而散列码被用来当做与关键字相连的数据的存储下标。关键字到其散列码的转换是自动执行的——你看不到散列码本身。你的程序代码也不能直接索引散列表。</p><pre><code class="java"> package fourtyThird; public class HashTest1 {     public static void main(String[] args) {         String str=&quot;hello&quot;;         int hash=0;         for(int i=0;i&lt;str.length();i++) {             hash=31*hash+str.charAt(i);             System.out.println(hash);         }     } }</code></pre><p> 结果是<br> 104<br> 3325<br> 103183<br> 3198781<br> 99162322<br> 那么下面散列码的结果不同也就好解释了。s和t都还是String对象，散列码由内容获得，结果一样。sb和tb是StringBuffer对象，自身没有hashCode方法，只能继承Object的默认方法，散列码是对象地址，当然不一样了。</p><pre><code class="java"> package fourtyThird; public class HashTest1 {     public static void main(String[] args) {         String s=new String(&quot;OK&quot;);         String t=&quot;OK&quot;;         StringBuffer sb=new StringBuffer(s);         StringBuffer tb=new StringBuffer(t);         int hash=0;         System.out.println(&quot;s&quot;);         for(int i=0;i&lt;s.length();i++) {             hash=s.hashCode();             System.out.println(hash);         }         System.out.println(&quot;t&quot;);         for(int i=0;i&lt;t.length();i++) {             hash=t.hashCode();             System.out.println(hash);         }         System.out.println(&quot;sb&quot;);         for(int i=0;i&lt;sb.length();i++) {             hash=sb.hashCode();             System.out.println(hash);         }         System.out.println(&quot;tb&quot;);         for(int i=0;i&lt;tb.length();i++) {             hash=tb.hashCode();             System.out.println(hash);         }     } }</code></pre><p> 结果是<br> s<br> 2524<br> 2524<br> t<br> 2524<br> 2524<br> sb<br> 1975012498<br> 1975012498<br> tb<br> 1808253012<br> 1808253012<br> <img src="https://img-blog.csdnimg.cn/20181224223400833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p></li><li><p>散列法的优点在于即使对于大的集合，它允许一些基本操作如add( ),contains( ),remove( )和size( )方法的运行时间保持不变。它创建一个类集，该类集使用散列表进行存储。散列表通过使用称之为散列法的机制来存储信息。</p></li><li><p>hashCode方法必须与equals方法必须兼容<br> 如果我们自己定义了一个类，想对这个类的大量对象组织成散列表结构便于查找。有一点一定要注意：就是hashCode方法必须与equals方法向兼容。</p><pre><code class="java"> class Employee {     int id;     String name = &quot;&quot;;     // 相同id对象具有相同散列码     public int hashCode() {         return id;     }     // equals必须比较id     public boolean equals(Employee x) {         if (this.id == x.id)             return true;         else             return false;     } }</code></pre><p> public HashSet()<br> Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load factor (0.75).（构造一个新的空集；支持HashMap实例具有默认的初始容量（16）和负载因子（0.75）。）</p></li><li><p>散列表又称为哈希表。散列表算法的基本思想是：以结点的关键字为自变量，通过一定的函数关系（散列函数）计算出对应的函数值，以这个值作为该结点存储在散列表中的地址。当散列表中的元素存放太满，就必须进行再散列，将产生一个新的散列表，所有元素存放到新的散列表中，原先的散列表将被删除。</p></li><li><p>在Java语言中，通过负载因子(loadfactor)来决定何时对散列表进行再散列。例如：如果负载因子是0.75，当散列表中已经有75%的位置已经放满，那么将进行再散列。负载因子越高(越接近1.0)，内存的使用效率越高，元素的寻找时间越长。负载因子越低(越接近0.0)，元素的寻找时间越短，内存浪费越多。</p></li><li><p>HashSet类的缺省负载因子是0.75。</p><table><thead><tr><th>构造方法</th><th>解释</th></tr></thead><tbody><tr><td>HashSet( )</td><td>第一种形式构造一个默认的散列集合。</td></tr><tr><td>HashSet(Collection c)</td><td>第二种形式用c中的元素初始化散列集合。</td></tr><tr><td>HashSet(int capacity)</td><td>第三种形式用capacity初始化散列集合的容量。</td></tr><tr><td>HashSet(int capacity, float fillRatio)</td><td>第四种形式用它的参数初始化散列集合的容量和填充比（也称为加载容量）。填充比必须介于0.0与1.0之间，它决定在散列集合向上调整大小之前，有多少能被充满。具体的说，就是当元素的个数大于散列集合容量乘以它的填充比时，散列集合被扩大。对于没有获得填充比的构造函数，默认使用0.75</td></tr><tr><td>HashSet没有定义更多的其他方法。</td><td></td></tr></tbody></table><pre><code class="java"> package fourtyThird; import java.util.HashSet; import java.util.Iterator; public class HashTest1 {     public static void main(String[] args) {         HashSet set = new HashSet();         set.add(&quot;3&quot;);         set.add(&quot;6&quot;);         set.add(&quot;5&quot;);         set.add(&quot;1&quot;);         set.add(&quot;9&quot;);         Iterator iter = set.iterator();         while(iter.hasNext()){             String value = (String)iter.next();               System.out.println(value);         }     } }</code></pre><p> 结果是：<br> 1<br> 3<br> 5<br> 6<br> 9</p><p> • 重要的是，<strong>注意：散列集合并没有确保其元素的顺序</strong>，因为散列法的处理通常不让自己参与创建排序集合。如果需要排序存储，另一种类集——<strong>TreeSet</strong>将是一个更好的选择。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse</title>
    <link href="undefined2019/11/25/%E7%BC%96%E8%BE%91%E5%99%A8/Eclipse/"/>
    <url>2019/11/25/%E7%BC%96%E8%BE%91%E5%99%A8/Eclipse/</url>
    
    <content type="html"><![CDATA[<h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><ol><li>设置字体Window  》 Preferences 》 General 》 Appearance 》 Colors and Fonts 》 Java 》 Java Editor Text Font 》 Edit 来设置</li><li>Ctrl+Shift+F格式化快捷键</li><li>Ctrl+Shirt+O自动导入包</li><li>自动生成hashCode和equals方法：source》生成hashCode（）和equals</li><li>自动生成get，set方法source 》 生成Getter和Setter</li><li>Ctrl+t，自动找到接口实习类</li><li>选中要提取的代码，右键=》Refactor=》Extract Method （快捷键是：Ctrl+Shift+M）然后就可以提取代码到一个新的方法中（用在servlet）</li></ol>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
      <category>Eclipse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eclipse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA</title>
    <link href="undefined2019/11/25/%E7%BC%96%E8%BE%91%E5%99%A8/IDEA/"/>
    <url>2019/11/25/%E7%BC%96%E8%BE%91%E5%99%A8/IDEA/</url>
    
    <content type="html"><![CDATA[<h2 id="IDE（Integrated-Development-Environment）集成开发环境"><a href="#IDE（Integrated-Development-Environment）集成开发环境" class="headerlink" title="IDE（Integrated Development Environment）集成开发环境"></a>IDE（Integrated Development Environment）集成开发环境</h2><ol><li>NetBeans <a href="http://netbeans.org/" target="_blank" rel="noopener">http://netbeans.org/</a></li><li>Intellij IDEA (公认最好的Java开发工具之一）</li><li>Eclipse</li></ol><h3 id="修改IDEA的快捷提示按键，使它只能按回车才使用提示"><a href="#修改IDEA的快捷提示按键，使它只能按回车才使用提示" class="headerlink" title="修改IDEA的快捷提示按键，使它只能按回车才使用提示"></a>修改IDEA的快捷提示按键，使它只能按回车才使用提示</h3><p>eclipse的快捷提示无论你按空格按回车都会强迫你使用它的提示，但是当我们不想使用它的提示的时候就显得非常难受了，<br>所以IDEA的这个设置，能够给我们更强的自主性。</p><img src="/2019/11/25/%E7%BC%96%E8%BE%91%E5%99%A8/IDEA/%E6%8F%90%E7%A4%BA.png" srcset="undefined" class="" title="提示"><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol><li><p>IDEA在当前类中查找方法快捷键<br>例如在String类中查找contains方法。<br>Ctrl + F12</p></li><li><p>格式化：Ctrl+Alt+L</p></li><li><p>Alt + Ins 快速创建构造方法</p></li><li><p>Ctrl + Alt + O 自动清楚无用包</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/Collection/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/Collection/</url>
    
    <content type="html"><![CDATA[<h2 id="集合Collection概念"><a href="#集合Collection概念" class="headerlink" title="集合Collection概念"></a>集合Collection概念</h2><ol><li>对于 Java 中的常量的命名规则：所有单词的字母都是大写，如果有多个单词，<br> 那么使用下划线连接即可。 比如说：<br> public static final int AGE_0F_PERSON = 20;</li><li><strong>在 Java 中声明 final 常量时通常都会加上 static 关键字</strong>，这样对象的每个实例<br> 都会访问唯一一份常量值。</li></ol><p><img src="https://img-blog.csdnimg.cn/20181220214709819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"></p><h3 id="Interface-Collection-lt-E-gt"><a href="#Interface-Collection-lt-E-gt" class="headerlink" title="Interface Collection&lt;E&gt;"></a>Interface Collection&lt;E&gt;</h3><p>public interface Collection&lt;E&gt;extends Iterable&lt;E&gt;<br><strong>E</strong>可以先当作Object类型具体后面学。</p><h4 id="Collection的Java-API中的定义"><a href="#Collection的Java-API中的定义" class="headerlink" title="Collection的Java API中的定义"></a>Collection的Java API中的定义</h4><p>The root interface in the collection hierarchy.<br>继承层次的根接口<br> A collection represents a group of objects,known as its elements.<br>一个集合代表一组对象 ，这些对象我们称为元素<br>Some collections allow duplicate elements and others do not.<br>某些集合允许重复的元素而其他的是不可以的。<br>Some are ordered and others unordered.<br>有些是排序的有些不是排序的<br>The JDK does not provide any <em>direct implementations</em> of this interface:<br>JDK不提供任何对这个接口的直接实现<br> it provides implementations of more specific subinterfaces like Set and List.<br>他提供了更加具体的子接口像Set和List来实现Collection这个父接口<br>This interface is typically used to pass collections around and manipulate them where maximum generality is desired.<br>这个接口通常被用作传递集合并且操纵集合。</p><h3 id="Interface-Set-lt-E-gt"><a href="#Interface-Set-lt-E-gt" class="headerlink" title="Interface Set&lt;E&gt;"></a>Interface Set&lt;E&gt;</h3><p>public interface Set&lt;E&gt;extends Collection&lt;E&gt;</p><p>A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction.</p><h3 id="Interface-List-lt-E-gt"><a href="#Interface-List-lt-E-gt" class="headerlink" title="Interface List&lt;E&gt;"></a>Interface List&lt;E&gt;</h3><p>public interface List&lt;E&gt;extends Collection&lt;E&gt;</p><p>An ordered collection (also known as a sequence).<br>一个<strong>有序</strong>的集合（也称之为<strong><em>序列</em></strong>）<br> The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h3 id="reverseOrder"><a href="#reverseOrder" class="headerlink" title="reverseOrder()"></a>reverseOrder()</h3><p>reverseOrder() 方法用于获取一个比较用来实现Comparable接口的对象的集合的自然顺序相反。<br>以下是java.util.Collections.reverseOrder()方法的声明。<br>public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder()<br>在方法调用返回一个比较器，它强行上实现Comparable接口的对象的集合的自然顺序相反。</p><h3 id="shuffle-List-lt-gt"><a href="#shuffle-List-lt-gt" class="headerlink" title="shuffle(List&lt;?&gt;)"></a>shuffle(List&lt;?&gt;)</h3><p>shuffle(List<?>) 方法用于随机排列随机使用一个默认的源指定的列表。以下是java.util.Collections.shuffle()方法的声明。public static void shuffle(List<?> list)<br>list– 将要改组的列表。</p><pre><code class="java">package fourtyThird;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.LinkedList;public class CollectionsTest {    public static void main(String[] args) {        LinkedList list = new LinkedList();        list.add(new Integer(-8));        list.add(new Integer(20));        list.add(new Integer(-20));        list.add(new Integer(8));        Comparator r = Collections.reverseOrder();        Collections.sort(list, r);        for (Iterator iter = list.iterator(); iter.hasNext();) {            System.out.println(iter.next() + &quot; &quot;);        }        System.out.println(&quot;-----------------&quot;);        Collections.shuffle(list);        for (Iterator iter = list.iterator(); iter.hasNext();) {            System.out.println(iter.next() + &quot; &quot;);        }        System.out.println(&quot;minimum value: &quot; + Collections.min(list));        System.out.println(&quot;maximum value: &quot; + Collections.max(list));    }}</code></pre><p>结果是：<br>20<br>8<br>-8<br>-20<br>-—————-<br>-20<br>20<br>-8<br>8<br>minimum value: -20<br>maximum value: 20</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="undefined2019/11/25/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/"/>
    <url>2019/11/25/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h2><p><strong>待查找的数组要有序。</strong></p><pre><code class="java">public class ArraySearchTest {    public static int search(int[] array, int value) {        int low = 0;        int high = array.length - 1;        int middle;        while(low &lt;= high) {            middle = (low + high) / 2;            if(array[middle] == value) {                return middle;            }            if(value &lt; array[middle]) {                high = middle - 1;            }            if(value &gt; array[middle]) {                low = middle + 1;            }        }        return -1;    }    public static void main(String[] args) {        int[] a = new int[] {1, 2, 3, 4, 5, 6, 7, 8};        int value = 8;        int index = search(a, value);        System.out.println(index);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>查找</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="undefined2019/11/25/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <url>2019/11/25/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序。（掌握交换排序，快速排序的原理与实现方式）"><a href="#冒泡排序。（掌握交换排序，快速排序的原理与实现方式）" class="headerlink" title="冒泡排序。（掌握交换排序，快速排序的原理与实现方式）"></a>冒泡排序。（掌握交换排序，快速排序的原理与实现方式）</h2><h3 id="arraycopy方法"><a href="#arraycopy方法" class="headerlink" title="arraycopy方法"></a>arraycopy方法</h3><p>这个方法是JDK提供的API，这个方法在java.lang.System。<br>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</p><p>Parameters:<br>src - the source array（原数组）.<br>srcPos - starting position in the source array（原数组中的起始位置，从此位置开始拷贝）.<br>dest - the destination array（目标数组）.<br>destPos - starting position in the destination data（目标数组的起始位置，从此位置开始接收）.<br>length - the number of array elements to be copied（待拷贝的的数组的个数）.</p><pre><code class="java">public class ArrayCopy {    public static void main(String[] args) {        int[] a = new int[] {1, 2, 3, 4};        int[] b = new int[4];        System.arraycopy(a, 0, b, 0, 4);        for(int i = 0;i &lt; b.length; i++) {            System.out.print(b[i]+&quot; &quot;);        }    }}</code></pre><p><strong><em>结果是<br>1 2 3 4</em></strong></p><ol><li>冒泡排序<br>拿个数组举例将下列数组升序排序<br>第一次排序<br><img src="https://img-blog.csdnimg.cn/20181217215026783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"><br>第二次排序<br><img src="https://img-blog.csdnimg.cn/20181217215123280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70" srcset="undefined" alt="在这里插入图片描述"><br>依次排序排列成<strong>3 4 5 7 9</strong></li></ol><p>设置一个方法接受参数int[]类型的数组将顺序排好再返回（升序排列）</p><pre><code class="java">public class BubbleSortTest {    public static int[] bubbleSort(int[] a) {        for(int i = 0;i &lt; a.length; i++) {            for(int j = 1;j &lt; a.length-i; j++) {                if(a[j-1] &gt; a[j]) {                    int temp = a[j-1];                    a[j-1] = a[j];                    a[j] = temp;                }            }            System.out.print(&quot;第&quot; + (i + 1) + &quot;趟排序&quot;);            for(int k = 0; k &lt; a.length; k++) {                System.out.print(a[k] + &quot; &quot;);            }            System.out.println();            //提升效率，如果没有发生比较直接返回数组        }        return a;    }    public static void main(String[] args) {        int[] a = new int[5];        a[0] = 5;        a[1] = 4;        a[2] = 7;        a[3] = 9;        a[4] = 3;        System.out.print(&quot;排序之前:&quot;);        for(int i = 0;i &lt; a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }        System.out.println();        a = bubbleSort(a);        System.out.print(&quot;排序之后:&quot;);        for(int i = 0;i &lt; a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }    }}</code></pre><p><strong><em>排序之前:5 4 7 9 3<br>第1趟排序4 5 7 3 9<br>第2趟排序4 5 3 7 9<br>第3趟排序4 3 5 7 9<br>第4趟排序3 4 5 7 9<br>第5趟排序3 4 5 7 9<br>排序之后:3 4 5 7 9</em></strong><br>==优化之后==</p><pre><code class="java">public class BubbleSortTest {    public static int[] bubbleSort(int[] a) {        boolean x = true;        for(int i = 0;i &lt; a.length; i++) {            x = true;            for(int j = 1;j &lt; a.length-i; j++) {                if(a[j-1] &gt; a[j]) {                    int temp = a[j-1];                    a[j-1] = a[j];                    a[j] = temp;                    x = false;                }            }            System.out.print(&quot;第&quot; + (i + 1) + &quot;趟排序&quot;);            for(int k = 0; k &lt; a.length; k++) {                System.out.print(a[k] + &quot; &quot;);            }            System.out.println();            if(x) {             //提升效率，如果没有发生比较直接返回数组                return a;            }        }        return a;    }    public static void main(String[] args) {        int[] a = new int[10];        a[0] = 5;        a[1] = 4;        a[2] = 7;        a[3] = 9;        a[4] = 3;        a[5] = 45;        a[6] = 1;        a[7] = 4;        a[8] = 8;        a[9] = 3;        System.out.print(&quot;排序之前:&quot;);        for(int i = 0;i &lt; a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }        System.out.println();        a = bubbleSort(a);        System.out.print(&quot;排序之后:&quot;);        for(int i = 0;i &lt; a.length; i++) {            System.out.print(a[i] + &quot; &quot;);        }    }}</code></pre><p>结果是<br>排序之前:5 4 7 9 3 45 1 4 8 3<br>第1趟排序4 5 7 3 9 1 4 8 3 45<br>第2趟排序4 5 3 7 1 4 8 3 9 45<br>第3趟排序4 3 5 1 4 7 3 8 9 45<br>第4趟排序3 4 1 4 5 3 7 8 9 45<br>第5趟排序3 1 4 4 3 5 7 8 9 45<br>第6趟排序1 3 4 3 4 5 7 8 9 45<br>第7趟排序1 3 3 4 4 5 7 8 9 45<br>第8趟排序1 3 3 4 4 5 7 8 9 45<br>排序之后:1 3 3 4 4 5 7 8 9 45</p><p>快速排序也是交换排序的一种，在后面介绍。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组剖析</title>
    <link href="undefined2019/11/25/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E7%BB%84%E5%89%96%E6%9E%90/"/>
    <url>2019/11/25/%E5%90%8E%E7%AB%AF/Java/%E6%95%B0%E7%BB%84%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="包装类（Wrapper-Class）"><a href="#包装类（Wrapper-Class）" class="headerlink" title="包装类（Wrapper Class）"></a>包装类（Wrapper Class）</h2><ol><li><p>针对于原生数据类型的包装，所有的包装类（8 个）都位于java.lang 包下。<br> 例如：Integer把原生数据类型int包装在对象中，类型Integer的对象包含了一个单独的一个int类型的值。</p><pre><code class="java"> public class IntegerTest {     public static void main(String[] args) {         int a = 10;         Integer integer = new Integer(a);         int b = integer.intValue();         System.out.println(a == b);     } }</code></pre><p> <code>结果是：true 其他的类型同理</code></p></li><li><p>Java 中的 8 个包装类分别是：Byte,Short,Integer,Long,Float,Double,Character, Boolean。 他们的使用方式都是一样的，可以实现原生数据类型与包装类型的双向转换。</p></li></ol><h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><ol><li><p>相同类型数据的集合就叫做数组。</p></li><li><p>如何定义数组，我们可以从new关键字看出数组其实是一个对象。</p></li><li><p>type[] 变量名 = new type[数组中元素的个数];可以按照下列方式定义长 type[] 变量名 = new type[数组中元素的个数];可以按照下列方式定义长度为 10 的数组：</p><pre><code class="java"> int[] a = new int[10]; int a[] = new int[10];      //不建议使用</code></pre></li><li><p>数组中的元素索引是从 0 开始的。对于数组来说，最大的索引==数组的长度 – 1。</p><pre><code class="java"> public class ArraryTest {     public static void main(String[] args) {         int[] a = new int[4];         int b[] = new int[2];         a[0] = 1;         a[1] = 2;         a[2] = 3;         a[3] = 4;         b[0] = 1;         b[1] = 2;         System.out.println(a[3]);         System.out.println(b[1]);     } }</code></pre><p> <strong><em>int[]是一个整体a代表int类型的数组</em></strong></p></li><li><p>定义数组的第 3 种方式： type[] 变量名 = {new type[]}{逗号分隔的初始化值列表};</p><pre><code class="java">     int[] b = {1,2,3,4};     int[] c = new int[] {1,2,3,4};     System.out.println(b[2]);     System.out.println(c[0]);</code></pre><p> <strong><em>结果是3 ，1  但是不可以写成new int[4]{1,2,3,4}</em></strong></p></li><li><p>Java 中的每个数组都有一个名为 length 的属性，表示数组的长度。 <strong>length</strong> 属性是 <strong>public，final， int</strong> 的。数组长度一旦确定，就不能改变大小。</p></li><li><p>int[] a = new int[10]，其中 a 是一个引用，它指向了生成的数组对象的首地址，数组中<br> 每个元素都是 int 类型，其中仅存放数据值本身。</p><pre><code class="java">         int[] a = new int[4];         boolean[] b = new boolean[2];         System.out.println(a[0]);         System.out.println(b[1]);</code></pre><p> <strong><em>结果是0，false</em></strong></p><pre><code class="java">         int[] a = {1,2,3};         int[] b = {1,2,3};         System.out.println(a.equals(b));         System.out.println(a == b );         System.out.println(a[0] == b[0]);</code></pre><p> <strong><em>结果是false   false  true    int[]并没有重写object类中的equals方法，所以两个对象并不相同。</em></strong></p></li><li><p>引用类型的变量的初值为空，数组中存放的是引用所以</p><pre><code class="java"> public class ArrayTest2 {     public static void main(String[] args) {         Person[] p = new Person[3];         System.out.println(p[0]);     } } class Person{     int age;     public Person(int age) {         this.age = age;     } }</code></pre><p> <strong><em>结果为null</em></strong></p><pre><code class="java">     public static void main(String[] args) {         Person[] p = new Person[3];         //System.out.println(p[0]);         p[0] = new Person(10);         p[1] = new Person(20);         p[2] = new Person(30);         for(int i = 0;i &lt; p.length; i++) {             System.out.println(p[i].age);         }         Person[] p2 = new Person[5];         for(int i = 0;i &lt; p2.length; i++) {             System.out.println(p2[i]);         }     } } class Person{     int age;     public Person(int age) {         this.age = age;     } }</code></pre><p> ***结果为10</p><pre><code>     20     30     null     null     null     null     null 执行完Person[] p = new Person[3];内存给数组分配3个空间，并且引用p指向p[0]的首地址，并且p[0],p[1],p[2]中存放的是引用并不是person对象，p[0] = new Person(10);p[1] = new Person(20);p[2] = new Person(30);当执行完这三句后p[0],p[1],p[2]存放的是指向person的引用，执行之前，数组中存放的是null***</code></pre><p> 将单数叫lisi双数叫zhangsan的例子：</p><pre><code class="java"> public class ArrayTest3 {     public static void main(String[] args) {         Student[] s = new Student[100];         for(int i = 0;i &lt; s.length; i++) {             s[i] = new Student();  //先生成对象             /*             if(i % 2 == 0){                 s[i].name = &quot;zhangsan&quot;;             }             else {                 s[i].name = &quot;lisi&quot;;             }             */             s[i].name = i % 2 == 0 ? &quot;zhangsan&quot; : &quot;lisi&quot;;         }         for(int i = 0;i &lt; s.length; i++) {             System.out.println(s[i].name);         }     } } class Student{     String name; }</code></pre></li><li><p>二维数组。 二维数组是一种平面的二维结构，本质上是数组的数组。 二维数组的定义方式： type[][] a = new type[2][3];</p><pre><code class="java"> public class ArrayTest4 {     public static void main(String[] args) {         int[][] i = new int[2][3];         System.out.println(i instanceof Object);//证明i是对象         System.out.println(i[0] instanceof int[]);//证明i[0]是数组     } }</code></pre><p> <strong>我们也可以把每一个行赋予不同的列</strong>，例如第一行2列，第二行3列，第三行1列</p><pre><code class="java"> public class ArraryTest5 {     public static void main(String[] args) {         int[][] a = new int[3][];         a[0] = new int[2];         a[1] = new int[3];         a[2] = new int[1];     } }</code></pre><p> <strong><em>注意：但是我们不能int[][] a = new int[][3];这样写，因为我们只知道有三列而不知道有几行无法初始化。</em></strong><br> 我们将不规则的二维数组的值取出例子如下：</p><pre><code class="java"> public class ArraryTest5 {     public static void main(String[] args) {         int[][] b = new int[][]{{1,2,3},{4},{5,6,7,8}};         for(int i = 0;i &lt; b.length; i++) {             for(int j = 0;j &lt;b[i].length; j++) {                 System.out.print(b[i][j]+&quot; &quot;);             }             System.out.println();         }     } }</code></pre><p> <strong><em>结果是<br> 1 2 3<br> 4<br> 5 6 7 8</em></strong></p></li><li><p>三维数组。 type[][][] a = new type[2][3][4];</p><pre><code class="java">public class ThreeDimensionArrayTest {    public static void main(String[] args) {        int[][][] a = new int[2][3][4];        System.out.println(a instanceof int[][][]);        System.out.println(a[0] instanceof int[][]);        System.out.println(a[0][0] instanceof int[]);    }}</code></pre><p><strong><em>结果是<br>true<br>true<br>true</em></strong></p></li></ol><h2 id="Swap交换"><a href="#Swap交换" class="headerlink" title="Swap交换"></a>Swap交换</h2><p>我们想要把x，y交换该如何作？<br>如果用第一种方法，x，y只是把值传给swap方法，a，b的改变并不影响x，y。<br>第二种方法才是正确的将x，y的值交换的方式。<br>第三种方法是不适用中间变量将a，b交换的方法。</p><pre><code class="java">public class Swap {    public static void swap(int a,int b) {        int temp = a;        a = b;        b = temp;    }    public static void main(String[] args) {        int x = 3;        int y = 4;        Swap.swap(x, y);        System.out.println(x);        System.out.println(y);        int temp = x;        x = y;        y = temp;        System.out.println(x);        System.out.println(y);        int a = 3;        int b = 4;        a = a + b;        b = a - b;        a = a - b;        System.out.println(x);        System.out.println(y);    }}</code></pre><p><strong><em>结果是<br>3<br>4<br>4<br>3<br>4<br>3</em></strong><br>那我们如果非要用方法实现两个数的交换该怎么办昵？<br>我们先来看下面这个例子</p><pre><code class="java">public class Swap2 {    public static void swap(char[] ch,char c) {        ch[0] = &#39;B&#39;;        c = &#39;D&#39;;    }    public static void main(String[] args) {        char[] ch = {&#39;A&#39;,&#39;C&#39;};        swap(ch, ch[1]);        for(int i = 0;i &lt; ch.length; i++) {            System.out.println(ch[i]);        }    }}</code></pre><p><strong><em>结果是<br>B<br>C</em></strong><br>从上面这个例子我们可以看到char[]数组传的是引用，main方法中的ch[0]和swap中的ch[0]是指向的同一个地址所以swap方法把ch[0]里的值改变了，而char是数值c是一个全新的字符型常量，并不是之前的ch[1]，所以ch[1]并没有改变<br>这样我们接着实现两个整数的交换</p><pre><code class="java">public class Swap3 {    public static void swap(int[] i) {        int temp = i[0];        i[0] = i[1];        i[1] = temp;    }    public static void main(String[] args) {        int[] i = {1,2};        swap(i);        System.out.println(i[0]);        System.out.println(i[1]);    }}</code></pre><p><strong><em>结果是<br>2<br>1</em></strong></p><h3 id="接口的数组"><a href="#接口的数组" class="headerlink" title="接口的数组"></a>接口的数组</h3><pre><code class="java">public class ArrayTest6 {    public static void main(String[] args) {        I[] i = new I[2];        I j = null;    }}interface I{}</code></pre><p>上述的例子编译并不会出错，尽管接口不能实例化，但是上述的i中存放的是引用并没有I的实例，所以不会出错，i[0]和j的效果是一样的，只是给分配了地址，并没有把接口实例化，只有输入new I（），程序才会报错。<br>当我们想给接口实例化时，必须让C实现接口I,这里用到了多态。</p><pre><code class="java">public class ArrayTest6 {    public static void main(String[] args) {        I[] i = new I[2];        i[0] = new C();        i[1] = new C();        I[] b = new I[] {new C(),new C()};    }}interface I{}class C implements I{}```## 数组的比较```javaimport java.util.Arrays;public class ArrayEqualsTest {    public static boolean isEqueals(int[] a,int[] b) {        if(a == null || b ==null) {            return false;        }        if(a.length != b.length) {            return false;        }        for(int i = 0; i &lt; a.length; i++) {            if(a[i] != b[i]) {                return false;            }        }        return true;    }    public static void main(String[] args) {        int[] a = {1,2,3};        int[] b = {1,2,3};        System.out.println(isEqueals(a, b));        System.out.println(Arrays.equals(a, b));    }}</code></pre><p><strong><em>结果是<br>true<br>true</em></strong><br>第一个true是我们自己实现的数组比较的方法，而第二个是java自带的在Arrays类中的方法，专门用来比较数组的。</p><h2 id="数组的一道应用题"><a href="#数组的一道应用题" class="headerlink" title="数组的一道应用题"></a>数组的一道应用题</h2><p>随机生成 50 个数字（整数），每个数字的范围是[10, 50]，统计每个数字出现的次数以及出现次数最多的数字与它的个数，最后将每个数字及其出现次数打印出来，如果某个数字出现次数为 0，则不要打印它。打印时按照数字的升序排列。<br><strong>注意：Random（）函数生成的是[0,1)之间的数，也就是说不包含1，但是包含0</strong></p><pre><code class="java">public class Example {    public static void main(String[] args) {        int[] random = new int[50];        int[][] number = new int[2][41];        for(int i = 0; i &lt; 50 ; i++) {            random[i] = (int)(Math.random() * 41) + 10;        }        for(int a = 0; a &lt;= 40; a++) {            number[0][a] = 0;            number[1][a] = a + 10;        }        for(int b = 0; b &lt; 50 ; b++) {            for(int c = 0; c &lt;= 40; c++) {                if(random[b] == number[1][c]) {                    number[0][c]++;                }            }        }        for(int d = 0; d &lt;= 40; d++) {            if(number[0][d] != 0) {                System.out.print(&quot;数字为&quot; + number[1][d]);                System.out.println(&quot;  出现的次数为&quot; + number[0][d]);            }        }    }}</code></pre><p>结果为<br>数字为10  出现的次数为1<br>数字为11  出现的次数为1<br>数字为12  出现的次数为2<br>数字为13  出现的次数为1<br>数字为14  出现的次数为1<br>数字为15  出现的次数为1<br>数字为16  出现的次数为2<br>数字为18  出现的次数为1<br>数字为20  出现的次数为1<br>数字为22  出现的次数为1<br>数字为23  出现的次数为3<br>数字为25  出现的次数为2<br>数字为26  出现的次数为2<br>数字为27  出现的次数为2<br>数字为29  出现的次数为1<br>数字为30  出现的次数为3<br>数字为32  出现的次数为1<br>数字为33  出现的次数为2<br>数字为34  出现的次数为1<br>数字为35  出现的次数为3<br>数字为37  出现的次数为2<br>数字为38  出现的次数为1<br>数字为39  出现的次数为1<br>数字为40  出现的次数为1<br>数字为41  出现的次数为4<br>数字为42  出现的次数为2<br>数字为43  出现的次数为1<br>数字为45  出现的次数为2<br>数字为46  出现的次数为1<br>数字为47  出现的次数为2<br>数字为50  出现的次数为1<br><strong>另一种方法</strong></p><pre><code class="java">import java.util.Random;public class RandomTest2 {    public static void main(String[] args) {        int[] count = new int[41];        Random random = new Random();        for(int i = 0; i &lt; 50; i++) {            int number = random.nextInt(41) + 10;//[10,50]            count[number - 10]++;        }        for(int i = 0; i &lt;count.length; i++) {            if(0 == count[i]) {                continue;            }            System.out.println((10 + i) + &quot;出现的次数&quot; + count[i]);        }        int max = count[0];        for(int i = 0; i &lt; count.length; i++) {            if(max &lt; count[i]) {                max = count[i];            }        }        System.out.println(&quot;出现的最大次数为：&quot; + max + &quot;次&quot;);        for(int i = 0; i &lt; count.length; i++) {            if(max == count[i]) {                System.out.println(i + 10);            }        }    }}</code></pre><p>结果是<br>11出现的次数1<br>12出现的次数2<br>13出现的次数2<br>14出现的次数1<br>15出现的次数2<br>17出现的次数2<br>19出现的次数2<br>20出现的次数4<br>22出现的次数1<br>23出现的次数1<br>24出现的次数2<br>25出现的次数2<br>26出现的次数1<br>27出现的次数1<br>28出现的次数1<br>30出现的次数1<br>31出现的次数1<br>34出现的次数2<br>35出现的次数1<br>36出现的次数3<br>37出现的次数1<br>39出现的次数2<br>40出现的次数2<br>41出现的次数2<br>42出现的次数2<br>43出现的次数1<br>45出现的次数1<br>46出现的次数2<br>48出现的次数1<br>49出现的次数1<br>50出现的次数2<br>出现的最大次数为：4次<br>20</p><h2 id="获取随机数的两种方法"><a href="#获取随机数的两种方法" class="headerlink" title="获取随机数的两种方法"></a>获取随机数的两种方法</h2><h3 id="Random类中的nextInt方法"><a href="#Random类中的nextInt方法" class="headerlink" title="Random类中的nextInt方法"></a>Random类中的nextInt方法</h3><p>java.util<br>Class Random<br>public int nextInt(int n)</p><p>Parameters:<br>n - the bound on the random number to be returned. Must be positive.<br>（返回随机数的边界值）<br>Returns:<br>the next pseudorandom, uniformly distributed int value between 0 (inclusive) and n (exclusive) from this random number<br>（返回下一个随机数，包含0，排除n，所以返回的数是[0,n)）</p><pre><code class="java">import java.util.Random;public class RandomTest {    public static void main(String[] args) {        Random random = new Random();        for(int i = 0; i &lt; 50; i++) {            System.out.println(random.nextInt(41)+10);        }    }}</code></pre><h3 id="Math类中的random方法"><a href="#Math类中的random方法" class="headerlink" title="Math类中的random方法"></a>Math类中的random方法</h3><p>java.lang<br>Class Math<br>public static double random()</p><p>Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. Returned values are chosen pseudorandomly with (approximately) uniform distribution from that range.</p><pre><code class="java">import java.util.Random;public class RandomTest {    public static void main(String[] args) {        Random random = new Random();        for(int i = 0; i &lt; 50; i++) {        double result = Math.random();        result *= 41;        int result2 = (int)result;        result2 += 10;        System.out.println(result2);        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-router</title>
    <link href="undefined2019/11/24/%E5%89%8D%E7%AB%AF/Vue/v-router/"/>
    <url>2019/11/24/%E5%89%8D%E7%AB%AF/Vue/v-router/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-router使用详情"><a href="#vue-router使用详情" class="headerlink" title="vue-router使用详情"></a>vue-router使用详情</h2><p>SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。单页面应用(SPA)的核心之一是:更新视图而不重新请求页面;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式。</p><h3 id="1、hash模式"><a href="#1、hash模式" class="headerlink" title="1、hash模式"></a>1、hash模式</h3><p>随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变url的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><pre><code class="html">    http://www.xxx.com/#/login</code></pre><p>这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：</p><pre><code class="js">function matchAndUpdate () {   // todo 匹配 hash 做 dom 更新操作}window.addEventListener(&#39;hashchange&#39;, matchAndUpdate)</code></pre><h3 id="2、history-模式"><a href="#2、history-模式" class="headerlink" title="2、history 模式"></a>2、history 模式</h3><p>14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了HTML5的实现，单页路由的url就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p><pre><code class="js">function matchAndUpdate () {   // todo 匹配路径 做 dom 更新操作}window.addEventListener(&#39;popstate&#39;, matchAndUpdate)</code></pre><h2 id="vue-router的使用"><a href="#vue-router的使用" class="headerlink" title="vue-router的使用"></a>vue-router的使用</h2><h3 id="1、动态路由匹配"><a href="#1、动态路由匹配" class="headerlink" title="1、动态路由匹配"></a>1、动态路由匹配</h3><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果</p><pre><code class="js">const User = {  template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;}const router = new VueRouter({  routes: [    // 动态路径参数 以冒号开头    { path: &#39;/user/:id&#39;, component: User }  ]})</code></pre><p>现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由。</p><p>一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：</p><p><a href="https://www.jianshu.com/p/5dff6811252d" target="_blank" rel="noopener">https://www.jianshu.com/p/5dff6811252d</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>赋值、浅拷贝和深拷贝的区别</title>
    <link href="undefined2019/11/24/%E5%89%8D%E7%AB%AF/JS/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>2019/11/24/%E5%89%8D%E7%AB%AF/JS/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="赋值（Copy）"><a href="#赋值（Copy）" class="headerlink" title="赋值（Copy）"></a>赋值（Copy）</h2><p>赋值是将某一数值或对象赋给某个变量的过程，分为：</p><ol><li><p>基本数据类型：赋值，赋值之后两个变量互不影响</p></li><li><p>引用数据类型：赋<strong>址</strong>，两个变量具有相同的引用，指向同一个对象，相互之间有影响对基本类型进行赋值操作，两个变量互不影响。</p><pre><code class="html"> // saucxs let a = &quot;saucxs&quot;; let b = a; console.log(b);  // saucxs a = &quot;change&quot;; console.log(a);   // change console.log(b);    // saucxs</code></pre><p> 对引用类型进行赋<strong>址</strong>操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a 中的基本类型数据。</p><pre><code class="html"> // saucxs let a = {     name: &quot;saucxs&quot;,     book: {         title: &quot;You Don&#39;t Know JS&quot;,         price: &quot;45&quot;     } } let b = a; console.log(b); // { //  name: &quot;saucxs&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;} // } a.name = &quot;change&quot;; a.book.price = &quot;55&quot;; console.log(a); // { //  name: &quot;change&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // } console.log(b); // { //  name: &quot;change&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // }</code></pre><p> 通常在开发中并不希望改变变量 a 之后会影响到变量 b，这时就需要用到浅拷贝和深拷贝。</p></li></ol><h2 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h2><h3 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝"></a>什么是浅拷贝</h3><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><img src="/2019/11/24/%E5%89%8D%E7%AB%AF/JS/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" srcset="undefined" class="" title="浅拷贝"><p>上图中，<code>SourceObject</code> 是原对象，其中包含基本类型属性 <code>field1</code> 和引用类型属性 <code>refObj</code>。浅拷贝之后基本类型数据 <code>field2</code> 和 <code>filed1</code> 是不同属性，互不影响。但引用类型 <code>refObj</code> 仍然是同一个，改变之后会对另一个对象产生影响。</p><p>简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的<strong>基本类型值</strong>，以及第一层的<strong>引用类型地址</strong>。</p><h3 id="浅拷贝使用场景"><a href="#浅拷贝使用场景" class="headerlink" title="浅拷贝使用场景"></a>浅拷贝使用场景</h3><ol><li><p>Object.assign()</p><p> <code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p> 有些文章说<code>Object.assign()</code> 是深拷贝，其实这是不正确的。</p><pre><code class="html"> // saucxs let a = {     name: &quot;saucxs&quot;,     book: {         title: &quot;You Don&#39;t Know JS&quot;,         price: &quot;45&quot;     } } let b = Object.assign({}, a); console.log(b); // { //  name: &quot;saucxs&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;} // } a.name = &quot;change&quot;; a.book.price = &quot;55&quot;; console.log(a); // { //  name: &quot;change&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // } console.log(b); // { //  name: &quot;saucxs&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // }``` 上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 `book` 时，对象 b 相应的位置也发生了变化。</code></pre></li><li><p>展开语法 <code>Spread</code></p><pre><code class="html"> // saucxs let a = {     name: &quot;saucxs&quot;,     book: {         title: &quot;You Don&#39;t Know JS&quot;,         price: &quot;45&quot;     } } let b = {...a}; console.log(b); // { //  name: &quot;saucxs&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;} // } a.name = &quot;change&quot;; a.book.price = &quot;55&quot;; console.log(a); // { //  name: &quot;change&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // } console.log(b); // { //  name: &quot;saucxs&quot;, //  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;} // }</code></pre></li><li><p>Array.prototype.slice方法</p><p> slice不会改变原数组，<code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括<code>end</code>）决定的原数组的<strong>浅拷贝</strong>。</p><pre><code class="html"> // saucxs let a = [0, &quot;1&quot;, [2, 3]]; let b = a.slice(1); console.log(b); // [&quot;1&quot;, [2, 3]] a[1] = &quot;99&quot;; a[2][0] = 4; console.log(a); // [0, &quot;99&quot;, [4, 3]] console.log(b); //  [&quot;1&quot;, [4, 3]]</code></pre><p> 可以看出，改变 <code>a[1]</code> 之后 <code>b[0]</code> 的值并没有发生变化，但改变 <code>a[2][0]</code> 之后，相应的 <code>b[1][0]</code> 的值也发生变化。</p><p> 说明 <code>slice()</code> 方法是浅拷贝，相应的还有<code>concat</code>等，在工作中面对复杂数组结构要额外注意。</p></li></ol><h2 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h2><h3 id="什么是深拷贝"><a href="#什么是深拷贝" class="headerlink" title="什么是深拷贝"></a>什么是深拷贝</h3><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p><img src="/2019/11/24/%E5%89%8D%E7%AB%AF/JS/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/%E6%B7%B1%E6%8B%B7%E8%B4%9D.png" srcset="undefined" class="" title="深拷贝"><h3 id="使用深拷贝的场景"><a href="#使用深拷贝的场景" class="headerlink" title="使用深拷贝的场景"></a>使用深拷贝的场景</h3><ol><li>JSON.parse(JSON.stringify(object))</li></ol><pre><code class="html">// saucxslet a = {    name: &quot;saucxs&quot;,    book: {        title: &quot;You Don&#39;t Know JS&quot;,        price: &quot;45&quot;    }}let b = JSON.parse(JSON.stringify(a));console.log(b);// {//  name: &quot;saucxs&quot;,//  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;}// }a.name = &quot;change&quot;;a.book.price = &quot;55&quot;;console.log(a);// {//  name: &quot;change&quot;,//  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;}// }console.log(b);// {//  name: &quot;saucxs&quot;,//  book: {title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;}// }</code></pre><p>完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。</p><p>我们看下对数组深拷贝效果如何。</p><pre><code class="html">// saucxslet a = [0, &quot;1&quot;, [2, 3]];let b = JSON.parse(JSON.stringify( a.slice(1) ));console.log(b);// [&quot;1&quot;, [2, 3]]a[1] = &quot;99&quot;;a[2][0] = 4;console.log(a);// [0, &quot;99&quot;, [4, 3]]console.log(b);//  [&quot;1&quot;, [2, 3]]</code></pre><p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。</p><p>但是该方法有以下几个问题：</p><p>（1）会忽略 <code>undefined</code></p><p>（2）会忽略 <code>symbol</code></p><p>（3）不能序列化函数</p><p>（4）不能解决循环引用的对象</p><p>（5）不能正确处理<code>new Date()</code></p><p>（6）不能处理正则</p><p>其中（1）（2）（3） <code>undefined</code>、<code>symbol</code> 和函数这三种情况，会直接忽略。</p><pre><code class="html">// saucxslet obj = {    name: &#39;saucxs&#39;,    a: undefined,    b: Symbol(&#39;saucxs&#39;),    c: function() {}}console.log(obj);// {//  name: &quot;saucxs&quot;,//  a: undefined,//  b: Symbol(saucxs),//  c: ƒ ()// }let b = JSON.parse(JSON.stringify(obj));console.log(b);// {name: &quot;saucxs&quot;}</code></pre><p>其中（4）循环引用会报错</p><pre><code class="html">// saucxslet obj = {    a: 1,    b: {        c: 2,        d: 3    }}obj.a = obj.b;obj.b.c = obj.a;let b = JSON.parse(JSON.stringify(obj));// Uncaught TypeError: Converting circular structure to JSON</code></pre><p>其中(5)* <code>new Date</code> 情况下，转换结果不正确。</p><pre><code class="html">// saucxsnew Date();// Mon Dec 24 2018 10:59:14 GMT+0800 (China Standard Time)JSON.stringify(new Date());// &quot;&quot;2018-12-24T02:59:25.776Z&quot;&quot;JSON.parse(JSON.stringify(new Date()));// &quot;2018-12-24T02:59:41.523Z&quot;解决方法转成字符串或者时间戳就好了。// saucxslet date = (new Date()).valueOf();// 1545620645915JSON.stringify(date);// &quot;1545620673267&quot;JSON.parse(JSON.stringify(date));// 1545620658688</code></pre><p>其中（6）正则情况下</p><pre><code class="html">// saucxslet obj = {    name: &quot;saucxs&quot;,    a: /&#39;123&#39;/}console.log(obj);// {name: &quot;saucxs&quot;, a: /&#39;123&#39;/}let b = JSON.parse(JSON.stringify(obj));console.log(b);// {name: &quot;saucxs&quot;, a: {}}</code></pre><p>PS：为什么会存在这些问题可以学习一下 JSON。</p><p>除了上面介绍的深拷贝方法，</p><p>常用的还有<code>jQuery.extend()</code> 和 <code>lodash.cloneDeep()</code>，后面文章会详细介绍源码实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th>和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td>赋值</td><td>是</td><td>改变会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>浅拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变会使原数据一起改变</td></tr><tr><td>深拷贝</td><td>否</td><td>改变不会使原数据一起改变</td><td>改变不会使原数据一起改变</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEXO的图片上传问题</title>
    <link href="undefined2019/11/23/%E9%94%99%E8%AF%AF/HEXO%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/"/>
    <url>2019/11/23/%E9%94%99%E8%AF%AF/HEXO%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题状况"><a href="#问题状况" class="headerlink" title="问题状况"></a>问题状况</h2><img src="/2019/11/23/%E9%94%99%E8%AF%AF/HEXO%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF.png" srcset="undefined" class="" title="图片上传错误 [图片上传错误]"><p>如果你的hexo安装了img插件但是还是不显示，后台输出地址404。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li><p>首先找到你的node_modules\hexo-asset-image@0.0.5@hexo-asset-image和node_modules\hexo-asset-image这两个文件包，删除。</p></li><li><p>接下来</p><pre><code class="npm"> npm install https://github.com/CodeFalling/hexo-asset-image --save</code></pre><p> 执行这条指令。</p></li><li><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><pre><code class="js"> &#39;use strict&#39;; var cheerio = require(&#39;cheerio&#39;); // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string function getPosition(str, m, i) { return str.split(m, i).join(m).length; } var version = String(hexo.version).split(&#39;.&#39;); hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){ var config = hexo.config; if(config.post_asset_folder){         var link = data.permalink;     if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)     var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;     else     var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;     // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.     var endPos = link.lastIndexOf(&#39;/&#39;) + 1;     link = link.substring(beginPos, endPos);     var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];     for(var i = 0; i &lt; toprocess.length; i++){     var key = toprocess[i];     var $ = cheerio.load(data[key], {         ignoreWhitespace: false,         xmlMode: false,         lowerCaseTags: false,         decodeEntities: false     });     $(&#39;img&#39;).each(function(){         if ($(this).attr(&#39;src&#39;)){             // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.             var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);             if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;             !/^\s*\//.test(src)) {             // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.             // In addition, to support multi-level local directory.             var linkArray = link.split(&#39;/&#39;).filter(function(elem){                 return elem != &#39;&#39;;             });             var srcArray = src.split(&#39;/&#39;).filter(function(elem){                 return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;             });             if(srcArray.length &gt; 1)                 srcArray.shift();             src = srcArray.join(&#39;/&#39;);             $(this).attr(&#39;src&#39;, config.root + link + src);             console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);             }         }else{             console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);             console.info&amp;&amp;console.info($(this));         }     });     data[key] = $.html();     } } });</code></pre></li><li><p>打开_config.yml文件，修改下述内容</p><pre><code class="js"> post_asset_folder: true</code></pre></li></ol><h2 id="问题推测"><a href="#问题推测" class="headerlink" title="问题推测"></a>问题推测</h2><ol><li>出现了多个版本的包出现了混乱</li><li>文件没有修改。</li></ol>]]></content>
    
    
    <categories>
      
      <category>错误</category>
      
      <category>博客</category>
      
      <category>图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="undefined2019/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <url>2019/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><ol><li><p>局域网 覆盖范围小 自己花钱购买设备 带宽固定 自己维护 100米 带宽 10M 100M 1000M<br> 设计的时候应该分层设计，一个交换机作为汇聚层（作为中心，接入其他接入层交换机），其余的交换机作为接入层（接入每台电脑，要求接口多）；<br> 接入层的交换机都连接到汇聚层交换机上，并且汇聚层每条线的带宽应该等于接入层带宽总和，这样既不会浪费，也不会限制。</p></li><li><p>广域网 距离远 花钱租带宽</p></li><li><p>Internet ISP 自己的机房 对网民提供访问Internet连接</p></li></ol><h2 id="规划IP地址介绍MAC地址"><a href="#规划IP地址介绍MAC地址" class="headerlink" title="规划IP地址介绍MAC地址"></a>规划IP地址介绍MAC地址</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址分为网络部分和主机部分，具体如何分辨看子网掩码例如：</p><p>IP        13.0.0.0<br>子网掩码  255.0.0.0</p><p>那么13就是网络部分0.0.0是主机部分，加入子网掩码是255.255那么13.0就是网络部分，0.0就是主机部分。</p><p>互联网连接的路由器的地址往往是这个网段的第一个地址。<br>如果你这个电脑想要给其他网段传输信息，需要配置网关，这个网关就是路由器的IP地址</p><img src="/2019/11/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Cip%E5%9C%B0%E5%9D%80.png" srcset="undefined" class="" title="计算机网络ip地址 [计算机网络ip地址]"><p>如图，ip地址的网络部分就是前三个部分，主机就是最后一个部分。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>在计算机出厂的时候就布置到芯片里面了你自己的MAC地址可以通过cmd窗口输入ipconfig /all来查看<br>物理地址就是MAC地址。<br>计算机网卡用MAC地址，计算机用IP地址。</p><h2 id="数据包和数据帧"><a href="#数据包和数据帧" class="headerlink" title="数据包和数据帧"></a>数据包和数据帧</h2><p>数据包：源地址，目的地址<br>数据帧：数据包+源物理地址+路由器物理地址<br>&lt;% asset_img 数据包和数据帧.png 数据包和数据帧 %&gt;<br>从15网段转到13网段，需要用到路由器，而从主机转发到路由器需要物理地址m4和m5</p><p>用DNS解析网址，获取网站的ip地址：13.0.0.2<br>&lt;% asset_img 互联网.png 互联网 %&gt;<br>（绿色的字母代表路由器）<br><strong>每经过一个路由器</strong>就需要这个路由器更改物理地址一个新的包含这个路由器的物理地址和下一个路由器的地址<br>（如果全球的计算机都通过交换机连就只需要一个地址了，(●’◡’●)）</p><p>一个数据包只能包含1500个字节，因此需要把页面切割，切割为一个个数据包能够传输的数据。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String类源代码渗析</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/String%E7%B1%BB%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B8%97%E6%9E%90/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/String%E7%B1%BB%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B8%97%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="相等性的比较（-）"><a href="#相等性的比较（-）" class="headerlink" title="相等性的比较（==）"></a>相等性的比较（==）</h2><ol><li>对于原生数据类型来说，比较的是左右两边的值是否相等。</li><li>对于引用类型来说，比较左右两边的引用是否指向同一个对象，或者说左右两<br>边的引用地址是否相同。</li><li>java.lang.Object 类。 java.lang 包在使用的时候无需显式导入，编译时由编译器自动<br>帮助我们导入。</li><li>API （Application Programming Interface），应用编程接口。</li><li>当打印引用时，实际上会打印出引用所指对象的 toString()方法的返回值，因为每个<br>类都直接或间接地继承自 Object，而 Object 类中定义了 toString()，因此每个类都有<br>toString()这个方法。</li></ol><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>该方法定义在 Object 类当中，因此 Java 中的每个类都具有该方法，对于 Object 类的 equals()方法来说，它是判断调用 equals()方法的引用与传进来的引用是否一致，即这两个引用是否指向的是同一个对象。对于 Object 类的 equals()方法来说，它等价于==。</p><pre><code class="java">public class StringTest { public static void main(String[] args) {  String str = new String(&quot;aa&quot;);  String str2 = new String(&quot;aa&quot;);  System.out.println(str.equals(str2));  System.out.println(&quot;-----------------&quot;);  String str3 = &quot;aa&quot;;  String str4 = &quot;aa&quot;;  System.out.println(str4.equals(str));  System.out.println(str3.equals(str2));  System.out.println(&quot;-----------------&quot;);  Object object = new Object();  Object object2 = new Object();  System.out.println(object.equals(object2));  }}</code></pre><p>输出结果：</p><pre><code class="text">true-----------------truetrue-----------------false</code></pre><h3 id="Object中的equals方法"><a href="#Object中的equals方法" class="headerlink" title="Object中的equals方法"></a>Object中的equals方法</h3><p>为什么第四个输出结果为false呢，下面我们看一下java中Object类的equals方法的源代码。</p><ol><li><p>首先先打开你电脑中的jdk，把src压缩包解压。</p></li><li><p>然后我们进入到src\java\lang中Object.java中的equals方法。</p><pre><code class="java"> public boolean equals(Object obj) {     return (this == obj); }</code></pre></li><li><p>等号代表this指向的地址和obj指向的地址是相同的，也就是说这==两个对象是同一个对象==，但是object和object2不是同一个对象所以第四个结果是false。</p></li><li><p>如果将第四个输出改为以下的情况</p><pre><code class="java"> System.out.println(object.equals(object));</code></pre><p>结果是：true</p></li></ol><h4 id="String中的equals方法"><a href="#String中的equals方法" class="headerlink" title="String中的equals方法"></a>String中的equals方法</h4><p>看完上述方法后我们会疑惑为什么第一个输出为true昵？<br>那说明String一定把equals方法Over Read（重写）了，那我们来看一下String类中的equals方法。</p><pre><code class="java">    public boolean equals(Object anObject) {        if (this == anObject) {            return true;        }        if (anObject instanceof String) {            String anotherString = (String)anObject;            int n = value.length;            if (n == anotherString.value.length) {                char v1[] = value;                char v2[] = anotherString.value;                int i = 0;                while (n-- != 0) {                    if (v1[i] != v2[i])                        return false;                    i++;                }                return true;            }        }        return false;    }</code></pre><ol><li>先看第一个if，里面的判断是如果自己等于自己，那么就直接返回true，后面都不用判断了。</li><li>如果不是不等的话，我们看一下第二个if，里面的条件是anObject是不是String的实例，也就是说anObject是不是一个字符串，如果不是字符串直接返回false。</li><li>如果是字符串类型，就显示的向下类型转换成String类。接下来一个字符一个字符比较，判断当前字符串与传进来的字符串的内容是否一致。</li><li>所以第第一个结果是true，==对于 String 对象的相等性判断来说，请使用 equals()方法，而不要使用==。</li></ol><h4 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h4><pre><code class="java">public class EqualsTest {    public static void main(String[] args) {        Student s1 = new Student(&quot;zhangsan&quot;);        Student s2 = new Student(&quot;zhangsan&quot;);        System.out.println(s1 == s2);        System.out.println(s1.equals(s2));    }}class Student{    String name;    public Student(String name) {        this.name = name;    }}</code></pre><p>结果如下</p><pre><code class="text">falsefalse</code></pre><ol><li><p>第一个输出结果和第二个输出实际上是相等的，都代表==。</p></li><li><p>程序如下</p></li></ol><pre><code class="java">public boolean equals(Object anObject) {//模仿String中的equals方法重写equals方法    if(this == anObject) {        return true;    }    if(anObject instanceof Student) {        Student student = (Student)anObject;        if(student.name.equals(this.name)) {            return true;        }    }    return false;}</code></pre><p>在Student类中重写equals方法来实现内容相同就相等。</p><h3 id="String详解"><a href="#String详解" class="headerlink" title="String详解"></a>String详解</h3><ol><li><p>String 是常量，其对象一旦创建完毕就无法改变。当使用+拼接字符串时，会生成新的 String 对象，而不是向原有的 String 对象追加内容。</p></li><li><p>String Pool（字符串池）</p></li><li><p>采用字面值方式赋值</p><pre><code class="java">     String s = “aaa”;</code></pre><p> 1) 查找 String Pool 中是否存在“aaa”这个对象，如果不存在，则在 String Pool 中创建一个“aaa” 对象，然后将 String Pool 中的这个“aaa”对象的地址返回来，赋给引用变量 s，这样 s 会指向 String Pool 中的这个“aaa”字符串对象<br> 2) 如果存在，则不创建任何对象，直接将 String Pool 中的这个“aaa”对象地址返回来，赋给 s 引用。</p></li><li><p>采用new的方式赋值</p></li></ol><pre><code class="java"> String s = new String(“aaa”);</code></pre><p>1) 首先在 String Pool 中查找有没有“aaa”这个字符串对象，如果有，则不在 String Pool中再去创建“aaa”这个对象了，直接在堆中（heap）中创建一个“aaa”字符串对象，然后将堆中的这个“aaa”对象的地址返回来，赋给 s 引用，导致 s 指向了堆中创建的这个“aaa”字符串对象。<br>2) 如果没有，则首先在 String Pool 中创建一个“aaa“对象，然后再在堆中（heap）创<br>建一个” aaa“对象，然后将堆中的这个” aaa“对象的地址返回来，赋给 s 引用，<br>导致 s 指向了堆中所创建的这个” aaa“对象。</p><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h3><p>我们先看一下java的官方文档</p><p>public String intern()<br>Returns a canonical representation for the string object.<br>A pool of strings, initially empty, is maintained privately by the class String.<br>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</p><p>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.</p><p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p><p>Returns:<br>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p><p>我来用实例解释一下上述文档<br>假如String pool中有”Hello”字符串<br>我们输入”Hello”.intern()返回的是字符串池中的hello对象<br>假设没有”Hello”字符串<br>我们输入”Hello”.intern()系统会现在字符串池中创建”Hello”，然后返回这个”Hello”</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ol><li><p>StringBuffer同样位于java.lang包的下面，是final class不能被继承。</p></li><li><p>和Sting的关系：String是常量而StringBuffer是变量，我们可以更改StringBuffer的值，追加字符串。</p><pre><code class="java"> public class StringBufferTest {     public static void main(String[] args) {         StringBuffer buffer = new StringBuffer();         buffer.append(&quot;hello&quot;).append(&quot; world&quot;).append(&quot; welcome&quot;).append(100).append(false);         String result = buffer.toString();         System.out.println(result);         String s = &quot;abc&quot;;         int a = 100;         boolean b = true;         String str = s + a + b;         System.out.println(str);         int c = 200;         System.out.println(a + c);         System.out.println(100 + 200);         System.out.println(&quot;100&quot; + 200);         //buffer = buffer.append(&quot;hello&quot;);上下两种表示形式是一样的并且追加后的buffer还是原来的buffer对象并没有改变         //buffer.append(&quot; world&quot;);         //buffer.append(&quot; welcome&quot;);     } }</code></pre><p> 输出的结果是：<br> hello world welcome100false<br> abc100true<br> 300<br> 300<br> 100200</p></li><li><p>共有四种构造方法，这里我们使用无参的，我们可以用toString方法将StringBuffer转换成String。append里面的参数不是字符串类型，也会给转换为字符串。</p></li></ol><h4 id="字符串的-法操作"><a href="#字符串的-法操作" class="headerlink" title="字符串的+法操作"></a>字符串的+法操作</h4><ol><li>字符串之间的+代表拼接并不是加法运算，<strong>只要加法运算中有一项为字符串，系统会把所有的变量全部转换为字符串。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解面向对象程序设计</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象程序设计（Object-Oriented-Programming，-OOP；-Object-Oriented-Design-OOD）"><a href="#面向对象程序设计（Object-Oriented-Programming，-OOP；-Object-Oriented-Design-OOD）" class="headerlink" title="面向对象程序设计（Object Oriented Programming， OOP； Object Oriented Design, OOD）"></a>面向对象程序设计（Object Oriented Programming， OOP； Object Oriented Design, OOD）</h2><p>什么是面向对象？ 在面向对象程序设计中有两个重要的概念：类（class）与对象（object）。</p><ol><li><p>类： 类是一种抽象的概念， 类中包含了数据（通常使用名词来表示） 与对数据的操纵（通常使用动词来表示）。 比如说人就是一种抽象的概念，人具有姓名、年龄、身高等数据，还有吃饭、跑步等操纵数据的动作。</p></li><li><p>对象：对象是一种具体的概念，是类的一种具体表示方式。比如说人是一个类，而张三、李四、王五等具体的人就是对象。</p></li><li><p>类所包含的内容，类一共包含两部分内容：</p></li></ol><p>a) 数据，数据在类中称作属性（Property 或者 Attribute） 或者叫成员变量（Member variable）。</p><p>b) 对数据的操纵，这种操纵在类中称作方法（method）。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java设计思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基本语句</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1、流程控制语句if的用法"><a href="#1、流程控制语句if的用法" class="headerlink" title="1、流程控制语句if的用法"></a>1、流程控制语句if的用法</h2><ol><li><p>第一种形式：</p><pre><code class="java"> if(布尔表达式){ //待执行的代码 }</code></pre><p> 第二种形式：</p><pre><code class="java"> if(布尔表达式){ //待执行的代码 } else{ //待执行的代码 }</code></pre><p> 第三种形式：</p><pre><code class="java"> if(布尔表达式){ //待执行的代码 } else if(布尔表达式){ //待执行的代码 } else if(布尔表达式){ //待执行的代码 } else{ //待执行的代码 }</code></pre></li><li><p>switch 语句，使用形式为：</p><pre><code class="java"> switch(变量) //此处的变量类型就目前所学内容来看，只能为 4 种类型： byte, short, int,char。 { case 常量 1: //待执行的代码 break; case 常量 2: //待执行的代码 break; case 常量 3: //待执行的代码 break; default： //待执行的代码 }</code></pre><p> 虽然 case 语句中的 break 是可选的，但在绝大多数情况下，如果没有 break，程序的逻辑就会发生错误，因此，通常情况下都需要加上 break。</p></li></ol><h2 id="2、循环控制语句"><a href="#2、循环控制语句" class="headerlink" title="2、循环控制语句"></a>2、循环控制语句</h2><ol><li><p>Java 中的循环控制语句一共有 3 种，分别是 while， do… while 以及 for 循环。</p></li><li><p>while 循环，形式为：</p><pre><code class="java"> while(布尔表达式) { //待执行的代码 }</code></pre></li><li><p>do…while 循环，新式为：</p><pre><code class="java"> do { //待执行的代码 } while(布尔表达式);</code></pre></li><li><p>while 与 do…while 之间的区别：如果布尔表达式的第一次判断就为 false，那么 while 循环一次也不执行； do…while 循环则会执行一次。 如果布尔表达式第一次判断为 true，那么 while 循环与 do…while 循环等价。</p></li><li><p>for 循环（使用最多的一种循环），形式为：</p><pre><code class="java"> for(变量初始化; 条件判断; 步进) { //待执行的代码 }</code></pre><p> for 循环的执行过程：</p><p> 1） 执行变量初始化。</p><p> 2） 执行条件判断。如果条件判断结果为假，那么退出 for 循环，开始执行循环后面的代码；如果条件判断为真，执行 for 循环里面的代码。</p><p> 3） 执行步进。</p><p> 4） 重复步骤 2。</p></li></ol><h2 id="3、break语句与continue语句"><a href="#3、break语句与continue语句" class="headerlink" title="3、break语句与continue语句"></a>3、break语句与continue语句</h2><ol><li>break 语句： 经常用在循环语句中，用于跳出整个循环，执行循环后面的代码。</li><li>continue 语句：经常用在循环语句中，用于跳出当前的这个循环（或者是跳出本次循环），开始下一次循环的执行。</li><li>break 与 continue 可以搭配标签使用， 在实际开发中，根本没有人会将 break 与 continue搭配标签来使用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符 Operator</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E8%BF%90%E7%AE%97%E7%AC%A6-Operator/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E8%BF%90%E7%AE%97%E7%AC%A6-Operator/</url>
    
    <content type="html"><![CDATA[<h2 id="1、运算精度等级"><a href="#1、运算精度等级" class="headerlink" title="1、运算精度等级"></a>1、运算精度等级</h2><ol><li><p>当有若干个变量参与运算时， 结果类型取决于这些变量中表示范围最大的那个变量类型。比如，参与运算的变量中，有整型 int，有双精度浮点型 double，有短整型 short，那么最后的结果类型就是 double。</p></li><li><pre><code class="java"> int a = 1; int b = 2; double c = (double)a / b;``` 上面的代码中， a 与 b 都是整型，但是通过(double)a 这种转换将 a 转换为一个匿名的变量，该变量的类型是 double，但是要注意： a 本身依旧是 int 类型，而不是 double 类型，这样， (double)a / b 就是 double 类型除以 int 类型，结果自然是 double 类型。</code></pre></li><li><p>取模运算符：使用%表示。</p><pre><code class="java"> int a = 5; int b = 3; int c = a % b;</code></pre><p> 上面代码的运行结果是 2，因为 5 除以 3 结果是 1 余 2。<br> 取模的规律：取模的结果符号永远与被除<br> 数的符号相同</p><pre><code class="java"> int a = 5; int b = -3; int c = a % b;</code></pre><p> 被除数是 5，那么取模的结果是 2</p><pre><code class="java"> int a = -5; int b = 3; int c = a % b;</code></pre><p> 被除数是-5，那么取模的结果是-2。</p></li></ol><h2 id="2、运算符"><a href="#2、运算符" class="headerlink" title="2、运算符"></a>2、运算符</h2><h3 id="（1）关系运算符"><a href="#（1）关系运算符" class="headerlink" title="（1）关系运算符"></a>（1）关系运算符</h3><p>大于（&gt;）、小于（&lt;）、等于（==）、不等于（!=）、大于等于（&gt;=）、小于等于（&lt;=），关系运算的结果是个 boolean 值。</p><h3 id="（2）逻辑运算符"><a href="#（2）逻辑运算符" class="headerlink" title="（2）逻辑运算符"></a>（2）逻辑运算符</h3><p>重点讲解两个，逻辑运算符本身也返回一个 boolean 值。</p><p>1） 逻辑与： 使用&amp;&amp;表示， 逻辑与是个双目运算符（即有两个操作数的运算符）， 只有当两个操作数都为真的时候，结果才为真； 其余情况结果均为假。 逻辑与表示的并且的意思。</p><p>2） 逻辑或：使用||表示，逻辑或也是个双目运算符，只有当两个操作数都为假的时候，结果才为假；其余情况结果均为真。 逻辑或表示或者的意思。</p><h3 id="（3）关于逻辑运算符的短路特性"><a href="#（3）关于逻辑运算符的短路特性" class="headerlink" title="（3）关于逻辑运算符的短路特性"></a>（3）关于逻辑运算符的短路特性</h3><p>1） 逻辑与： 如果第一个操作数为 false，那么结果肯定就是 false，所以在这种情况下，将不会执行逻辑与后面的运算了，即发生了短路。</p><p>2） 逻辑或： 如果第一个操作数为 true，那么结果肯定就是 true，所在在这种情况下，将不会执行逻辑或后面的运算了，即发生了短路。</p><h3 id="（4）关于变量的自增与自减运算"><a href="#（4）关于变量的自增与自减运算" class="headerlink" title="（4）关于变量的自增与自减运算"></a>（4）关于变量的自增与自减运算</h3><ol><li><p>关于</p><pre><code class="java"> int b = a++;</code></pre><p> 作用是将 a 的值先赋给 b，然后再让 a 自增 1。</p></li><li><p>关于</p><pre><code class="java"> int b = ++a</code></pre><p> 作用是将 a 的值先自增 1，然后将自增后的结果赋给 b。</p></li></ol><h2 id="（5）条件运算符"><a href="#（5）条件运算符" class="headerlink" title="（5）条件运算符"></a>（5）条件运算符</h2><p>条件运算符（三元表达式），其形式为：type d = a ? b : c; 具体化形式为：</p><pre><code class="java"> int d = 2 &lt; 1 ? 3 : 4;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注释</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E6%B3%A8%E9%87%8A/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是给人看的，不是给计算机看的。 Java 中共有 3 种类型的注释：</p><ol><li><p>单行注释： 以//开头， //后面的所有内容均被当作注释处理。</p></li><li><p>多行注释： 以/* 开头，以 * /结束，中间的所有内容均被当作注释处理。 多行注释来源于C/C++。 关于多行注释，<font color=red>需要注意的是，多行注释不能嵌套。</font></p></li><li><p>另一种多行注释。 用于产生 Java Doc 帮助文档。 暂且不介绍</p></li></ol><pre><code class="java">///**//***/</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生数据类型(Primitive Data Type)</title>
    <link href="undefined2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Primitive-Data-Type/"/>
    <url>2019/11/22/%E5%90%8E%E7%AB%AF/Java/%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Primitive-Data-Type/</url>
    
    <content type="html"><![CDATA[<h2 id="轻量级编辑器"><a href="#轻量级编辑器" class="headerlink" title="轻量级编辑器"></a>轻量级编辑器</h2><p>Windows：notepad、editplus、ultraedit、gvim</p><p>Linux：vi、vim、gedit</p><h2 id="1、Java-中的数据类型分为两大类"><a href="#1、Java-中的数据类型分为两大类" class="headerlink" title="1、Java 中的数据类型分为两大类"></a>1、Java 中的数据类型分为两大类</h2><p>1） 原生数据类型 （Primitive Data Type）</p><p>2） 引用类型（对象类型） （Reference Type）</p><h2 id="2、变量与常量"><a href="#2、变量与常量" class="headerlink" title="2、变量与常量"></a>2、变量与常量</h2><p>所谓常量，就是值不会变化的量；所谓变量，就是值可以变化的量。</p><h3 id="（1）如何定义变量"><a href="#（1）如何定义变量" class="headerlink" title="（1）如何定义变量"></a>（1）如何定义变量</h3><p>变量类型 变量名;</p><pre><code class="java">int a;</code></pre><h3 id="（2）如何为变量赋值"><a href="#（2）如何为变量赋值" class="headerlink" title="（2）如何为变量赋值"></a>（2）如何为变量赋值</h3><p>变量名 = 变量值;</p><pre><code class="java">a = 2;</code></pre><p>= 表示赋值，将等号右边的值赋给了左边的变量。</p><p>Java 中使用==表示相等，等价于数学中的=。</p><h3 id="（3）综合变量定义与赋值"><a href="#（3）综合变量定义与赋值" class="headerlink" title="（3）综合变量定义与赋值"></a>（3）综合变量定义与赋值</h3><p>变量类型 变量名;</p><p>变量名 = 变量值;</p><pre><code class="java">int a;a = 1;</code></pre><p>可以将上面两个步骤合二为一：<br>变量类型 变量名 = 变量值;</p><pre><code class="java">int a = 1;</code></pre><pre><code class="java">package JavaBase.PrimitiveDataType;public class Vairable {    public static void main(String[] args) {        int a = 1;        System.out.println(a);        System.out.println(&quot;a&quot;);    }}</code></pre><p><code>结果是：1a</code></p><h2 id="3、变量名"><a href="#3、变量名" class="headerlink" title="3、变量名"></a>3、变量名</h2><p>在 Java 中，变量名以下划线、字母、 $符号开头，并且后跟下划线、字母、 $符号以及数字。 总之，<font color=red>Java 中的变量名不能以数字开头。</font></p><h3 id="（1）关于计算机系统中的数据表示位"><a href="#（1）关于计算机系统中的数据表示位" class="headerlink" title="（1）关于计算机系统中的数据表示位"></a>（1）关于计算机系统中的数据表示位</h3><p>bit（只有 0， 1 两种状态），是计算机系统中的最小数据表示单位。<br>字节： byte， 1 byte = 8 bit。<br>1 KB = 1024 Byte （1Kg = 1000g，与计算机系统不同）<br>1 MB = 1024 KB<br>1 GB = 1024 MB</p><h2 id="4、原生数据类型"><a href="#4、原生数据类型" class="headerlink" title="4、原生数据类型"></a>4、原生数据类型</h2><ol><li><p>Java 中的原生数据类型共有 8 种</p><p> 1） 整型：使用 int 表示。（32 位）</p><p> 2） 字节型：使用 byte 表示。（表示-128～127 之间的 256 个整数）。</p><p> 3）短整型：使用 short 表示。（16 位）</p><p> 4） 长整型：使用 long 表示。（64 位）</p><p> 5）单精度浮点型：使用 float 表示。 所谓浮点型，指的就是小数，比如 1.2。</p><p> 6）双精度浮点型：使用 double 表示。 双精度浮点型表示的数据范围要比单精度浮点型大。</p><p> 7） 字符型：使用 char 表示（char 是 character 的缩写）。所谓字符， 就是单个的字符表示，比如字母 a，或者中文张，外面用单引号包围上。比如 char a = ‘B’; char b = ‘张’;</p><p> 8）布尔类型，使用 boolean 表示。 布尔类型只有两种可能值，分别是 true 与 false。</p></li><li><p>Java 中的所有浮点类型默认情况下都是 double。 不能将 double 类型的值赋给 float 类型的变量，即便该 double 类型的值处于 float 类型的范围内也是不可以的。总之，能否成功赋值取决于等号右边的值类型与等号左边的变量类型是否一致。</p></li><li><p>如何将 double 类型的值赋给 float 类型的变量？ 答案就是(1)强制类型转换，将 double 类型的值强制转换为 float 类型。 (2)使用 java 预言的支持。强制转换的语法： 类型 变量名 = （类型） 变量值;</p></li><li><p>变量在使用前必须要赋值；变量必须要声明其类型方可使用；变量在使用前必须要定义，并且只能定义一次。</p></li><li><p>如下代码无法通过编译：</p><pre><code class="java"> int a = 1; short b = a;</code></pre><p> a 是 int 类型， b 是 short 类型， int 类型表示的数据范围要比 short 类型大，不能将表示范围大的值赋给表示范围小的变量。</p></li><li><p>如下代码可以通过编译：</p><pre><code class="java"> short a = 1; int b = a;</code></pre><p> a 是 short 类型， b 是 int 类型， int 类型表示的数据范围要比 short 类型大，可以将表示范围小的值赋给表示范围大的变量。</p></li><li><p>总结：可以将表示范围小的值赋给表示范围大的变量；但不能直接将表示范围大的值赋给表示范围小的变量，只能通过强制类型转换实现。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java简介</title>
    <link href="undefined2019/11/21/%E5%90%8E%E7%AB%AF/Java/Java%E7%AE%80%E4%BB%8B/"/>
    <url>2019/11/21/%E5%90%8E%E7%AB%AF/Java/Java%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1、Java的版本"><a href="#1、Java的版本" class="headerlink" title="1、Java的版本"></a>1、Java的版本</h2><p>Java SE：Java Standard Edition         基础版本</p><p>Java ME：Java Micro Edition           手机开发</p><p>Java EE:：Java Enterprise Edition       企业开发</p><p>Java是由Sun公司推出的（后被Oracle公司收购）。<br>收购价格：74亿美金<br>J2SE、J2ME、J2EE</p><h2 id="2、下载JDK"><a href="#2、下载JDK" class="headerlink" title="2、下载JDK"></a>2、<a href="https://www.java.com/zh_CN/download/windows-64bit.jsp" target="_blank" rel="noopener">下载JDK</a></h2><p>JDK：Java Development Kit（Java开发包）(Java开发必备）</p><p>JRE：Java Runtime Environment（java执行环境）</p><p>JDK包含了JRE</p><p>jdk 1.4 ，jdk1.5（5.0），jdk1.6（6.0）</p><p>jdk1.5（5.0）：Tiger，老虎</p><p>jdk1.6（6.0）：Mustang，野马</p><p>最新免费版是1.8</p><h2 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h2><p>设定环境变量（可以是用户变量，也可以是系统变量)，指向JDK安装目录中的bin目录</p><p>CLASSPATH：D:\Java\jdk1.8.0_191\lib</p><p>Path：D:\Java\jdk1.8.0_191\bin</p><p>通过运行，输入cmd或powershell打开窗口，输入java -version，显示出Java版本信息</p><h2 id="4、Java程序的执行过程"><a href="#4、Java程序的执行过程" class="headerlink" title="4、Java程序的执行过程"></a>4、Java程序的执行过程</h2><p>可以直接使用windows记事本来编写Java程序，也可以使用Editplus，UltraEdit等高级文本编辑工具编写Java程序，还可以使用专业的IDE（Integrated Devellopment Environment）编写。</p><p>第一次使用，我们使用记事本实现一个Hello World的Java程序。所有的Java代码，其后缀都是以java结尾。</p><p>Java程序的执行过程分为两步：</p><ol><li>编译  javac 文件名.java</li><li>执行  java 文件名</li></ol><p>Class文件是字节码文件，程序最终执行的就是这个字节（bytecode）文件。</p><p><strong>Java是跨平台的语言，真正执行的不是二进制，而是字节码。<br>JVM（Java Virtual Machine，Java虚拟机）<br>Java是跨平台的，而JVM不是跨平台的（JVM是由C语言编写的）。<br>Java之所以能做到跨平台，本质原因在于JVM不是跨平台的。</strong></p><pre><code class="java">public class Test{    public static void main(String[] args){        System.out.println(&quot;Hello Word&quot;);    }}</code></pre><p><img src="https://img-blog.csdnimg.cn/20190227113749540.png" srcset="undefined" alt="HelloWorld"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/21/%E5%8D%9A%E5%AE%A2/hello-world/"/>
    <url>2019/11/21/%E5%8D%9A%E5%AE%A2/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
      <category>HEXO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="undefined2019/11/21/%E5%8D%9A%E5%AE%A2/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>2019/11/21/%E5%8D%9A%E5%AE%A2/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h2><p>这是我的第一个博客，会记录一些我的学习经历，激励并警醒以后的自己</p><h2 id="主题参考指南"><a href="#主题参考指南" class="headerlink" title="主题参考指南"></a><a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE" target="_blank" rel="noopener">主题参考指南</a></h2><h2 id="Hevo网址"><a href="#Hevo网址" class="headerlink" title="Hevo网址"></a><a href="https://hexo.io/zh-cn/docs" target="_blank" rel="noopener">Hevo网址</a></h2><p><code>一定要好好学习!!!!</code></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>