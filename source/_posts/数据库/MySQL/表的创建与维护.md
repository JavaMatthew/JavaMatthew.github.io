---
title: 表的创建与维护
p: 数据库/MySQL/表的创建与维护
date: 2020-04-26 11:14:04
tags: MySQL
categories: MySQL
---
## 表

- 表是关系数据库的核心
- 表=关系
- 表是记录的集合
- 二维表格模型易于人类理解
- MySQL默认存储引擎都是基于行（记录）存储
- 每行记录都是基于列进行组织的

### MySQL中数据库与表之间的关系

{% asset_img 表和数据库的关系.png 表和数据库的关系%}

### CREATE TABLE语法

```sql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
(create_definition,...)
[table_options]
[partition_options]
create_definition:
col_name column_definition
| [CONSTRAINT [symbol]] PRIMARY KEY [index_type] 
(index_col_name,...)
[index_option] ...
| {INDEX|KEY} [index_name] [index_type] (index_col_name,...)
[index_option] ...
| [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY]
[index_name] [index_type] (index_col_name,...)
[index_option] ...
| {FULLTEXT|SPATIAL} [INDEX|KEY] [index_name] 
(index_col_name,...)
[index_option] ...
| [CONSTRAINT [symbol]] FOREIGN KEY
[index_name] (index_col_name,...) reference_definition
| CHECK (expr)
table_option:
ENGINE [=] engine_name
| AUTO_INCREMENT [=] value
| AVG_ROW_LENGTH [=] value
| [DEFAULT] CHARACTER SET [=] charset_name
| CHECKSUM [=] {0 | 1}
| [DEFAULT] COLLATE [=] collation_name
| COMMENT [=] 'string'
| CONNECTION [=] 'connect_string'
| DATA DIRECTORY [=] 'absolute path to directory'
| DELAY_KEY_WRITE [=] {0 | 1}
| INDEX DIRECTORY [=] 'absolute path to directory'
| INSERT_METHOD [=] { NO | FIRST | LAST }
| KEY_BLOCK_SIZE [=] value
| MAX_ROWS [=] value
| MIN_ROWS [=] value
| PACK_KEYS [=] {0 | 1 | DEFAULT}
| PASSWORD [=] 'string'
| ROW_FORMAT [=] 
{DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
| STATS_AUTO_RECALC [=] {DEFAULT|0|1}
| STATS_PERSISTENT [=] {DEFAULT|0|1}
| STATS_SAMPLE_PAGES [=] value
| TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]
| UNION [=] (tbl_name[,tbl_name]...)
```

### CREATE TABLE——外键约束

外键约束主要是为了保持数据一致性

```sql
[CONSTRAINT [symbol]] FOREIGN KEY
[index_name] (index_col_name, ...)
REFERENCES tbl_name (index_col_name,...)
[ON DELETE reference_option]
[ON UPDATE reference_option]
reference_option:
RESTRICT | CASCADE | SET NULL | NO ACTION
RESTRICT = NO ACTION
```

CASCADE：父表delete、update的时候，子表会delete、update掉关联记录；
SET NULL：父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；
RESTRICT：如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；
NO ACTION：同 RESTRICT，也是首先先检查外键；

### ALTER TABLE

```sql
ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name
[alter_specification [, alter_specification] ...]
[partition_options]

如需在表中添加列，请使用下面的语法:
ALTER TABLE table_name
ADD column_name datatype

如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：
ALTER TABLE table_name
DROP COLUMN column_name

要改变表中列的数据类型，请使用下面的语法：

MySQL / Oracle：
ALTER TABLE table_name
MODIFY COLUMN column_name datatype
```

## 分区表

• 将一个表或者索引分解为多个更小、更可管理的部分
• 目前只支持水平分区
• 局部分区索引
• 每个分区保存自己的数据与索引
• 分区列必须是唯一索引的一个组成部分

```sql
mysql> CREATE TABLE t1 (
-> col1 INT NOT NULL,
-> col2 DATE NOT NULL,
-> col3 INT NOT NULL,
-> col4 INT NOT NULL,
-> UNIQUE KEY (col1, col2)
-> )
-> PARTITION BY HASH(col3)
-> PARTITIONS 4;
ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table's partitioning function
```

### 分区类型支持

range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区
list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区
hash分区：基于给定的分区个数，把数据分配到不同的分区
key分区：类似于hash分区

```sql
CREATE TABLE t(
id INT PRIAMRY KEY
)ENGINE=INNODB
PARTITION BY RANGE (id)(
PARTITION p0 VALUES LESS THAN (10),
PARTITION p1 VALUES LESS THAN (20));

mysql> CREATE TABLE t (
-> a INT,
-> b INT)ENGINE=INNODB
-> PARTITION BY LIST(b)(
-> PARTITION p0 VALUES IN (1,3,5,7,9),
-> PARTITION p1 VALUES IN (0,2,4,6,8)
-> );

CREATE TABLE t_hash (
a INT,
b DATETIME
)ENGINE=InnoDB
PARTITION BY HASH (YEAR(b))
PARTITIONS 4;

mysql> CREATE TABLE t_key (
-> a INT,
-> b DATETIME)ENGINE=InnoDB
-> PARTITION BY KEY (b)     这里的key把b进行了内部hash所以也是int类型
-> PARTITIONS 4;

```

如果没有索引，也可以使用分区。
**分区条件必须是INT类型**

### COLUMNS分区

• COLUMNS分区支持以下的数据类型：
• 所有的整型类型，如INT，SMALLINT，TINYINT，BIGINT。FLOAT和DECIMAL则不予支持
• 日期类型，如DATE和DATETIME。其余的日期类型不予支持
• 字符串类型，如CHAR, VARCHAR, BINARY, 和VARBINARY。BLOB和TEXT类型不予支持

```sql
CREATE TABLE t_columns_range(
a INT,
b DATETIME
)ENGINE=INNODB
PARTITION BY RANGE COLUMNS (B)(
PARTITION p0 VALUES LESS THAN ('2009-01-01'),
PARTITION p1 VALUES LESS THAN ('2010-01-01')
);
```

### 子分区

• 在分区的基础上再进行分区
• 也称为复合分区
• 允许在RANGE和LIST的分区上再进行HASH或者是KEY的子分区

```sql
mysql> CREATE TABLE ts (a INT, b DATE)engine=innodb
-> PARTITION BY RANGE( YEAR(b) )
-> SUBPARTITION BY HASH( TO_DAYS(b) )
-> SUBPARTITIONS 2 (
-> PARTITION p0 VALUES LESS THAN (1990),
-> PARTITION p1 VALUES LESS THAN (2000),
-> PARTITION p2 VALUES LESS THAN MAXVALUE
-> );
Query OK, 0 rows affected (0.01 sec)
```

### 查询每个分区的记录数量

```sql
SELECT PARTITION_NAME, TABLE_ROWS
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'XXX';
```

### 查看是否通过分区表进行查询

```sql
mysql> EXPLAIN PARTITIONS SELECT * FROM Profile WHERE id=1\G;
*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: Profile
partitions: p1
type: const
possible_keys: PRIMARY
key: PRIMARY
key_len: 4
ref: const
rows: 1
Extra: 
1 row in set (0.00 sec)
```

Q：分区能提高性能吗？

不要因为数据量大而作分区，要为提高性能而使用分区
