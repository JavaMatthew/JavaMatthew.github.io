---
title: 服务器间通信
date: 2020-09-23 14:15:27
tags: Spring
categories: Spring
---
## 每个服务之间如何通信

> 所有的微服务都是独立的 Java进程跑在独立的虚拟机上，所有服务间的通信就是IPC（Inter Process Communication），已经有很多成熟的 方案，现在基本最通用的有两种方式

### 同步调用

- REST（JAX-RS，Spring Boot）
- RPC（Thrift，Dubbo）

同步调用比较见到那，一致性强，但是容易出调用问题，性能 体验上也会差些，特别是调用层次多的时候。一般REST基于HTTP，更容易实现，更容易被接收，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了HTTP的SDK救恩那个调用，所以相对使用的广一些。
RPC也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。

服务间通信  网络中只有字符串可以穿透防火墙
    REST Http 通信
    RPC  远程过程调用

### 异步消息调用

- Kafka
- Notify
- MessageQueue

异步消息的方式在分布式系统中有特别广泛的应用，他即能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息挤压不会冲垮被调用放，同时能保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据**最终一致性**；还有就是后台服务一般要实现**幂等性**，因为消息送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的Broker

## 如此多的服务，如何实现？

在微服务架构中，一般每一个服务都是有 多个拷贝，来做负载均衡。一个服务随时可能下线，也可能英规 临时访问压力增加 新的服务节点 。服务之间如何相互感知？服务如何管理？

这就是服务发现的问题了。一般有两类做法，也各有优缺点。基本都是通过Zookeeper等类似技术做服务之策信息的分布式管理。当服务上线时，服务提供者将自己的服务信息注册到ZK（或类似框架），并通过心跳维持长链接，试试更新链接信息。服务调用者通过ZK寻址，更具可定制算法，找到一个服务，还可以将服务信息缓存在本地以提高性能。当服务下线时，ZK会发通知给服务客户端。

### 主流的服务注册中心

- Eureka
- Consul
- Zookeeper

### 基于客户端的服务注册与发现

有点事架构简单，扩展灵活，支队服务注册器依赖。缺点事客户端要维护 所有调用服务的地址，有技术难度。一般大公司有成熟的内部框架支持，比如Dubbo。
{% asset_img 客户端服务注册流程.png 客户端服务注册流程%}

### 基于服务端的服务注册与发现

优点是简单，所有服务对于前台调用方透明，一般在小公司在与服务商部署的应用采用的比较多。
{% asset_img 服务端服务注册流程.png 服务端服务注册流程%}

## 服务挂了，符合解决？

前面提到，分布式最大的特性就是网络是不可靠的。通过微服务拆分能降低这个风险，不过如果没有特别的保障，结局肯定是噩梦。所以当 我们的系统是由一系列的服务调用链 组成的时候，我们必须确保 任一环节出问题都不至于影响整体链路。相应的手段有很多：

- 重试机制
    当服务发送请求10s后没有收到应答，再次发送请求
- 限流
    前端在高并发数量过多的时候直接进行限制90%请求，不给服务端
- 熔断机制
    后端在流量过多时进行返回，相当于后端的限流
- 负载均衡
- 降级（本地缓存）
    在请求过多时将处理不了的请求缓存到本地。