---
title: 持续集成
p: 后端/持续集成
date: 2020-10-12 20:42:30
tags: 持续集成
categories: [后端,持续集成]
---
## 持续集成

> 互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）

持续集成指的是，频繁地（一天多次）将代码集成到主干。他的好处有两个：

- 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。
- 防止分支大幅偏离主干。如果不是京城集成，主干有在不断更新，会导致以后集成的难度变大，甚至难以集成。

持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和源代码能否正确地集成在一起。
与持续集成相关的，还有两个概念，分别是持续交付和持续部署。

## 持续交付

> 持续交付(Continuous delivery)指的是，频繁地将软件的新版本，交付给质量团队或者用户，一共评审。如果评审通过，代码就进入生产阶段。

持续交付可以看做持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。

## 持续部署

> 持续部署(continuous deployment) 是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。

持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。
持续部署的亲体是能自动化完成测试、构建、部署等步骤。

持续部署的难点在于能够自动化的完成测试，需要测试人员有较高的水平能够使用脚本语言构建所有的使用场景完成测试，如果不能自动化测试就手动从类生产环境中部署到生产环境。

## 构建

> 所谓构建指的是将远吗转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等

常用的构建工具如下：

- Jenkins
- Travis
- Codeship
- Strider

Jenkins和Strider是开源软件，Travis和Codeship对于开源项目可以免费使用。他们都会讲构建和测试，在一次运行中执行。

## 使用GitLab持续集成

从GitLab8.0开始，GitLab CI就已经集成在GitLab中，我们只要在项目中添加一个`.gitlab-ci.yml`文件，然后添加一个Runner，即可进行持续集成。而且随着GitLab的升级，GitLab CI变得越来越强大

### Pipeline

一次pipeline其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。
任何提交或者Merge Request的合并都可以触发Pipeline

### Stages

Stages表示构建阶段，说白了就是上面提到的流程。我们可以在一次Pipline中定义多个Stages，这些Stages会有以下特点：

- 所有Stages会按照顺序运行，即当一个Stage完成后，下一个Stage才会开始
- 只有当所有Stages完成后，该构建任务（Pipeline）才会成功

一个管道包含多个阶段

### Jobs

Jobs表示构建工作，表示某个Stage里面执行的工作。我们可以在Stages里面定义多个Jobs，这些Jobs会有以下特点：

- 相同Stage中的Jobs会并行执行
- 相同Stage中的Jobs都执行成功时该Stage才会成功
- 如果任何一个Job失败，那么该Stage是啊比，即该构建任务（Pipline）失败

一个阶段包含多个任务

## GitLab Runner

想问为什么不用GitLab CI来运行那些构建任务？

一般来说，构建任务都会占用很多的系统资源（譬如编译代码），而GitLabCI有时GitLab的一部分，如果有GitLab CI来运行构建任务的话，在执行构建任务的时候，GitLab的性能会大幅下降。

GitLab CI最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给GitLab Runner来做啦。
因为GitLab RUnner可以安装到不同的机器上，所以在构建任务运行期间并不会影响到GitLab性能

### 安装

#### Dockerfile

在 /usr/local/docker/runner/environment 目录下创建 Dockerfile

```dockerfile
FROM gitlab/gitlab-runner:v11.0.2
MAINTAINER Lusifer <topsale@vip.qq.com>

# 修改软件源
RUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > /etc/apt/sources.list && \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> /etc/apt/sources.list && \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> /etc/apt/sources.list && \
    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> /etc/apt/sources.list && \
    apt-get update -y && \
    apt-get clean

# 安装 Docker
RUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \
    curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - && \
    add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable" && \
    apt-get update -y && \
    apt-get install -y docker-ce
COPY daemon.json /etc/docker/daemon.json

# 安装 Docker Compose
WORKDIR /usr/local/bin
RUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose
RUN chmod +x docker-compose

# 安装 Java
RUN mkdir -p /usr/local/java
WORKDIR /usr/local/java
COPY jdk-8u152-linux-x64.tar.gz /usr/local/java
RUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \
    rm -fr jdk-8u152-linux-x64.tar.gz

# 安装 Maven
RUN mkdir -p /usr/local/maven
WORKDIR /usr/local/maven
RUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz
# COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven
RUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \
    rm -fr apache-maven-3.5.3-bin.tar.gz
# COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml

# 配置环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_152
ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3
ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin

WORKDIR /
```

#### daemon.json

在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址

```dockerfile
{
  "registry-mirrors": [
    "https://registry.docker-cn.com"
  ],
  "insecure-registries": [
    "192.168.75.131:5000"
  ]
}
```

#### docker-compose.yml

在 /usr/local/docker/runner 目录下创建 docker-compose.yml

```yml
version: '3.1'
services:
  gitlab-runner:
    build: environment
    restart: always
    container_name: gitlab-runner
    privileged: true
    volumes:
      - /usr/local/docker/runner/config:/etc/gitlab-runner
      - /var/run/docker.sock:/var/run/docker.sock
```

#### 注册 Runner

`docker exec -it gitlab-runner gitlab-runner register`

```dockerfile

# 输入 GitLab 地址

Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): http://192.168.75.146:8080/

# 输入 GitLab Token

Please enter the gitlab-ci token for this runner: 1Lxq_f1NRfCfeNbE5WRh

# 输入 Runner 的说明

Please enter the gitlab-ci description for this runner: 可以为空

# 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci

Please enter the gitlab-ci tags for this runner (comma separated): deploy

# 这里选择 true ，可以用于代码上传后直接执行
Whether to run untagged builds [true/false]: true

# 这里选择 false，可以直接回车，默认为 false
Whether to lock Runner to current project [true/false]: false

# 选择 runner 执行器，这里我们选择的是 shell
Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh: shell

附：项目配置 Dockerfile 案例
FROM openjdk:8-jre

MAINTAINER Lusifer <topsale@vip.qq.com>

ENV APP_VERSION 1.0.0-SNAPSHOT
ENV DOCKERIZE_VERSION v0.6.1
RUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
    && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
    && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz

RUN mkdir /app

COPY itoken-eureka-$APP_VERSION.jar /app/app.jar
ENTRYPOINT ["dockerize", "-timeout", "5m", "-wait", "tcp://192.168.75.128:8888", "java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar", "--spring.profiles.active=prod"]

EXPOSE 8761
```
