---
title: 高性能缓存
p: 后端/Java/高并发与多线程/高性能缓存
date: 2020-04-20 11:16:00
tags: [Java,多线程]
categories: [Java,多线程]
---
## 最简单缓存入手————HashMap



## 并发安全要保证————用synchronized实现

- 性能差
- 代码复用能力差

## 给HashMap加final关键字

- 属性被声明为final后，该变量则只能被复制一次，且一旦被复制，final的百年来就不能再被改变。
- 所以我们把它加上final关键字，增强安全性。

## 代码有重构空间————用装饰者模式

- 我们假设ExpensiveFunction类是耗时计算的实现类，实现了Computable接口，但是其本身不具备缓存功能，也不需要考虑缓存的事情
- 缺点
  - 性能差
  - 当多个线程同时想计算的时候，需要慢慢等待，严重时，性能甚至比不用缓存更差

## 性能待优化————引出锁性能优化经验：缩小锁的粒度

- 虽然提高了并发效率，但是并不意味着就是线程安全的，还需要考虑到同时读写等情况
- 但是起始没必要自己实现线程安全的HashMap，也不应该加synchronized，因为我们自己实现的性能远不如现有的并发集合
- 我们来使用ConcurrentHashMap优化我们的缓存

### 用并发集合————ConcurrentHashMap

- 缺点：在计算完成前，另一个要求计算相同值得请求到来，会导致计算两遍，这和缓存想避免多次计算得初衷恰恰相反，是不可接受的

#### 避免重复计算————Future和Callable的妙用

- 动机：现在不同的线程进来以后，确实可以同时计算，但是如果两个线程前脚后，也就是相差无几的进来请求同一个数据，那么我们来看看会出现什么问题：重复计算
- 这个例子只有2个线程，并不可怕，但是如果是100个线程都请求同样的内容，却都需要重新计算，那么会造成巨大的浪费

#### 依然存在重复的可能————用原子操作putIfAbsent

- 如果有两个同时计算666的线程，同时调用cache.get方法，那么返回的结果都为null，后面还是会创建两个任务去计算相同的值
{% asset_img 重复计算.png 重复计算%}

```java
@Override
    public V compute(A arg) throws Exception {
        Future<V> future = cache.get(arg);
        if (future == null) {
            Callable<V> callable = () -> c.compute(arg);
            FutureTask<V> futureTask = new FutureTask<>(callable);
            // putIfAbsent往里放，如果不存在就放入，并返回之前的value，因为初始arg为null所以就进行计算
            // 如果有值就会返回之前放过的值
            future = cache.putIfAbsent(arg, futureTask);
            if (future == null) {
                future = futureTask;
                System.out.println("从Future调用了计算函数");
                futureTask.run();
            }
        }
        return future.get();
    }
```

## 计算中抛出异常————ExcecutionException

- 这3种异常之所以用不同的catch块捕获，是因为它们的处理逻辑是不同的
  - CancellationException和InterruptedException是人为取消的，那么我们应该立即终止任务
  - 但是如果是计算错误，且我们明确直到多试几次就可以得到答案，那么我们的逻辑应该是重试，尝试多次直到正确的结果出现
  - 在这里，我们加上while(true)来保证计算错误不会影响我们的逻辑，然后如果是计算错误，就进入下一个循环，重新计算，直到计算成功；如果是人为取消，那么就抛出异常然后结束运行

## 高并发访问时

- 如果同时过期，那么同时都拿不到缓存，导致打爆CPU和MySQL，造成缓存雪崩，缓存击穿等高并发下的缓存问题
- 想测并发性能，所有线程同时访问缓存
  - 前一个类存在一个问题，就是大量的请求实际上不是同时到达的，而是分先后，但是这样就没办法给缓存造成压力，我们需要真正的同一时刻大量请求到达，此时可以用CountDownLatch来实现

```java
package MultithReading.imoocacache;

import MultithReading.imoocacache.computeble.ExpensiveFunction;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @Description TODO
 * @Author Matthew
 * @Date 2020/4/20 21:40
 * @Version 1.0
 */

public class ImoocCache7 {

    static ImoocCache6<String, Integer> expensiveComputer = new ImoocCache6<>(new ExpensiveFunction());
    public static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        ExecutorService service = Executors.newFixedThreadPool(10000);
        for (int i = 0; i < 10000; i++) {
            service.submit(() -> {
                    Integer result = null;
                try {
                    System.out.println(Thread.currentThread() + "开始等待");
                    countDownLatch.await();
                    SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormat.get();
                    String format = dateFormat.format(new Date());
                    System.out.println(Thread.currentThread() +"--"+ format+"被放行");
                    result = expensiveComputer.compute("666");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(result);
            });
        }
        Thread.sleep(5000);
        countDownLatch.countDown();
        service.shutdown();
//        service.shutdown();
//        while (!service.isTerminated()) {
//        }
        System.out.println("总耗时："+ (System.currentTimeMillis()-start));
    }
}

class ThreadSafeFormatter {
    public static ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue() {
            return new SimpleDateFormat("mm:ss");
        }

        @Override
        public SimpleDateFormat get() {
            return super.get();
        }
    };

}
```
