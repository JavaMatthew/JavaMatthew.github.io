---
title: 线程8大核心基础知识
p: 后端/Java/高并发与多线程/线程8大核心基础知识
date: 2020-03-01 13:10:46
tags: [Java,多线程]
categories: [Java,多线程]
---
## 多线程全部脉络

{%asset_img 0全课脉络.png 0全课脉络 %}

## 多线程8大基础

{%asset_img 1线程8大核心基础.png 1线程8大核心基础 %}

### 实现多线程的方法时1种2种还是4种

> 实现多线程的官方正确方法：2种

Oracle官网文档：
There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started. The other way to create a thread is to declare a class that implements the Runnable interface.
创建一个新的执行线程有两种方法：一个是将一个类声明为Thread的子类，这个子类应该重写run类的方法Thread，然后可以分配并启动子类的实例。另一种方法来创建一个线程是声明实现类Runnable接口。

#### 两种方法对比

1. 方法1（实现Runnable接口）更好
    方法2（继承Thread类）的缺点：从代码的架构去考虑run方法应该和Thread类应该时解耦的；
        如果想新建一个任务只能够新建一个线程，而新建线程的损耗是比较大的，所以方法1好在资源的节约上；
        Java无法双继承，限制了它的可扩展性。

2. 两种方法的本质对比
    方法一：最终调用target.run()
    方法二：run()整个都被重写

#### 有多少实现线程的方法

1. 从不同的角度看，会有不同的答案。
2. 典型答案时两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
3. 但是我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，run方法的代码如下：

    ```java
    @Override
    public void run() {
        if (target != null){
            target.run();
        }
    }
    ```

    方法一和方法二，也就是“继承Thread类然后重写run()和实现Runnable接口并传入Thread类在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：
        方法一：最终调用target.run()
        方法二：run()整个都被重写
4. 然后具体展开说其他方式；
    还有其他的实现线程的方法，例如线程池等，他们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
5. 结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnabel实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程但是他们的本质都逃不出刚才所说的范围。

### 典型错误观点分析

1. “**线程池**拆功能键线程也算是一种新建线程的方式”
    原理：用的new Thread
2. “通过Callable和FutureTask创建线程，也算是一种新建线程的方式”
    本质是Runnable接口
3. “无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”
4. 定时器
5. 匿名内部类
6. Lambda表达式

> 多线程的实现方式，在代码种写法千变万化，但其本质万变不离其宗。

## 正确的启动线程

### start()和run()的比较

```java
Runnable runnable = () -> System.out.println(Thread.currentThread().getName());
runnable.run();

new Thread(runnable).start();
```

运行结果为
main
Thread-0

#### start()方法含义

- 启动新线程：向JVM申请启动新线程
- 准备工作
- 不能重复的执行start()

#### start()源码解析

- 启动新线程检查线程状态
- 加入线程组
- 调用start0()

start方法的执行流程是什么？

1. 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行种或者已结束的线程，都不能再次启动，详见CantStartTwice10类）
2. 被加入线程组
3. 调用start0()方法启动线程
注意点：
start方法是被synchronized修饰的方法，可以保证线程安全；由JVM创建的main方法线程和system组线程，并不会通过start来启动。

#### run()方法原理解读

```java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```

通过Thread重写run方法，或者给target赋值为Runnable，调用Runnable的run方法

## 正确的停止线程

1. 原理介绍：使用interrupt来通知，而不是强制

Java中停止线程的原则是什么？

在Java中，最好的停止线程的方式是使用中断interrupt，但是这仅仅是会通知到被终止的线程“你该停止运行了”，被终止点额线程自身拥有决定权（决定是否、以及何时停止）这依赖于请求停止方和被停止方都遵守一种约定好的编码规范。
任务和线程的启动很容易。在大多时候，我们都会让它们运行知道结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或者线程，或许是因为用户取消了操作，或者服务需要被快速关闭，或者是运行超时或出错了。
要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。**Java没有提供任何机制来安全地终止线程。但它提供了中断（Interruption），这是一种协作机制**，能够使一个线程终止另一个线程的当前工作。
这种协作式的方法使必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：**当需要停止时，它们首先会清楚当前正在执行的工作，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清楚如何执行清楚工作。**
生命周期结束（End-of-Lifecycle)的问题会使任务、服务以及程序的设计和实现等过程变得复杂，而这个在程序设计中非常重要的要素却经常被忽略。一个行为良好的软件与勉强运的软件之间的最主要区别就是，行为良好的软件能很完善地处理失败、关闭和取消等过程。

### 正确的停止方法：interrupt

- 通常线程会在什么情况下停止普通情况
- 线程可能被阻塞(例如Thread.sleep)
- 如果线程在每次迭代后都阻塞

- while内try/catch的问题
- 实际开发中的两种最佳实践
- 响应中断的方法总结列表

### 实际开发中的两种最佳实践

- 优先选择：传递中断
- 不想或无法传递：恢复中断
- 不应屏蔽中断

处理中断的最好方法是什么？

优先选择在方法上抛出异常
用throws InterruptedException 标记你的方法，不采用try语句块捕获异常，以便于该异常可以传递到顶层，让run方法可以捕获这一异常，例如：

```java
void subTask() throws InterruptedException {
    sleep(delay);
}
```

由于run方法内无法抛出checked Exception（只能用try catch），顶层方法必须处理该异常，避免漏掉或者被吞掉的情况，增强了代码的健壮性。

如果不能抛出中断，要怎么做？

如果不想或无法传递InterruptedException（例如用run方法的时候，就不让该方法throws InterruptedException），那么应该选择在catch子句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行依然能够检查到刚才发生了中断。