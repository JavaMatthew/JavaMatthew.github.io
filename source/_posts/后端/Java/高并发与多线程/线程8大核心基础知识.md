---
title: 线程8大核心基础知识
p: 后端/Java/高并发与多线程/线程8大核心基础知识
date: 2020-03-01 13:10:46
tags: [Java,多线程]
categories: [Java,多线程]
---
## 多线程全部脉络

{%asset_img 0全课脉络.png 0全课脉络 %}

## 多线程8大基础

{%asset_img 1线程8大核心基础.png 1线程8大核心基础 %}

### 实现多线程的方法时1种2种还是4种

> 实现多线程的官方正确方法：2种

Oracle官网文档：
There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started. The other way to create a thread is to declare a class that implements the Runnable interface.
创建一个新的执行线程有两种方法：一个是将一个类声明为Thread的子类，这个子类应该重写run类的方法Thread，然后可以分配并启动子类的实例。另一种方法来创建一个线程是声明实现类Runnable接口。

#### 两种方法对比

1. 方法1（实现Runnable接口）更好
    方法2（继承Thread类）的缺点：从代码的架构去考虑run方法应该和Thread类应该时解耦的；
        如果想新建一个任务只能够新建一个线程，而新建线程的损耗是比较大的，所以方法1好在资源的节约上；
        Java无法双继承，限制了它的可扩展性。

2. 两种方法的本质对比
    方法一：最终调用target.run()
    方法二：run()整个都被重写

#### 有多少实现线程的方法

1. 从不同的角度看，会有不同的答案。
2. 典型答案时两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
3. 但是我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，run方法的代码如下：

    ```java
    @Override
    public void run() {
        if (target != null){
            target.run();
        }
    }
    ```

    方法一和方法二，也就是“继承Thread类然后重写run()和实现Runnable接口并传入Thread类在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：
        方法一：最终调用target.run()
        方法二：run()整个都被重写
4. 然后具体展开说其他方式；
    还有其他的实现线程的方法，例如线程池等，他们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
5. 结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnabel实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程但是他们的本质都逃不出刚才所说的范围。

### 典型错误观点分析

1. “**线程池**拆功能键线程也算是一种新建线程的方式”
    原理：用的new Thread
2. “通过Callable和FutureTask创建线程，也算是一种新建线程的方式”
    本质是Runnable接口
3. “无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”
4. 定时器
5. 匿名内部类
6. Lambda表达式

> 多线程的实现方式，在代码种写法千变万化，但其本质万变不离其宗。