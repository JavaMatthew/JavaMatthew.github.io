---
title: 并发流程
p: 后端/Java/高并发与多线程/并发流程
date: 2020-04-10 08:30:53
tags: [Java,多线程]
categories: [Java,多线程]
---
## 什么是控制并发流程

- 控制并发流程的工具类，作用就是帮助我们程序眼更容易得让线程之间合作
- 让线程之间相互配合，来满足业务逻辑
- 比如让线程A等待线程B执行完毕后再执行等合作策略

{% asset_img 控制并发流程的工具类.png 控制并发流程的工具类%}

## CountDownLatch倒计时门闩

### CountDownLatch类的作用

并发流程控制工具

- 倒数门闩
- 例子：购物拼团；大巴（游乐园坐过山车排队），人满发车
- 流程：倒数结束之前，一直处于等待状态，直到倒计时结束了，此线程才继续工作。

### 类的主要方法介绍

- CountDownLatch（int count）：仅有一个构造函数，参数count为需要倒数的数值。
- await（）：调用await（）方法的线程会被挂起，它会等待直到count值为0才继续执行
- countDown（）：将count值减1，直到为0时，等待的线程会被唤起。
{% asset_img countDownLatch.png countDownLatch%}

### 两个典型用法

- 类的主要方法介绍
- 用法一：一个线程邓艾多个线程都执行完毕，再继续自己的工作。
- 用法二：多个线程等待某一个线程的信号，同时开始执行。

### CountDownLatch注意点

- 扩展用法：多个线程等待多个线程完成执行后，再同时执行
- CountDownLatch是不能够重用的，如果需要重新技术，可以考虑适用CyclicBarrier或者创建新的CountDownLatch实例。

## Semaphore信号量

- Semaphore可以用来限制或管理数量有限的资源的使用情况。

### 信号量使用流程

1. 初始化Semaphore并指定许可证的数量
2. 在需要被现在的代码前加acquire或者acquireUninterruptibly（）方法
3. 在任务执行结束后，调用release（）来释放许可证

### 信号量主要方法介绍

- new Semaphore(int permits,boolean fair):这里可以设置是否要使用公平策略，如果传入true，那么Semaphore会把之前等待的线程放到FIFO的队列里，以便于当有了新的许可证，可以分发给之前等了最长时间的线程。
- acquire（）
- acquireUninterruptibly（）
- tryAcquire():看看现在有没有空闲的许可证，如果有的话就获取，如果没有的话也没关系，我不必陷入阻塞，我可以取做别的事，过一会再来查看许可证的空闲情况。
- tryAcquire（timeout）：和tryAcquire（）一样，但是多了一个超时时间，比如“在3秒内获取不到许可证，我就去做别的事”。
- release（）

### 信号量特殊用法

- 一次性获取或释放多个许可证
  - 比如TaskA会调用很销魂资源的method1（），而TaskB调用的是不太消耗西元的method2（），假设我们一共有5个许可证。那么我们就可以要求TaskA获取5个许可证才能执行，而TaskB只需要获取到一共许可证就恩那个执行，这样就避免了A和B同时运行的情况，我们可以根据自己的需求合理分配资源。

### 信号量注意点

1. 获取和释放的许可证数量必须一致，否则，比如每次都获取2个但是只释放1个甚至不释放，随着时间的推移，到最后许可证数量不够用，会导致成型卡死。（虽然信号量类并不对是否和获取的数量做规定，但是这是我们的变成规范，否则容易出错）
2. 注意在初始化Semaphore的时候设置公平性，一般设置为true会更合理
3. 并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对线程并无要求，也许是A获取了，然后由B释放，只要逻辑合理即可。
4. 信号量的作用，除了控制临界区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才能开始工作，那么就线程1acquire(),而线程2完成任务后release(),这样的话，相当于是轻量级的CountDownLatch。

## Condition接口（又称条件对象）

### Condition作用

- 当线程1需要等待某个条件的时候，它就去执行condition.await()方法，一旦执行了await()方法，线程就会进入阻塞状态
- 然后通常会有另外一共线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就回去执行condition.signal()方法，这时JVM就会从被阻塞的线程里找，找到那些等待该condition的线程，当线程1就会收到可执行信号的时候它的线程状态就会变成Runnable可执行状态。

### signalAll()和signal()区别

- signalAll()会换器所有的正在等待的线程
- 但是signal()是公平的，只会唤起那个等待时间最长的线程

### Condition注意点

- 实际上，如果说Lock用来代替synchronized，那么Condition就是用来代替相对应的Object.wait/notify的，所以子啊用法和性质上，几乎都一样
- await方法会自动释放持有的Lock锁，和Object.wait一样，不需要自己手动先释放锁
- 调用await的时候，必须持有锁，否则会抛出异常，和Object.wait一样

## CyclicBarrier循环栅栏

- CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程
- 当有大量线程相互配合，分别计算不同任务，并且需要最后统一汇总的时候，我们可以是用CyclicBarrier。CyclicBarrier可以构造一个集结点，当某一个线程执行完毕，他就会到集结点等待，直到所有线程都到了集结点，那么该栅栏就被撤销，所有线程再统一出发，继续执行剩下的任务。
- 生活中的例子：“咱们3个人明天中午在学校碰面，都到齐后，一起讨论下学期的计划。”

### CyclicBarrier和CountDownLatch的区别

- 作用不同：CyclicBarrier要等固定数量的线程都到达了栅栏位置才能继续执行，而CountDownLatch只需等待数字到0，也就是说，CountDownLatch用于实践，但是CyclicBarrier是用于线程的。
- 可重用性不同：CountDownLatch在倒数到0并出发门闩打开后，就布恩那个再次使用了，除非新建新的实例；而CyclicBarrier可以重复使用。