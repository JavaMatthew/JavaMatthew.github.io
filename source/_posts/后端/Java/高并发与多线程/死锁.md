---
title: 死锁
p: 后端/Java/高并发与多线程/死锁
date: 2020-03-12 21:12:29
tags: [Java,多线程]
categories: [Java,多线程]
---
## 什么是死锁

- 发生在并发中
- 互不相让：当两个（或更多）线程（或进程）象互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁
{% asset_img 死锁.png 死锁%}
{% asset_img 死锁1.png 死锁1%}

## 死锁的影响

死锁的影响在不同系统中是不一样的，这取决于系统对死锁的处理能力

- 数据库中：检测并放弃事务
- JVM中：：无法自动处理

### 几率不高但危害大

- 不一定发生，但是遵守“墨菲定律”
- 一旦发生，多是高并发常见，影响用户多
- 整个系统崩溃、子系统崩溃、性能降低
- 压力测试无法找出所有潜在的死锁

### 实际生产中的里斯：转账

- 需要两把锁
- 获取两把锁成功，且余额大于0，则扣除转出人，增加收款人的余额，是原子操作

## 死锁的4个必要条件

1. 互斥条件
2. 请求与保持条件
3. 不剥夺条件
4. 循环等待

缺一不可，这个分析之前的例子

## 如何定位死锁

- jstack
- ThreadMXBean代码演示

## 修复死锁的策略

- 线上问题都需要防患于未然，不造成损失地扑灭几乎已经使不可能
- 保存案发现场然后立刻重启服务器
- 暂时保证线上服务的安全，然后在利用刚才保存的信息，排查死锁，修改代码，重新发版

### 常见修复策略

- 避免策略：哲学家就餐的换手方案、转账换序方案

#### 死锁避免策略

- 思路：避免相反的获取锁的顺序
- 转账时避免死锁
  - 实际上不在乎获取锁的顺序
  - 通过hashcode来获取决定获取锁的顺序、冲突时需要“加时赛"
  - 有主键就更方便

### 哲学家就餐问题

{% asset_img 哲学家就餐.png 哲学家就餐%}

#### 有死锁和资源耗尽的风险

- 死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）

```java
public class DiningPhilosophers {
    public static class Philosopher implements Runnable {
        private Object lestChopstick;
        private Object rightChopstic;
        public Philosopher(Object lestChopstick, Object rightChopstic) {
            this.lestChopstick = lestChopstick;
            this.rightChopstic = rightChopstic;
        }
        @Override
        public void run() {
            while (true) {
                doAction("Thinking");
                synchronized (lestChopstick) {
                    doAction("Picked up left chopstick");
                    synchronized (rightChopstic) {
                        doAction("Pick up right chopstick - eating");
                        doAction("Put down right chopstick");
                    }
                    doAction("Put down left chopstick");
                }
            }
        }

        private void doAction(String action) {
            System.out.println(Thread.currentThread().getName() + " " + action);
            try {
                Thread.sleep((long) (Math.random() * 10));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Philosopher[] philosophers = new Philosopher[5];
        Object[] chopsticks = new Object[philosophers.length];
        for (int i = 0; i < chopsticks.length; i++) {
            chopsticks[i] = new Object();
        }
        for (int i = 0; i < philosophers.length; i++) {
            Object leftChopstick = chopsticks[i];
            Object rightChopstick = chopsticks[(i + 1) % chopsticks.length];
            philosophers[i] = new Philosopher(leftChopstick, rightChopstick);
            new Thread(philosophers[i], "哲学家" + (i + 1) + "号").start();
        }
    }
}
```

#### 解决方案

- 服务员检查（避免策略）
- 改变一个哲学家拿叉子的顺序（避免策略）
- 餐票（避免策略）
- 领导调节（检测与恢复策略）

### 检测与恢复策略

- 允许发生死锁
- 每次调用锁都记录
- 定期检查“锁的调用链路图”中是否存在环路
- 一旦发生死锁，就用死锁恢复机制进行恢复

- 检测算法：锁的调用链路图
- 恢复方法1：进程终止
  - 逐个终止线程，直到自锁消除。
  - 终止顺序：
    1. 优先级（是前台交互还是后台处理）
    2. 已占用资源，还需要的资源
    3. 已经运行时间
- 恢复方法2：资源抢占
  - 把已经分发出去的锁给收回来
  - 让线程回退几步，这样就不用结束整个线程，成本比较低
  - 缺点：可能同一线程一直被抢占，那就造成饥饿

### 鸵鸟策略

鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来他就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概览极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复。

## 实际工程中如何避免死锁

1. 设置超时时间
    - Lock的tryLock(long timeout, TimeUnit unit)
    - synchronized不具备尝试锁的能力
    - 造成超时的可能性多：发生了死锁、线程陷入死循环、线程执行很慢
    - 获取锁失败：打日志、发报警邮件、重启等
    - 代码演示：退一步海阔天空
2. 多使用并发类而不是自己设计锁
    - ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等
    - 实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高
3. 尽量降低锁的使用粒度：用不同的锁而不是一个锁
4. 如果能使用同步代码块，就不使用同步方法：自己指定锁对象
5. 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践
6. 避免锁的嵌套：MustDeadLock类
7. 分配资源前先看看能不能收回来：银行家算法
8. 尽量不要几个功能用同一把锁：专锁专用

## 其他活性故障

- 死锁是最常见的活跃性问题瞒不过除了刚才的死锁之外，还有一些类似的问题，会导致程序无法顺利执行，统称为活跃性问题
- 活锁
- 饥饿

### 活锁

- 有死锁和资源耗尽的风险
  - 死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）
  - 活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，在等五分钟，又同时拿起这些餐叉
  - 在实际的计算机问题中，缺乏餐叉可用类比位缺乏共享资源

#### 什么是活锁

- 虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但程序却得不到进展，为奴为线程始终重复做同样的事
- 如果这里死锁，那么就事这里两个人都始终一动不动，直到对方先抬头，它们之间不再说话，只是等待
- 如果发生活锁，那么这里的情况就是，双方都不停地对对方说“你先起来吧，你先起来吧”，双方都一直在说话，在运行
- 死锁和活锁的结果事一样的，就是谁都不能先抬头

#### 如何解决活锁问题

- 原因：重试机制不变，消息队列始终重试，吃饭始终谦让
- 以太网的指数退避算法
- 加入随机因素

#### 工程中的活锁实例：消息队列

- 策略：消息如果处理失败，就放在队列开头重试
- 由于依赖服务出了问题，处理该消息一直失败
- 没阻塞，但程序无法继续
- 解决：放在队列尾部、重试限制

### 饥饿

- 当线程需要某些资源（例如CPU），但是却始终得不到
- 线程的优先级设置过于低，或者又某些线程持有锁同时又无线循环从而不释放锁，或者某程序始终占用某文件的写锁
- 饥饿可能会导致响应性差：比如，我们的浏览器有一个线程负责处理前台相应（打开收藏夹等动作），另外的后台线程负责下载图片和文件、计算渲染等。在这种情况下，如果后台线程吧CPU资源都占用了，那么前台线程将无法得到很好地执行，这回导致用户的体验很差。

## 面试问题

1. 写一个必然死锁的例子
2. 发生死锁必须满足哪些条件
    1. 互斥条件
    2. 请求与保持条件
    3. 不剥夺条件
    4. 循环等待条件

3. 如何定位死锁
    1. jstack
    2. ThreadMXBean

4. 有哪些解决死锁问题的策略
    1. 避免策略：哲学家就餐的换手方案，转账换序方案
    2. 检测与恢复策略:一段实践检测是否又死锁，如果又就剥夺某一个资源，来打开死锁
    3. 鸵鸟策略：鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来他就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概览极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复。

5. 讲讲经典的哲学家就餐问题
    - 服务员检查（避免策略）
    - 改变一个哲学家拿叉子的顺序（避免策略）
    - 餐票（避免策略）
    - 领导调节（检测与恢复策略）

6. 实际工程中如何避免死锁
    1. 设置超时时间
        - Lock的tryLock(long timeout, TimeUnit unit)
        - synchronized不具备尝试锁的能力
        - 造成超时的可能性多：发生了死锁、线程陷入死循环、线程执行很慢
        - 获取锁失败：打日志、发报警邮件、重启等
        - 代码演示：退一步海阔天空
    2. 多使用并发类而不是自己设计锁
        - ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean等
        - 实际应用中java.util.concurrent.atomic十分有用，简单方便且效率比使用Lock更高
    3. 尽量降低锁的使用粒度：用不同的锁而不是一个锁
    4. 如果能使用同步代码块，就不使用同步方法：自己指定锁对象
    5. 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践
    6. 避免锁的嵌套：MustDeadLock类
    7. 分配资源前先看看能不能收回来：银行家算法
    8. 尽量不要几个功能用同一把锁：专锁专用
