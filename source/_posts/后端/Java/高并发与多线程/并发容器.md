---
title: 并发容器
p: 后端/Java/高并发与多线程/并发容器
date: 2020-04-04 12:07:47
tags: [Java,多线程]
categories: [Java,多线程]
---
## 古老和过时的同步容器

- Vector和Hashtable
  - 并发性能差（synchronized修饰方法）
- ArrayList和HashMap
  - 虽然这两个类不是线程安全的，但是可以用Collections.synchronizedList(new ArrayList<E>())和Collections.synchronizedMap(new HashMap<K,V>())使之变成线程安全的，用的同步代码块
- ConcurrentHashMap和CopyOnWriteArrayList
  - 取代同步的HashMap和同步的Arraylist（时代巨轮滚滚向前）
  - 绝大多数并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能都更好

## ConcurrentHashMap（重点、面试常考）

### 为什么需要ConcurrentHashMap

- 为什么不用Collections.synchronizedMap()?
- 为什么HashMap使线程不安全的？
  - 同时put碰撞导致数据丢失
  - 同时put扩容导致数据丢失
  - 死循环造成的CPU100%

### JDK1.7的ConcurrentHashMap实现和分析

- Java7种的ConcurrentHashMap最外层使多个segment，每个segment的底层数据结构与HashMap类似，仍然使数组和联邦组成的拉链法
- 每个segment独立上ReentrantLock锁，每个segment之间互补影响，提高了并发效率
- ConcurrentHashMap默认有16个Segments，所以最多可以同时支持16个线程并发写（操作分别分布在不同的Segment上）。这个默认值可以在初始化的适合设置为其他值，但是一旦初始化以后，使不可以扩容的。
{% asset_img java7ConcurrentHashMap.png java7ConcurrentHashMap%}

### JDK1.8的ConcurrentHashMap实现和分析

{% asset_img java8ConcurrentHashMap.png java8ConcurrentHashMap%}

#### putVal流程

1. 判断key value不为空
2. 计算hash值
3. 根据对应位置节点的类型，来赋值，或者和老婆Transfer，或者增长链表，或者给红黑树增加节点
4. 检查满足阈值就“红黑树化”
5. 返回oldVal

#### get流程

- 计算hash值
- 找到对应的位置，根据情况进行：
- 直接取值
- 红黑树里找值
- 遍历链表取值
- 返回找到的结果

### 为什么把1.7的结构提升为1.8的结构

- 数据结构（并发度提高了）
- Hash碰撞（处理的效率提高了）
- 保证并发安全
- 查询复杂度
- 为什么超过8要转为红黑树？
  - 当设置为8时，冲突发生的概率为0.00000006

### ConcurrentHashMap的组合操作

- replace

```java
public class OptionsNotSafe implements Runnable{

    private static ConcurrentHashMap<String, Integer> scores = new ConcurrentHashMap<>();

    public static void main(String[] args) throws InterruptedException {
        scores.put("小明", 0);
        Thread thread1 = new Thread(new OptionsNotSafe());
        Thread thread2 = new Thread(new OptionsNotSafe());
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(scores);
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            while (true) {
                Integer score = scores.get("小明");
                int newScore = score + 1;
//                scores.put("小明", newScore);
                boolean b = scores.replace("小明", score, newScore);
                if (b) {
                    break;
                }
            }

        }
    }
}
```

- putIfAbsent

```java
if(!map.containsKey(key))
  return map.put(key,value);
else
  return map.get(key);
```

## CopyOnWriteArrayList

### 诞生的原因

- 代替Vector和SynchronizedList，就和ConcurrentHashMap代替SynchronizedMap的原因一样
- Vector和SynchronizedList的锁的粒度太大，并发效率相对比较低，并且迭代时无法编辑
- Copy-On-Write并发容器还包括CopyOnWriteArraySet，用来代替同步Set

### 适用场景

- 读操作可以尽可能地快，而写即使慢一些也没有太大关系
- 读多写少：黑名单，每日更新；监听器：迭代操作远多于修改操作

### 读写规则

- 回顾读写锁：读读共享、其他都互斥
- 读写锁规则的升级：读取时完全不用加锁的，并且更厉害的是，写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待

### 实现原理

- 创建新副本、读写分离
- “不可变”原理
- 迭代的时候

### 缺点

- 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的数据，马上能读到，请不要适用CopyOnWrite容器。
- 内存占用问题：因为CopyOnWrite的写是复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。
