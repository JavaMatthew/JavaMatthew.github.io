---
title: 多线程八大核心面试问题总结
p: 后端/Java/高并发与多线程/多线程八大核心面试问题总结
date: 2020-03-07 11:29:15
tags: [Java,多线程]
categories: [Java,多线程]
---
## 常见面试问题总结

### 有多少种实现线程的方法

思路有5点

1. 从不同的角度看，会有不同的答案。
2. 典型答案时两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
3. 但是我们看原理，其实Thread类实现了Runnable接口，并且看Thread类的run方法，会发现其实那两种本质都是一样的，run方法的代码如下：

    ```java
    @Override
    public void run() {
        if (target != null){
            target.run();
        }
    }
    ```

    方法一和方法二，也就是“继承Thread类然后重写run()和实现Runnable接口并传入Thread类在实现多线程的本质上，并没有区别，都是最终调用了start()方法来新建线程。这两个方法的最主要区别在于run()方法的内容来源：
        方法一：最终调用target.run()
        方法二：run()整个都被重写
4. 然后具体展开说其他方式；
    还有其他的实现线程的方法，例如线程池等，他们也能新建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
    1. “**线程池**拆功能键线程也算是一种新建线程的方式”
        原理：用的new Thread
    2. “通过Callable和FutureTask创建线程，也算是一种新建线程的方式”
        本质是Runnable接口
    3. “无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式”
    4. 定时器
    5. 匿名内部类
    6. Lambda表达式
5. 结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现，第一种是重写run方法，第二种实现Runnable接口的run方法，然后再把该runnabel实例传给Thread类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程但是他们的本质都逃不出刚才所说的范围。

### 实现Runnable接口和继承Thread类哪种方式更好

1. 两种方法的本质对比
    方法一：最终调用target.run()
    方法二：run()整个都被重写

2. 方法1（实现Runnable接口）更好
    方法2（继承Thread类）的缺点：从代码的架构去考虑run方法应该和Thread类应该时解耦的；
        如果想新建一个任务只能够新建一个线程，而新建线程的损耗是比较大的，所以方法1好在资源的节约上；
        Java无法双继承，限制了它的可扩展性。

### 一共线程两次调用start（）方法会出现什么情况？为什么

start的启动流程

1. 检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行种或者已结束的线程，都不能再次启动，详见CantStartTwice10类）
2. 被加入线程组
3. 调用start0()方法启动线程
注意点：
start方法是被synchronized修饰的方法，可以保证线程安全；由JVM创建的main方法线程和system组线程，并不会通过start来启动。

但是如果两次调用start（）方法会抛出异常IllegalThreadStateException

### 既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢

调用start方法是启动一个新线程，会进行以下三个步骤：

- 启动新线程检查线程状态
- 加入线程组
- 调用start0()

而直接调用run方法并不会声明一个新的线程而是和普通类调用方法那样执行，还是只有main线程。

### 如何停止线程

1. 原理：用interrupt来请求、好处
2. 想停止线程，要求方、被停止方、子方法被调用方相互配合
3. 最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况

原理：用interrupt来请求线程停止而不是强制，好处是安全
想停止线程，要求方、被停止方、子方法被调用方相互配合才行：
a）作为被停止方：每次循环中或者适时检查中断信号，并且在可能抛出InterruptedException的地方处理该中断信号；
b）请求方：发出中断信号；
c）子方法调用方（被线程调用的方法的作者）要注意：优先在方法层面抛出InterrupedException，或者检查到中断信号时，再次设置中断状态；
最后再说错误的方法：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况。

### 如何处理不可中断的阻塞

根据不同的类调用不同的方法
如果线程阻塞时由于调用了wait(),sleep()或join()方法，你可用中断线程，通过抛出InterruptedException异常来唤醒该线程。
但是对于不能响应InterruptedException的阻塞，很遗憾并没有一共同一的解决方案。
但是我们可用利用特定的其他的可用响应的中断方法，比如ReentranLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。
答案有很多种，因为有很多原因会造成线程阻塞，所以针对不同情况，唤起的方法也不同。
总结就是说如果不支持响应中断，就要用特定方法来唤起，没有万能药。

### 线程有哪几种状态，生命周期是什么

- New
- Runnable
- Blocked
- Waiting
- Time Waiting
- Terminated
{% asset_img 线程的生命周期.png 线程的生命周期%}

### 用程序实现两个线程交替打印0~100的奇偶数

```java
package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;

/**
 * @Description TODO
 * 两个线程交替打印0~100的奇偶数，用wait和notify
 * @Author Matthew
 * @Date 2020/3/4 12:19
 * @Version 1.0
 */

public class WaitNotifyPrintOddEvenWait {
    private static int count = 0;
    private static final Object lock = new Object();
    // 1. 拿到锁，我们就打印
    // 2. 打印完，唤醒其他线程，自己就休眠
    public static void main(String[] args) throws InterruptedException {
        new Thread(new TurningRunner(),"偶数").start();
        Thread.sleep(10);
        new Thread(new TurningRunner(),"奇数").start();
    }

    static class TurningRunner implements Runnable {
        @Override
        public void run() {
            while (count <= 100) {
                synchronized (lock) {
                    //拿到锁就打印
                    System.out.println(Thread.currentThread().getName() + ":" + count++);
                    lock.notify();
                    if (count <= 100) {
                        try {
                            // 如果任务还没结束，就让出lock锁，让本线程休眠
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }

                }
            }
        }
    }

}
```

```java
package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;

/**
 * @Description TODO
 * 两个线程交替打印0~100的奇偶数，用synchronized关键字实现
 * @Author Matthew
 * @Date 2020/3/4 12:08
 * @Version 1.0
 */

public class WaitNotifyPrintOddEvenSyn {
    // 新建两个线程
    // 1个只处理偶数，第二个处理奇数（用位运算）
    // 用synchronized来通信

    private static int count;
    private static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(()->{
            while (count < 100) {
                synchronized (lock) {
                    if ((count & 1) == 0) {
                        System.out.println(Thread.currentThread().getName() + ":" + count++);
                    }
                }
            }
        }, "偶数").start();
        new Thread(()->{
            while (count < 100) {
                synchronized (lock) {
                    if ((count & 1) == 1) {
                        System.out.println(Thread.currentThread().getName() + ":" + count++);
                    }
                }
            }
        }, "奇数").start();
    }
}
```

### 手写生产者消费者设计模式

```java
package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;

import java.util.Date;
import java.util.LinkedList;

/**
 * @Description TODO
 * 用wait/notify来实现
 * @Author Matthew
 * @Date 2020/3/4 9:40
 * @Version 1.0
 */

public class ProducerConsumerModel {
    public static void main(String[] args) {
        EventStorage eventStorage = new EventStorage();
        Producer producer = new Producer(eventStorage);
        Consumer consumer = new Consumer(eventStorage);
        new Thread(producer).start();
        new Thread(consumer).start();
    }

}
class Producer implements Runnable {
    private EventStorage storage;

    public Producer(EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            storage.put();
        }
    }
}

class Consumer implements Runnable {
    private EventStorage storage;

    public Consumer(EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            storage.take();
        }
    }
}

class EventStorage{
    private int maxSize;
    private LinkedList<Date> storage;

    public EventStorage() {
        maxSize = 10;
        storage = new LinkedList<>();
    }
    public synchronized void put(){
        while (storage.size() == maxSize) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        storage.add(new Date());
        System.out.println("仓库里有了" + storage.size() + "个产品。");
        notify();
    }
    public synchronized void take(){
        while (storage.size() == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("拿到了" + storage.poll() + ",现在仓库还剩下" + storage.size());
        notify();
    }
}

```

### 为什么wait()需要在同步代码块内使用，而sleep不需要

为了让通信变得可靠，防止死锁，或者永久等待的发生
如果不把wait()、notify()放在代码块中，很有可能执行wait()前，线程突然切过去，这样另一个线程的执行完notify()后切换回来执行wait(),
会导致线程执行wait()之后，永远没有线程唤醒，导致了永久等待或者死锁的发生
Java设计者考虑到这样的问题，将线程间需要配合的方式放到同步代码块中
sleep()是针对单独线程的，和其他线程关系不大，所以不需要放到同步代码块中。

### 为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里?而sleep定义在Thread类里

wait()、notify()、notifyAll()是锁级别的操作，而锁是属于某一个对象的（锁绑定在某一个对象中，而不是线程中）
假设将wait()、notify()、notifyAll()定义在线程中，就会造成很大的局限性，这样，每个线程都可以休眠。但是经常会碰到这种情况，某一个线程持有多个锁，并且锁之间是相互配合的。如果将wait()这样的方法定义在Thread类中，就没有办法实现线程之间的配合

### wait方法是属于Object对象的，那调用Thread.wait会怎么样

Thread类在线程退出的时，会自动执行notify()，使我们的流程受到干扰。

```java
package MultithReading.threadcoreknowledge.threadobjectclasscommonmethods;

/**
 * @Description TODO
 * 通过讲解join原理，分析出join的代替写法
 * @Author Matthew
 * @Date 2020/3/4 20:36
 * @Version 1.0
 */

public class JoinPrinciple {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "执行完毕");
        });

        thread1.start();
        System.out.println("开始等待子线程运行完毕");
//        thread1.join();
        synchronized (thread1) {
            thread1.wait();
        }
        System.out.println("所以子线程执行完毕");
    }
}
```

### 如何选择用notify还是notifyAll

notify是唤醒1个线程，notifyAll是唤醒所有线程

### notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办

 竞争锁失败之后，陷入等待状态，等待持有锁的线程释放锁，再去竞争锁。

### 用suspend()和resume()来阻塞线程可以吗？为什么

不可以，因为调用它之后线程使带着锁挂起的，容易产生死锁。

### wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）

- 相同
  - 阻塞
  - 响应中断
- 不同
  - 同步方法中
  - 释放锁
  - 指定时间线
  - 所属类

### 在join期间，线程处于哪种线程状态

如果没加时间限制，线程处于waiting状态，否则是Time-waiting

### 守护线程和普通线程的区别

- 守护线程和普通线程的区别
  - 整体无区别
  - 唯一区别在于JVM的离开

### 我们是否需要给线程设置未守护线程

不需要

### run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样

不可以抛出异常，如果抛出异常会离开终止执行

```java
/**
 * @Description TODO
 * 自己的MyUncaughtExceptionHanlder
 * @Author Matthew
 * @Date 2020/3/5 15:57
 * @Version 1.0
 */

public class MyUncaughtExceptionHanlder implements Thread.UncaughtExceptionHandler {
    private String name;
    public MyUncaughtExceptionHanlder(String name) {
        this.name = name;
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.WARNING, "线程异常，终止了" + t.getName(), e);
        System.out.println(name + "捕获了异常" + t.getName() + "异常" + e);
    }
}
```

```java

public class UseOwnUncaughtExceptionHandler implements Runnable{
    public static void main(String[] args) throws InterruptedException {
        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHanlder("捕获器1"));
            new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-1").start();
            Thread.sleep(300);
            new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-2").start();
            Thread.sleep(300);
            new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-3").start();
            Thread.sleep(300);
            new Thread(new UseOwnUncaughtExceptionHandler(), "MyThread-4").start();
    }

    @Override
    public void run() {
            throw new RuntimeException();
    }
}

三月 07, 2020 7:07:30 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException
警告: 线程异常，终止了MyThread-1
java.lang.RuntimeException
捕获器1捕获了异常MyThread-1异常java.lang.RuntimeException
	at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)
	at java.lang.Thread.run(Thread.java:748)

三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException
捕获器1捕获了异常MyThread-2异常java.lang.RuntimeException
警告: 线程异常，终止了MyThread-2
java.lang.RuntimeException
	at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)
	at java.lang.Thread.run(Thread.java:748)

捕获器1捕获了异常MyThread-3异常java.lang.RuntimeException
三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException
警告: 线程异常，终止了MyThread-3
java.lang.RuntimeException
	at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)
	at java.lang.Thread.run(Thread.java:748)

捕获器1捕获了异常MyThread-4异常java.lang.RuntimeException
三月 07, 2020 7:07:31 下午 MultithReading.threadcoreknowledge.uncaughtexception.MyUncaughtExceptionHanlder uncaughtException
警告: 线程异常，终止了MyThread-4
java.lang.RuntimeException
	at MultithReading.threadcoreknowledge.uncaughtexception.UseOwnUncaughtExceptionHandler.run(UseOwnUncaughtExceptionHandler.java:25)
	at java.lang.Thread.run(Thread.java:748)
```

### 线程中如何处理某某个未处理异常

使用全局处理器，对异常进行处理

### 什么是多线程的上下文切换

上下文切换可以认为是内核（操作系统的核心）在CPU上对于进程（包括线程）进行以下的活动：
（1）挂起一共进程，将这个进程在CPU中的状态（上下文）存储与内存中的某处，
（2）在内存中检索下一个进程的上下文并将其在CPU的寄存器中恢复，
（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
