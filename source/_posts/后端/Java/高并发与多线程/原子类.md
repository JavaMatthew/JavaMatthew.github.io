---
title: 原子类
p: 后端/Java/高并发与多线程/原子类
date: 2020-03-30 12:07:11
tags: [Java,多线程]
categories: [Java,多线程]
---
## 什么时原子类，有什么作用

- 原子类的作用和锁类似，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：
- 粒度更细：原子变量可以把竞争范围缩小到比变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度
- 效率更高：通常，适用原子类的效率会比使用锁的效率更高，除了高度竞争的情况。

## 6类原子类纵览

{% asset_img 原子类.png 原子类%}

## AtomicInteger

### 常用方法

- public final int get() //获取当前的值
- public final int getAndSet(int newValue) //获取当前的值，并设置新的值
- public final int getAndIncrement() // 获取当前的值，并自增
- public final int getAndDecrement() // 获取当前的值，并自减
- public final int getAndAdd(int delta) // 获取当前的值，并加上预期的值
- boolean compareAndSet(int expect,int update) // 如果单曲的数值等于预期值，则以原子方式将该值设置为输入值（update）

## Atomic*Reference引用类型原子类

- AtomicReference:AtomicReference类的作用，和AtomicInteger并没有本质区别，AtomicInnteger可以让一个整数保证原子性，而AtomicReference可以让一个对象保证原子性，当然，AtomicReference的功能明显比AtomicInteger强，因为一个对象里可以包含很多属性。用法和AtomicInteger类似。

## 把普通变量升级为具有原子功能

- AtomicIntegerFieldUpdater普通变量进行升级
- 使用场景：偶尔需要一个原子get-set操作

## AtomicIntegerFieldUpdater注意点

- 可见范围（需要用volatile修饰）
- 不支持static

## Adder累加器

- 是Java 8引入的，相对是比较新的一个类
- 高并发下LongAdder比AtomicLong效率高，不过本质是空间换时间
- 竞争激烈的时候，LongAdder把不同线程对应到不同的Cell上进行修改，降低了冲突的概率，是多端锁的理念，提高了并发性。

### 代码演示

- 这里演示多线程情况下AtomicLong的性能，有16个线程对同一个AtomicLong累加
- 由于竞争很激烈，每一次加法，都要flush和refresh，导致很耗费资源。

### LongAdder带来的改进和原理

- 在内部，这个LongAdder额实现原理和刚才的AtomicLong是由不同的，刚才的AtomicLong的实现原理是，每一次加法都需要做同步，所以在高并发的时候会导致冲突比较多，也就降低了效率
- 而此时的LongAdder，每个线程会有自己的一个计数器，禁用来在自己线程内计数，这样一来就不会和其他线程的计数器干扰
- 如图中所示，第一个线程的计数器数值，也就是ctr‘，为1的时候，可以线程2的计数器ctr”的数值已经是3了，他们之间并不存在竞争关系，所以在加和的过程中，根本不需要同步机制，也不需要刚才的flush和refresh。这里也没有一个公共的counter来给所有线程统一计数
- LongAdder引入了分段累加的概念，内部有一个base变量和一个Cell[]数组共同参与计数：
- base变量：竞争不激烈，直接累加到该变量上
- Cell[]数组：竞争激烈，各个线程分散累加到自己的槽Cell[i]中

### 对比AtomicLong和LongAdder

- 在低争用下，AtomicLong和LongAdder这两个类具有相似的特征。但是在竞争激烈的情况下，LongAdder的语气吞吐量要高得多，但要消耗更多的空间
- LongAdder适合的场景是统计求和计数的场景，而且LongAdder基本只提供了add方法，而AtomicLong还具有cas方法

## Accumulator累加器

- Accumulator和Adder非常相似，Accumulator就是一个更通用版本的Adder

### 使用场景

需要大量计算的适合，可使用多线程快速高效处理，可以进行任何计算，不限于加法

```java
public static void main(String[] args) {
        LongAccumulator longAccumulator = new LongAccumulator(Long::sum, 0);
        ExecutorService executorService = Executors.newFixedThreadPool(8);
        IntStream.range(1,10).forEach(i->executorService.submit(()->longAccumulator.accumulate(i)));
        executorService.shutdown();
        while (!executorService.isTerminated()) {}
        System.out.println(longAccumulator.getThenReset());
    }
```

在LongAccumulator传入什么表达式，运算的结果就是什么
