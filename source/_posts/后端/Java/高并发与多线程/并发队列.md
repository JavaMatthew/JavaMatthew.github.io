---
title: 并发队列
p: 后端/Java/高并发与多线程/并发队列
date: 2020-04-07 09:47:09
tags: [Java,多线程]
categories: [Java,多线程]
---
## 为什么要适用队列

- 队列可以在线程间传递数据：生产者消费者模式、银行转账
- 考虑锁等线程安全问题的重任从你转移到了队列上

## 什么是阻塞队列

- 简介、地位
  - 阻塞队列是具有阻塞功能的队列，所以它首先是一个队列，其次是具有阻塞功能。
  - 通常，阻塞队列的一端是给生产者方数据用，另一端给消费者拿数据用。阻塞队列线程安全的，所以生产者和消费者都可以是多线程的

- 阻塞功能：最有特色的两个带有阻塞功能的方法是
- take()方法：获取并逸出队列的头结点，一旦执行take的时候，队列里误数据，则阻塞，直到队列有数据
- put()方法：插入元素。但是如果队列已满，那么就无法继续插入，则阻塞，知道队列有了空闲空间

- 是否有界（容量有多大）：这是一个非常重要的属性，无界队列意味着里面可以容纳非常多（Integer.MAX_VALUE,约为2的31次，是非常大的一个数，可以近似认为是无线容量）
- 阻塞队列和线程池的关系：阻塞队列是线程池的重要组成部分

## BlockingQueue

### 主要方法

- put，take
- add，remove，element
- offer，poll，peek

### 常用实现

- ArrayBlockingQueue
- LinkedBlockingQueue
  - 无界
  - 容量Integer.MAX_VALUE
  - 内部结构：Node、两把锁。
- PriorityBlockingQueue
- SynchronousQueue注意点
  - SynchronousQueue没有peek等函数，因为peek的含义是取出头结点，但是SynchronousQueue的容量是0，所以连头结点都没有，也就没有peek方法。同理，没有iterate相关方法
  - 是一个极好的用来直接传递的并发数据结构
  - SynchonousQueue是线程池Executors.newCachedThreadPool()适用的阻塞队列
- DelayQueue
  - 延迟队列，根据延迟时间排序
  - 元素需要实现Delayed接口，规定排序规则

## 非阻塞并发队列

- 并发包种的非阻塞队列只有ConcurrentLinkedQueue这一种，顾名思义ConcurrentLinkedQueue是适用链表作为其数据结构的，适用CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景。用的相对比较少一些
- 看源码的offer方法的CAS思想，内有p。casNext方法，用了UNSAFE.compareAndSwapObject

## 如何选择适合自己的队列

- 边界
- 空间
- 吞吐量
