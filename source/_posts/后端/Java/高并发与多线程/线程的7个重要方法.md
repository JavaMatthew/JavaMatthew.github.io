---
title: 线程的7个重要方法
p: 后端/Java/高并发与多线程/线程的7个重要方法
date: 2020-03-04 08:23:05
tags: [Java,多线程]
categories: [Java,多线程]
---
## Thread和Object类中的重要方法详解

### 方法概览

{% asset_img 方法概览.png 方法概览%}

### wait,notify,notifyAll方法详解

- 用必须先拥有monitor
- notify只能唤醒其中一个
- 属于Object类
- 类似功能的Condition
- 同时持有多个锁的情况，让一个线程wait必须让他释放所有的锁，否则会进入死锁**因为如果程序不运行完，而单一的线程运行完并不会释放这个线程当前持有的锁**

notify唤醒的对象必须是调用wait的对象要不无法唤醒。

```java
public class WaitNotifyReleaseOwnMonitor {
    private static volatile Object resourceA = new Object();
    private static volatile Object resourceB = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (resourceA) {
                System.out.println("ThreadA got resourceA lock.");
                synchronized (resourceB) {
                    System.out.println("ThreadA got resourceB lock.");
                    try {
                        resourceA.wait();
                        System.out.println("ThreadA releases resourceA lock.");
                        resourceA.notify();//将resourceA替换位resourceB无法唤醒Thread1
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });


        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (resourceA) {
                System.out.println("ThreadB got resourceA lock.");
                System.out.println("ThreadB tries to resourceB lock.");
                resourceA.notify();
                try {
                    resourceA.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("--------");
                synchronized (resourceB) {
                    System.out.println("ThreadB got resourceB lock.");
                }
            }
        });

        thread1.start();
        thread2.start();

    }
}
```

#### wait的作用和用法

当调用wait方法之后，直到线程中情况值以发生时，才会被唤醒

- 另一个线程调用这个对象的notify()方法且刚好被唤醒的时本线程；
- 另一个线程调用这个对象的notifyAll()方法；
- 过了wait（long timeout）规定的超时时间，如果传入就是永久等待；
- 线程自身调用了interrupt()

```java
public class JoinPrinciple {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            try {
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "执行完毕");
        });

        thread1.start();
        System.out.println("开始等待子线程运行完毕");
//        thread1.join();
        synchronized (thread1) {
            thread1.wait();
        }
        System.out.println("所以子线程执行完毕");
    }
}
```

自我理解：虽然下列代码是thread1调用wait方法，但是当前线程是main线程，所以是main函数进入waiting而不是thread1

### sleep方法详解

作用:我只想让线程再预期的时间执行，其他时候不要占用CPU资源

sleep方法不释放锁

sleep方法响应中断
    1. 抛出InterruptedException
    2. 清楚中断状态

sleep方法可用让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，知道规定时间后再执行，休眠期间如果被中断，会抛出异常并清楚中断状态。

### join方法作用、用法

作用：因为新的线程加入了我们，所以我们要等他执行完再出发
用法：main等待thread1执行完毕，注意谁等谁

- CountDownLatch或CyclicBarrier类

### yield方法

作用：释放我的CPU时间片
定位：JVM不保证遵循
yield和sleep区别：是否随时可能再次被调度

## 手写生产者消费者设计模式

什么是生产者和消费者模式
{% asset_img 生产者消费者模式.png 生产者消费者模式 %}

## 面试题

1. 为什么线程通信的方法wait(),notify()和notifyAll()被定义在Object类里？而sleep定义在Thread里？
    wait()、notify()、notifyAll()是锁级别的操作，而锁是属于某一个对象的（锁绑定在某一个对象中，而不是线程中）
    假设将wait()、notify()、notifyAll()定义在线程中，就会造成很大的局限性，这样，每个线程都可以休眠。但是经常会碰到这种情况，某一个线程持有多个锁，并且锁之间是相互配合的。如果将wait()这样的方法定义在Thread类中，就没有办法实现线程之间的配合
2. 用3种方式实现生产者模式
3. 为什么wait()需要再同步代码块内使用，而sleep()不需要？
    为了让通信变得可靠，防止死锁，或者永久等待的发生
    如果不把wait()、notify()放在代码块中，很有可能执行wait()前，线程突然切过去，这样另一个线程的执行完notify()后切换回来执行wait(),
    会导致线程执行wait()之后，永远没有线程唤醒，导致了永久等待或者死锁的发生
    Java设计者考虑到这样的问题，将线程间需要配合的方式放到同步代码块中
    sleep()是针对单独线程的，和其他线程关系不大，所以不需要放到同步代码块中
4. wait方法时属于Object对象的，那调用Thread.wait会怎么样？
    Thread类在线程退出的时，会自动执行notify()，使我们的流程受到干扰。
5. notifyAll()之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？
    竞争锁失败之后，陷入等待状态，等待持有锁的线程释放锁，再去竞争锁。
6. 可以用suspend()和resume()来阻塞线程吗，为什么？
    由于安全问题被弃用，不推荐使用。推荐使用wait()和notify()
7. wait/notify、sleep异同（方法属于哪个对象？线程状态怎么切换？）
    - 相同
        - 阻塞
        - 响应中断
    - 不同
        - 同步方法中
        - 释放锁
        - 指定时间xian
        - 所属类
8. 在join期间，线程处于哪种线程状态？
    线程处于waiting状态。
