---
title: 线程池
p: 后端/Java/高并发与多线程/线程池
date: 2020-03-15 10:07:34
tags: [Java,多线程]
categories: [Java,多线程]
---
## 线程池的自我介绍

- 如果不使用线程池，每个任务都新开一个线程处理
  - 一个线程
  - for循环创建线程
  - 当任务数量上升到1000
- 这样开销太大，我们希望有固定数量的线程，来执行这1000个线程，这样就避免了反复创建闭关销毁线程锁带来的开销问题。

### 为什么要使用线程池

- 问题一：反复创建线程开销大
- 问题二：过多的线程会占用太多内存

- 解决以上两个问题的思路
  - 用少量的线程————避免内存占用过多
  - 让这部分线程都保持工作且可用反复执行任务————避免生命周期的损耗

### 线程池的好处

- 加快响应速度
- 合理利用CPU和内存
- 统一管理

### 线程池使用应用的场合

- 服务器接收到大量请求时，使用线程池技术时非常合适的，他可以大大减少线程的创建和销毁次数，提高服务器的工作效率
- 实际上，在开发中，如果需要创建5个以上的线程，那么就可用使用线程池来管理

## 创建和停止线程池

### 线程池构造函数的参数

{% asset_img 线程池构造函数参数.png 线程池构造函数参数%}

#### 参数中的corePoolSize和maxPoolSize

- corePoolSize指的是核心线程数:线程池在完成初始化后，默认情况下，线程池中并没有任何线程，线程池会等待会任务到来时。再创建新线程区执行任务
- 线程池会可能胡izai核心线程数的基础上，额外增加一些线程，但是这些新增加的线程数有一个上线，这就是最大量maxPoolSize
- maximumPoolSize的说明
    maximumPoolSize和maxPoolSize的含义相同，不做额外区分。实际上，在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize是相同的就可以了。

{% asset_img maxPoolSize.png maxPoolSize%}

##### 添加线程规则

1. 如果线程小于corePoolSize，即使其他工作线程处于空闲状态，也很会创建一个线程来运行新任务。
2. 如果线程数等于（或大于）corePoolSize但少于maximumPoolSize，则将任务放入队列。
3. 如果队列已满，并且线程数小于maxPoolSize，则创建一个新线程来运行任务。
4. 如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。

{% asset_img 添加规则.png 添加规则%}

- 是否需要增加线程的判断顺序是：
  - corePoolSize
  - workQueue
  - maxPoolSize

##### 增减线程的特点

1. 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池。
2. 线程池希望保持较少的线程数，并且只有再负载变得很大时才增加它。
3. 通过maximumPoolSize为很高的值，例如Interger.MAXVALUE,可用允许线程池容纳任意数量的并发任务。
4. 是只有再队列填满时才创建多余corePoolSize的线程，所以如果你使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。

#### keepAliceTime

- 如果线程池当前的线程数多余corePoolSize，那么如果多余的线程共享啊hi见超过keepAliveTime，它们就会被终止。

#### ThreadFactory 用来创建线程

- 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory(),创建出来的线程都在同一个线程组，拥有同样的NORM——PRIORITY优先级并且都不是守护线程。如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。
- 通常我们用默认的ThreadFactory就可以了

#### workQueue工作队列

- 有3中最常见的队列类型:
    1. 直接交接：SynchronousQueue
    2. 无界队列：LinkedBlockingQueue
    3. 有界队列：ArrayBlockingQueue

### 线程池应该手动创建还是自动创建

- 手动创建更好，因为这样可用让我们更加明确线程池的运行规则，避免资源耗尽的风险。
- 让我们来看看自动创建线程池（也就是直接调用JDK封装号的构造函数）可能带来哪些问题
- newFixedThreadPool
  - 由于传进去的LinkedBlockingQueue是没有容量上限的，所以当请求数越来越多，并且无法即使处理完毕的时候，也就是请求堆积的时候，会容易造成占用大量的内存，可能会导致OOM。`Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded at ...`
- newSingleThreadExecutor
  - 可以看出，这里和刚才的newFixedThreadPool的原理基本一样，只不过把线程数直接设置成了1，所以这也会导致同意的问题，也就是当请求堆积的时候，可能会占用大量的内存。
- newCachedThreadPool
  - 可缓存线程池
  - 特点：无界线程池，具有自动回收多余线程的功能
  {% asset_img CachedThreadPool.png CachedThreadPool%}
  - 这里的弊端在于第二个参数maximumPoolSize被设置为了Integer.MAX_VALUE,这可能会创建数量非常多的线程，甚至导致OOM。
- newScheduledThreadPool
  - 支持定时及周期性任务执行的线程池

```java
new ThreadPoolExecutor(4, 10,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>())
```

#### 正确的创建线程池的方法

- 根据不同的业务场景，自己设置线程池参数，分析阿里规约的图的第二个例子，比如我们的内存有多大，我们能不能接收任务被拒绝等等。

#### 线程池里的线程数量设定为多少比较合适

- CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右
- 耗时IO型（读写数据库、文件、网络读写等）最佳线程数一般会大于CPU核心数很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的计算方法：
- 线程数 = CPU核心数 * （1 + 平均等待时间/平均工作时间）

## 常见线程池的特点

- FixedThreaddPool（固定线程）
- CachedThreadPool（可缓存线程池）
- ScheduledThreadPool（周期或定时执行任务）
- SingleThreadExecutor（单线程的线程池）
{% asset_img 常见线程池.png 常见线程池%}

## 阻塞队列分析

- FixedThreadPool和SingleThreadExecutor的Queue是LinkedBlockingQueue？
- CachedThreadPool使用的Queue是SynchronousQueue？
- Scheduled Thread Pool来说，它使用的是延迟队列DelayedWoekQueue
- workStealingPool是JDK1.8加入的
  - 这个线程池和之前的都有很大不同
  - 子任务（递归）
  - 窃取

## 停止线程池的正确方法

1. shutdown 作用：当前线程池任务全部结束后关闭线程池，如果shutdown后又有线程池开启线程会抛出异常
2. isShutdown 作用：判断是否处于关闭状态（线程正在运行也有可能哦！）
3. isTerminated 作用：判断是否彻底处于关闭状态（当前没有正在运行的线程，且线程池处于关闭状态）
4. awaitTermination 作用：判断多长时间以内是否关闭了线程池
5. shutdownNow 作用：立刻强制关闭线程池，结束当前运行的线程，并抛出异常

### 任务太多，怎么拒绝

- 拒绝时机
  1. 当Executor关闭时，提交新任务会被拒绝
  2. 以及当Executor对最大线程和工作队列容量使用有限边界并且已经饱和时

### 4种拒绝策略

- AbortPolicy 直接抛出异常
- DiscardPolicy 默默的丢弃
- DiscardOldestPolicy 丢弃最老的任务
- CallerRunsPolicy 谁提交任务，谁执行
  优点：避免了业务损失；提交的速度降低，主线程一直提交任务，线程池等队列都满以后，主线程开始执行提交的线程；执行期间，线程池会执行完毕，给线程池一个缓冲的时间。

### 钩子方法

- 每个任务执行前后
- 日志、统计

```java
package MultithReading.threadpool;

import java.util.concurrent.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Description 演示每个任务执行前后放钩子函数
 * @Author Matthew
 * @Date 2020/3/16 15:04
 * @Version 1.0
 */

public class PauseableThreadPool extends ThreadPoolExecutor {

    private boolean isPaused;
    private final ReentrantLock lock = new ReentrantLock();
    private Condition unPaused = lock.newCondition();

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public PauseableThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    @Override
    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        lock.lock();
        try {

            while (isPaused) {
                unPaused.await();
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    private void pause() {
        lock.lock();
        try {
            isPaused = true;
        } catch (Exception e) {

        } finally {
            lock.unlock();
        }
    }

    public void resume() {
        lock.lock();
        try {
            isPaused = false;
            unPaused.signalAll();
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        PauseableThreadPool pauseableThreadPool = new PauseableThreadPool(10, 20, 10l, TimeUnit.SECONDS, new LinkedBlockingQueue<>());
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("我被执行");
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < 10000; i++) {
            pauseableThreadPool.execute(runnable);
        }
        Thread.sleep(1500);
        pauseableThreadPool.pause();
        System.out.println("线程池被暂停了");
        Thread.sleep(1500);
        pauseableThreadPool.resume();
        System.out.println("线程池被恢复了");
    }
}
```

## 线程池组成部分

- 线程池组成部分
  - 线程池管理器
  - 工作线程
  - 任务列队
  - 任务接口（Task）

线程池、ThreadPoolExecutor、ExecutorService、Executor、Executors等这么多和线程池相关的类，大家都是什么关系？
{% asset_img 线程池.png 线程池%}
虽然声明线程池的时候是new ThreadPoolExecutor但是返回的时候是ExecutorService，所以一般我们把ExecutorService当作线程池。

### 线程池实现任务复用的原理

- 相同线程执行不同任务

```java
if (workerCountOf(c) < corePoolSize)
    if (addWorker(command, true))
        return;
进入addWorker
w = new Worker(firstTask);
进入Worker找runWorker
我们发现相同的线程执行的Runnable的run方法不一样
Runnable task = w.firstTask;
task.run();
```

## 线程池状态

- RUNNING：接受新任务并处理排队任务
- SHUTDOWN：不接受新任务，但处理排队任务
- STOP：不接受新任务，也不处理排队任务，并中断正在进行的任务
- TIDYING，中文是整洁，理解了中文就容易理解这个状态了：所有任务都已终止，workerCount为零时，线程会转换到TIDYING状态，并将运行terminate（）钩子方法。
- TERMINATED：terminate（）运行完成

### 使用线程池的注意点

- 避免任务堆积
- 避免线程数过度增加
- 排查线程泄漏
