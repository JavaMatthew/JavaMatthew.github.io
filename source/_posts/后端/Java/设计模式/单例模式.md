---
title: 单例模式
p: 后端/Java/设计模式/单例模式
date: 2020-03-09 20:29:39
tags: [Java,设计模式]
categories: [Java,设计模式]
---
## 单例模式

### 饿汉式（静态常量）【可用】

```java
public class Singleton1 {
    private final static Singleton1 INSTANCE = new Singleton1();

    private Singleton1(){

    }

    public static Singleton1 getInstance() {
        return INSTANCE;
    }
}
```

### 饿汉式（静态代码块）（可用）

```java
public class Singleton2 {
    private final static Singleton2 INSTANCE;

    static {
        INSTANCE = new Singleton2();
    }

    private Singleton2(){

    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}
```

### 懒汉式（线程不安全）【不可用】

```java

public class Singleton3 {
    private static Singleton3 INSTANCE;

    private Singleton3() {

    }

    public static Singleton3 getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton3();
        }
        return INSTANCE;
    }
}
```

### 懒汉式（线程安全）[不推荐]

```java
public class Singleton4 {
    private static Singleton4 INSTANCE;

    private Singleton4() {

    }

    public synchronized static Singleton4 getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton4();
        }
        return INSTANCE;
    }
}

```

### 懒汉式（线程不安全）[不推荐]

```java
public class Singleton5 {
    private static Singleton5 INSTANCE;

    private Singleton5() {

    }

    public static Singleton5 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton5.class) {
                INSTANCE = new Singleton5();
            }
        }
        return INSTANCE;
    }
}
```

### 双重检查（推荐面试用）

> 优点：线程安全；延迟加载；效率较高；

- 为什么要double-check
    1. 线程安全
    2. 单check行不行？
    3. 性能问题
- 为什么要用volatile
    1. 新建对象实际上有3个步骤
    2. 重排序会带来NPE（空指针）
    3. 防止重排序

```java
public class Singleton6 {
    private static Singleton6 INSTANCE;

    private Singleton6() {

    }

    public static Singleton6 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton6.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton6();
                }
            }
        }
        return INSTANCE;
    }
}

```

在这里的双重检查想要防止的，是这种特殊情况：
“在第一个线程退出synchronized之前，里面的操作执行了一部分，比如执行了new却还没执行构造函数，然后第一个线程被切换走了，这个时候第二个线程刚刚到第一重检查，所以看到的对象就是非空，就跳过了整个synchronized代码块，获取到了这个单例对象，但是使用其中的属性的时候却不是想要的值。”
{% asset_img 单例模式.png 单例模式.png%}

### 静态内部类[推荐用]

```java
public class Singleton7 {

    private Singleton7() {
    }
    private static class SingletonInstance {
        private static volatile Singleton7 INSTANCE = new Singleton7();
    }

    public static Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```

### 枚举【推荐用】

```java
public enum  Singleton8 {
    INSTANCE;

    public void whatever() {
    }
}
```

## 不同写法对比

1. 饿汉：简单，但是没有lazy loading
2. 懒汉：有线程安全问题
3. 静态内部类：可用
4. 双重检查：面试用
5. 枚举 最好

### 用哪种单例的实现方案最好

- Joshua Bloch大神在《Effective Java》中明确表达过的观点：“适用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经称为实现Singleton的最佳方法。”
- 写法简单
- 线程安全有保障
- 避免反序列化破坏单例

### 各种写法的适用场合

1. 最好的方法时利用枚举，因为还可以防止反序列化虫棍创建新的对象；
2. 非线程同步的方法不能使用；
3. 如果程序一开始要加载的资源太多，那么就应该使用懒加载；
4. 饿汉式如果是对象的创建需要配置文件就不适用。
5. 懒加载虽然好，但是静态内部类这种方式会引入编程复杂性。

### 单例模式面试常见问题

- 饿汉式的缺点？
- 懒汉式的缺点？
- 为什么要用double-check？不用就不安全么？
- 为什么双重检查模式要用volatile？
- 应该如何选择，用哪种单例的实现方案最好？
