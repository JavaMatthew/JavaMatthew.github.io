---
title: 接口中的默认方法与静态方法
p: 后端/Java/Java8新特性/接口中的默认方法与静态方法
date: 2019-12-12 15:07:01
tags: Java
categories: [Java,Java8新特性]
---
## 接口中的默认方法

### 接口默认方法的”类优先”原则

> 若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时
    - 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。
    - 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。

```java
public class Fclass {
    public String Xiao(){
        return "呵呵呵呵呵呵";
    }
}
```

```java
public interface MyInterface1 {
    default String Xiao(){
        return "哈哈哈哈哈哈";
    }
}
```

```java
public interface MyInterface2 {
    default String Xiao(){
        return "嘿嘿嘿嘿嘿嘿嘿";
    }
}
```

```java
import org.junit.Test;

public class Cclass extends Fclass implements MyInterface1, MyInterface2 {
    @Test
    public void test1(){
        Cclass cclass = new Cclass();
        System.out.println(cclass.Xiao());
    }
}
// 结果是
// 呵呵呵呵呵呵
```

```java
public class Cclass implements MyInterface1, MyInterface2 {
    @Test
    public void test1(){
        Cclass cclass = new Cclass();
        System.out.println(cclass.Xiao());
    }

    @Override
    public String Xiao() {
        return MyInterface1.super.Xiao();
    }
}
// 结果是
// 哈哈哈哈哈哈
```

```java
import org.junit.Test;

public class Cclass implements MyInterface1, MyInterface2 {
    @Test
    public void test1(){
        Cclass cclass = new Cclass();
        System.out.println(cclass.Xiao());
    }

    @Override
    public String Xiao() {
        return MyInterface2.super.Xiao();
    }
}
// 结果是
// 嘿嘿嘿嘿嘿嘿嘿
```

## 接口中的静态方法

Java8 中，接口中允许添加静态方法

```java
public interface MyInterface1 {
    default String Xiao(){
        return "哈哈哈哈哈哈";
    }

    static void show(){
        System.out.println("我是静态方法，我再接口里面");
    }
}
```

```java
public class Fclass {
    public String Xiao(){
        return "呵呵呵呵呵呵";
    }
    static void show(){
        System.out.println("我是静态方法，我再里面");
    }
}

```

```java
import org.junit.Test;

public class Cclass implements MyInterface1, MyInterface2 {
    @Test
    public void test1(){
        Cclass cclass = new Cclass();
        System.out.println(cclass.Xiao());
//        Cclass.show();
        Fclass.show();
        MyInterface1.show();
    }

    @Override
    public String Xiao() {
        return MyInterface2.super.Xiao();
    }
}

```
