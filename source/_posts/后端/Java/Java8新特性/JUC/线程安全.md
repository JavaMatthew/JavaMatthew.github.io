---
layout: 线程安全
title: 线程安全
date: 2019-12-18 09:36:26
tags: Java
categories: [Java,JUC线程]
---

## 创建线程的方式

1. 继承Thread
2. 实现Runnable
3. 实现Callable
    一、相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常。
    二、执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果。FutureTask是Futrue接口的实现类
4. 通过线程池声明

## 显示锁 Lock同步锁

- 在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。
- ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。

1. 用于解决多线程安全问题的范式：
    synchronized：隐式锁
    1. 同步代码块
    2. 同步方法
    jdk1.5后：
    3. 同步锁Lock
        注意：是一个显示锁，需要通过lock()方法上锁，必须通过unlock()方法进行释放锁

注意：
在可能出现线程异常的地方要把释放锁放在finally中

```java
class Ticket implements Runnable {

    private int tick = 100;

    private Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try{
                if (tick > 0) {
                    try {
                        Thread.sleep(200);
                        System.out.println(Thread.currentThread().getName() + " 完成售票，余票为： " + --tick);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else {
                    break;
                }
            }finally {
                lock.unlock();
            }
        }
    }
}
```

## Condition 控制线程通信

- Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。
- 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。
- Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。

### 生产者消费者案例

```java

/**
 * 生产者和消费者案例
 */
class TestProductorAndCunsumer {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Productor productor = new Productor(clerk);
        Consumer consumer = new Consumer(clerk);
        new Thread(productor, "生产者A").start();
        new Thread(productor, "生产者B").start();
        new Thread(consumer, "消费者A").start();
        new Thread(consumer, "消费者B").start();
    }
}

//店员
class Clerk {
    private int product = 0;

    private Lock lock = new ReentrantLock();

    private Condition condition = lock.newCondition();

    //进货
    public void get() {

        try{
            lock.lock();
            //为了避免虚假唤醒问题，应该总是使用在循环中
            while (product >= 1) {
                System.out.println("产品已满！");
                try {
//                    this.wait();
                    condition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + ":" + ++product);
//            this.notifyAll();
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    //卖货
    public void sale() {
        lock.lock();
        try{
            //使用if会产生虚假唤醒问题
            while (product <= 0) {
                System.out.println("缺货！");
                try {
//                    this.wait();
                    condition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName() + ":" + --product);
//            this.notifyAll();
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}

//生产者
class Productor implements Runnable {
    private Clerk clerk;

    public Productor(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.get();
        }
    }
}

//消费者
class Consumer implements Runnable {

    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            clerk.sale();
        }
    }
}
```

## 线程按序交替

> 编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。如：ABCABCABC…… 依次递归

```java

            // 1.判断
            if (number != 1) {
                condition1.await();
            }
            // 2.打印
            for (int i = 1; i <= 1; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i + "\t" + totalLoop);
            }

            //3.唤醒
            number = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     *
     * @param totalLoop 循环第几轮
     */
    public void loopB(int totalLoop) {
        lock.lock();
        try {
            // 1.判断
            if (number != 2) {
                condition2.await();
            }
            // 2.打印
            for (int i = 1; i <= 1; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i + "\t" + totalLoop);
            }

            //3.唤醒
            number = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     *
     * @param totalLoop 循环第几轮
     */
    public void loopC(int totalLoop) {
        lock.lock();
        try {
            // 1.判断
            if (number != 3) {
                condition3.await();
            }
            // 2.打印
            for (int i = 1; i <= 1; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i + "\t" + totalLoop);
            }

            //3.唤醒
            number = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

## ReadWriteLock 读写锁

- ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。
- ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。

1. ReadWriteLock:读写锁

写写/读写需要“互斥”
读读 不需要互斥

```java

public class TestReadWriteLock {

    public static void main(String[] args) {
        ReadWriteLockDemo rw = new ReadWriteLockDemo();
        for (int i = 0; i < 10; i++) {
            new Thread(() -> rw.set(new Random().nextInt(101)), " Write:").start();
        }

        for (int i = 0; i < 100; i++) {
            new Thread(rw::get, "Read:").start();
        }
    }
}

class ReadWriteLockDemo {
    private int number = 0;

    private ReadWriteLock lock = new ReentrantReadWriteLock();

    //读
    public void get() {
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + ":" + number);
        } finally {
            lock.readLock().unlock();
        }

    }

    //写
    public void set(int number) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName());
            this.number = number;
        } finally {
            lock.writeLock().unlock();
        }
    }
}

```

## 线程八锁

一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法

- 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法
- 加个普通方法后发现和同步锁无关
- 换成两个对象后，不是同一把锁了，情况立刻变化。
- 都换成静态同步方法后，情况又变化
- 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。
- 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！

### 判断打印的“one” or “two”

1. 两个普通同步方法，两个线程，标准打印，打印？              one two
2. 新增Thread.sleep()给getOne(),打印？                    one two
3. 新增普通方法getThree()，打印？                         three one two
4. 两个普通的同步方法，两个Number对象，打印？               two     one
5. 修改getOne()为静态同步方法，打印？                      two     one
6. 修改两个方法均为静态同步方法，一个Number对象？            one    two
7. 一个静态同步方法，一个非静态同步方法，两个Number对象？     two    one
8. 两个静态同步方法，两个Number对象？                       one    two

### 线程八锁的关键

1. 非静态方法的锁默认为this，静态方法的锁为对应的Class实例
2. 某一个时刻内，只能有一个县城持有锁，无论几个方法。

## 线程池

- 第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。
- 线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。
- 为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：
  - Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）
  - Executors.newFixedThreadPool(int)（固定大小线程池）
  - Executors.newSingleThreadExecutor()（单个后台线程）它们均为大多数使用场景预定义了设置。

1. 线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建于晓辉额外开销，提高了相应的速度
2. 线程池的体系结构：
    java.util.concurrent.Executor:负责现场的使用与调度的根接口
        |--**ExectorService 子接口：线程池的主要接口
            |--ThreadPoolExecutor 线程池的实现类
            |--ScheduledExecutorService 子接口：负责线程的调度
                |--ScheduledThreadPoolExecutor: 继承ThreadPoolExecutor，实现ScheduledExecutorService
3. 工具类：Executors
    ExecutorService newFixedThreadPook()：创建固定大小的线程池
    ExecutorService newCachedThreadPool(): 缓存线程池，线程池的数量不固定，可以根据需求自动的更新数量
    ExecutorService newSingleThreadExecutor(): 创建单个线程池。线程池中只有一个线程

    ScheduledExecutorService newScheduledThreadPool(): 创建固定大小的线程，可以延迟或定时的执行任务。

```java

public class TestThreadPool {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //1. 创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(5);
        ThreadPoolDemo threadPoolDemo = new ThreadPoolDemo();
        //2. 位线程池中的线程分配任务
        Future<Long> submit = pool.submit(() -> LongStream.rangeClosed(0, 100).parallel().sum());
        System.out.println(submit.get());
//        for (int i = 0; i < 10; i++) {
//            pool.submit(threadPoolDemo);
//        }
        //3. 关闭线程池
        //shutdown 平和的关闭，等待线程池中的所有线程执行完正在执行的程序，销毁线程池
        //shutdownNow 暴力的关闭，立刻销毁线程池
        pool.shutdown();
    }
}

class ThreadPoolDemo implements Runnable{

    private int i = 0;

    @Override
    public void run() {
        while (i <= 100) {
            System.out.println(Thread.currentThread().getName() + ":" + i++);
        }
    }
}
```
