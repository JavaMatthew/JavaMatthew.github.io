---
title: 堆
p: 后端/Java/JVM/堆
date: 2020-08-27 20:35:36
tags: [Java,JVM]
categories: [Java,JVM]
---
## 概述

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
- 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理撒花姑娘不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）

## 内存细分

{% asset_img 堆空间.png 堆空间%}

新生区+养老区+元空间

- Young Generation Space 新生区 Young/New
  - 又被划分为Eden区和Survivor区
- Tenure generation space 养老区 Old/Tenure
- Meta Space 元空间 Meta

{% asset_img 差异.png 差异%}

## 堆空间的大小设置和查看

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项"-Xmx"和"-Xms"来进行设置。
  - "-Xms"用于表示堆区的起始内存，等价于-XX:InitialHeapSize
  - "-Xmx"则用于表示堆区的最大内存，等价于-XX:MaxHeapSize
- 一旦堆区中的内存大小超过"-Xmx"所指定的最大内存时，将会跑出OutOfMemoryError异常
- 通常会将-Xms和-Xmx两个参数配置相同的，**其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**
- 默认情况下，初始内存大小: 物理电脑内存大小/64
             最大内存大小: 物理电脑内存大小/4

```java
-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
    -X 是jvm的运行参数
    ms 是memory start
-Xmx 用来设置对空（年轻代+老年代）的最大内存大小
```

- 手动设置：-Xms600m -Xmx600m
  开发中建议将初始堆内存和最大的堆内存设置成相同的值
- 查看设置的参数：方式一：jps / jstart -gc 进程id
                 方式二：-XX:+PrintGCDetails

```java
-Xms: 575 M
-Xmx: 575 M
系统内存大小为：35.9375 G
系统内存大小为：2.24609375 G
Heap
 PSYoungGen      total 179200K, used 9216K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)
  eden space 153600K, 6% used [0x00000000f3800000,0x00000000f41001a0,0x00000000fce00000)
  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)
  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000)
 ParOldGen       total 409600K, used 0K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)
  object space 409600K, 0% used [0x00000000da800000,0x00000000da800000,0x00000000f3800000)
 Metaspace       used 3176K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K
```

179200K = 153600 + 25600
jvm默认from和to只有一个有数据
所以575 = （153600 + 25600 + 409600）/1024

## OutOfMemory举例（OOM内存溢出）

```java
public class OutOfMemory {
    public static void main(String[] args) {
        ArrayList<Pic> list = new ArrayList<>();
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            list.add(new Pic(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Pic{
    private byte[] pix;

    public Pic(int length) {
        pix = new byte[length];
    }
}

```

Error occurred during initialization of VM
Too small initial heap

## 年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类“
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端请胯下还能与JVM的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫作from区、to区）

下面参数开发中一般不会调整

- 配置新生代与老年代在对结构的占比
  - 默认-XX:NewRatio = 2, 表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改-XX:NewRatio = 4 ,表示新生代占1，老年代占4，新生代占整个堆的1/5

- 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1
- 当然开发人员可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio = 8
- 几乎所有的Java对象都是在Eden区被new出来的

## 对象分配过程

一般对象会出生在Eden区，经过一段时间Eden满了还在使用会转移到to区，在form和to之间转移一段时间后，迭代15次，转移到老年代。

1. 针对幸存者s0、s1区的总结：复制之后又交换，谁空谁是to
2. 关于垃圾回收：频繁在新生区手机，很少在养老区手机，几乎不再永久区/元空间收集。

{% asset_img 对象分配.png 对象分配.png%}
