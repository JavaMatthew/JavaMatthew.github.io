---
title: 排序
p: 后端/算法/排序
date: 2019-11-25 10:13:36
tags: [算法,排序]
categories: [算法,排序]
---

## 冒泡排序。（掌握交换排序，快速排序的原理与实现方式）

### arraycopy方法

这个方法是JDK提供的API，这个方法在java.lang.System。
public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)

Parameters:
src - the source array（原数组）.
srcPos - starting position in the source array（原数组中的起始位置，从此位置开始拷贝）.
dest - the destination array（目标数组）.
destPos - starting position in the destination data（目标数组的起始位置，从此位置开始接收）.
length - the number of array elements to be copied（待拷贝的的数组的个数）.

```java
public class ArrayCopy {

    public static void main(String[] args) {
        int[] a = new int[] {1, 2, 3, 4};

        int[] b = new int[4];

        System.arraycopy(a, 0, b, 0, 4);

        for(int i = 0;i < b.length; i++) {
            System.out.print(b[i]+" ");
        }

    }

}
```

***结果是
1 2 3 4***

1. 冒泡排序
拿个数组举例将下列数组升序排序
第一次排序
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181217215026783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70)
第二次排序
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181217215123280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNzMzMg==,size_16,color_FFFFFF,t_70)
依次排序排列成**3 4 5 7 9**

设置一个方法接受参数int[]类型的数组将顺序排好再返回（升序排列）

```java
public class BubbleSortTest {

    public static int[] bubbleSort(int[] a) {
        for(int i = 0;i < a.length; i++) {
            for(int j = 1;j < a.length-i; j++) {
                if(a[j-1] > a[j]) {
                    int temp = a[j-1];
                    a[j-1] = a[j];
                    a[j] = temp;
                }
            }
            System.out.print("第" + (i + 1) + "趟排序");
            for(int k = 0; k < a.length; k++) {
                System.out.print(a[k] + " ");
            }
            System.out.println();
            //提升效率，如果没有发生比较直接返回数组
        }
        return a;
    }

    public static void main(String[] args) {
        int[] a = new int[5];
        a[0] = 5;
        a[1] = 4;
        a[2] = 7;
        a[3] = 9;
        a[4] = 3;

        System.out.print("排序之前:");
        for(int i = 0;i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
        a = bubbleSort(a);

        System.out.print("排序之后:");
        for(int i = 0;i < a.length; i++) {
            System.out.print(a[i] + " ");
        }

    }

}
```

***排序之前:5 4 7 9 3
第1趟排序4 5 7 3 9
第2趟排序4 5 3 7 9
第3趟排序4 3 5 7 9
第4趟排序3 4 5 7 9
第5趟排序3 4 5 7 9
排序之后:3 4 5 7 9***
==优化之后==

```java
public class BubbleSortTest {

    public static int[] bubbleSort(int[] a) {
        boolean x = true;
        for(int i = 0;i < a.length; i++) {
            x = true;
            for(int j = 1;j < a.length-i; j++) {
                if(a[j-1] > a[j]) {
                    int temp = a[j-1];
                    a[j-1] = a[j];
                    a[j] = temp;
                    x = false;
                }

            }
            System.out.print("第" + (i + 1) + "趟排序");
            for(int k = 0; k < a.length; k++) {
                System.out.print(a[k] + " ");
            }
            System.out.println();
            if(x) {             //提升效率，如果没有发生比较直接返回数组
                return a;
            }
        }
        return a;
    }

    public static void main(String[] args) {
        int[] a = new int[10];
        a[0] = 5;
        a[1] = 4;
        a[2] = 7;
        a[3] = 9;
        a[4] = 3;
        a[5] = 45;
        a[6] = 1;
        a[7] = 4;
        a[8] = 8;
        a[9] = 3;

        System.out.print("排序之前:");
        for(int i = 0;i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
        a = bubbleSort(a);

        System.out.print("排序之后:");
        for(int i = 0;i < a.length; i++) {
            System.out.print(a[i] + " ");
        }

    }

}
```

结果是
排序之前:5 4 7 9 3 45 1 4 8 3
第1趟排序4 5 7 3 9 1 4 8 3 45
第2趟排序4 5 3 7 1 4 8 3 9 45
第3趟排序4 3 5 1 4 7 3 8 9 45
第4趟排序3 4 1 4 5 3 7 8 9 45
第5趟排序3 1 4 4 3 5 7 8 9 45
第6趟排序1 3 4 3 4 5 7 8 9 45
第7趟排序1 3 3 4 4 5 7 8 9 45
第8趟排序1 3 3 4 4 5 7 8 9 45
排序之后:1 3 3 4 4 5 7 8 9 45

快速排序也是交换排序的一种，在后面介绍。
