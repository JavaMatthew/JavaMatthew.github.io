---
title: this和对象
p: 前端/JS/this和对象
date: 2020-02-15 12:20:26
tags: [前端,JS]
categories: [前端,JS]
---

## this

- 解析器在调用函数每次都会向函数内部传递进一共隐含的参数，
  - 这个隐含的额参数就是this，this指向的是一个对象，
  - 这个对象我们成为函数执行的上下文对象，
  - 根据函数的**调用方式**的不同，this会指向不同的对象。
    1. 以函数的形式调用时，this永远都是window
    2. 以方法的形式调用时，this就是调用方法的那个对象

## 构造函数

创建一共构造函数，专门用来创建Person对象的
    构造函数就是一共普通函数，创建方式和普通函数没有区别，不同的时构造函数习惯上首字母大写
构造函数和普通函数的区别就是调用方式的不同
    普通函数时直接调用，而构造函数需要使用new关键字来调用

```js
function Person(name,age,gender) {
    this.name = name
    this.age= age
    this.gender = gender
    this.sayName = function(){
        console.dir(obj)
    }
}
var per = new Person() // [object Object]
//  var per = Person()    undefined
console.log(per)
```

### 构造函数的执行流程

1. 立即创建一共新的对象
2. 将新建的对象设置为函数中this，在构造函数中可以使用this来引用新建的对象
3. 逐行执行函数中的代码
4. 将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们成为一类对象，也将一共构造函数称为一共类。
    我们将通过一个构造函数创建的对象，称为时该类的实例

this的情况：
    1. 当以函数的形式调用时，this是window
    2. 当以方法的形式调用时，谁调用方法this就是谁
    3. 当以构造函数的形式调用时，this就是新创建的那个对象

使用instanceof可以检查一共对象是否是一共类的实例
  语法：
    对象 instanceof 构造函数
如果时，则返回true，否则返回false
所有对象都是Object的后代，所以任何对象和Object作instanceof检查时都会返回true

创建一共Person构造函数
在Person构造函数中，为每一个对象都添加了一共sayName方法，
    目前我们的方法是在构造函数内部创建的，
        也就是构造函数每执行一次就会创建一共新的sayName方法
    也是所有实例的sayName都是唯一的
    这样就导致了构造函数执行一次就会创建一共新的方法，
        执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的
        这是完全没有必要的，完全可以使所有的对象共享同一个方法

## 原型prototype

我们所创建的每一个函数，解析器都会向函数中添加一共属性prototype
    这个属性对应着一个对象，这个对象就是我们所谓的原型对象
如果函数作为普通函数调用prototype没有任何作用
当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性
